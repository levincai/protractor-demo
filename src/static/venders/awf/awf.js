/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*	Base
	------------------------------------------*/
		__webpack_require__(1);


	/*	UI Components
	------------------------------------------*/
		__webpack_require__(92);


	/*	User
	------------------------------------------*/
		__webpack_require__(182);


	/*	Congitive
	------------------------------------------*/
		// When we have a cognitive layer, it'll go here.
		// require('./components/cognitive/cognitive.js');


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject = __webpack_require__(2);

	/*	AWF
	------------------------------------------*/
		/**
		 * @namespace awf
		 * @type {Object}
		 *
		 * @description It all starts here. The awf namespace provides a starting point for the functions and capabilities of the Adaptive Workplace Foundation (AWF). Just pass an [awfConfig]{@link awf.awfConfig} object to the [init()]{@link awf.init} function and let the magic begin.
		 *
		 * @property {string} VERSION The version of this AWF instance.
		 */

		var awf = new BaseObject();
		window.awf = awf;


	/*	Soft-failing on local storage
	------------------------------------------*/
		__webpack_require__(7);


	/*	Util
	------------------------------------------*/
		/**
		 * @namespace awf.util
		 * @type {object}
		 *
		 * @description A namespace that provides access to some utility functions of the AWF.
		 */
		awf.util = __webpack_require__(8);


	/*	IE11 Will crash if console.time related
	* 	methods are called without the console
	* 	window open.
	------------------------------------------*/
		if (awf.util.info.browser.ie) {
			window.console.time = function () {};
			window.console.timeEnd = function () {};
			window.console.timeStamp = function () {};
		}


	/*	Adding Base Object
	------------------------------------------*/
		/**
		 * @namespace awf.__
		 * @type {Object}
		 *
		 * @description A namespace that provides access to the non-ui classes of the AWF.
		 */

		awf.__ = {
			BaseObject: __webpack_require__(2)
		};


	/*	jQuery
	------------------------------------------*/
		var $ = __webpack_require__(4);
		awf.$ = $;

		__webpack_require__(42);


	/*	Lodash
	------------------------------------------*/
		var _ = __webpack_require__(5);
		awf._ = _;

		// Make lodash templates use mustache style
		awf._.templateSettings = {
			evaluate:    /\{\[([\s\S]+?)\]\}/g,
			interpolate: /{{([\s\S]+?)}}/g,
			escape:      /{{{([\s\S]+?)}}}/g
		};


	/*	awf.VERSION
	------------------------------------------*/
		var version_data = _.merge({},
				__webpack_require__(43),
				__webpack_require__(44)),
			version = _.template('{{major}}.{{minor}}.{{patch}} {{name}} - {{date}}.{{iteration}}')(version_data);

		Object.defineProperty(awf, 'VERSION', {
			get: function () { return version; }
		});


	/*	Snippets
	------------------------------------------*/
		__webpack_require__(45);


	/*	Init
	------------------------------------------*/
		// module that provides the init function
		awf.init = __webpack_require__(46);


	/*	Classes
	------------------------------------------*/
		// module that sets the requires for the awf.__ classes and creates an instance of awf.app
		__webpack_require__(54);


	/*	Construct
	------------------------------------------*/
		awf.construct = new awf.__.ConstructService({
			local_storage_key: 'awf.construct'
		});


	/*	Helpers
	------------------------------------------*/
		/* Polyfill for Number.isInteger */
		Number.isInteger = Number.isInteger || function(value) {
			return typeof value === "number" &&
				   isFinite(value) &&
				   Math.floor(value) === value;
		};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = BaseObject;

	var extendJQueryEvents = __webpack_require__(3);

	/**
	 * BaseObject
	 * @class
	 * @memberOf awf.__
	 */
	function BaseObject () {
		//
	}


	/**
	 * @function
	 * @instance
	 * @name on
	 * @memberOf awf.__.BaseObject
	 * @description Attaches a listener to events triggered from this object
	 * @return {object} this (chainable)
	 */

	/**
	 * @function
	 * @instance
	 * @name off
	 * @memberOf awf.__.BaseObject
	 * @description Removes a listener to events triggered from this object
	 * @return {object} this (chainable)
	 */

	/**
	 * @function
	 * @instance
	 * @name triggerHandler
	 * @memberOf awf.__.BaseObject
	 * @description Triggers an event on this object
	 * @return {object} this (chainable)
	 */


	/*	Prototype Methods
	------------------------------------------*/
		extendJQueryEvents(BaseObject.prototype);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = extendJQueryEvents;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	/**
	 * Mixes in the jQuery Event Emitter functions to the given object
	 * @memberOf awf.util
	 * @param  {object} target Usually a class prototype
	 * @return {undefined}
	 *
	 * @example
	 * function ClassXYZ () {
	 *  //
	 * }
	 *
	 * var xyz = new ClassXYZ();
	 * xyz.on('my-event', function () { console.log('my-event was called'); }); // throws JS error, since the `on` function does not exist
	 *
	 * extendJQueryEvents(ClassXYZ.prototype);
	 * xyz.on('my-event', function () { console.log('my-event was called'); }); // works!
	 *
	 * xyz.trigger('my-event'); // logs 'my-event was called'
	 * 
	 */
	function extendJQueryEvents (target) {
		_.forEach(['on','off','trigger','one','triggerHandler'], function (ev) {
			target[ev] = function () {
				$.fn[ev].apply($(this), arguments);
				return this;
			};
		});
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.0
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-08T20:02Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.0",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Support: IE11 only
		// In IE 11 fullscreen elements inside of an iframe have
		// 100x too small dimensions (gh-1764).
		if ( document.msFullscreenElement && window.top !== window ) {

			// Support: IE11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if ( elem.getClientRects().length ) {
				val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
			}
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					// Support: IE<11
					// option.value not trimmed (#14858)
					return jQuery.trim( elem.value );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
								jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true

					// Previously, `originalEvent: {}` was set here, so stopPropagation call
					// would not be triggered on donor event, since in our own
					// jQuery.event.stopPropagation function we had a check for existence of
					// originalEvent.stopPropagation method, so, consequently it would be a noop.
					//
					// But now, this "simulate" function is used only for events
					// for which stopPropagation() is noop, so there is no need for that anymore.
					//
					// For the compat branch though, guard for "click" and "submit"
					// events is still used, but was moved to jQuery.event.stopPropagation function
					// because `originalEvent` should point to the original event for the constancy
					// with other events and for more focused logic
				}
			);

			jQuery.event.trigger( e, null, elem );

			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8+
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		context = context || ( support.createHTMLDocument ?
			document.implementation.createHTMLDocument( "" ) :
			document );

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				// Subtract offsetParent scroll positions
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ) -
					offsetParent.scrollTop();
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true ) -
					offsetParent.scrollLeft();
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.10.1';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;

	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;

	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }

	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);

	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;

	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);

	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;

	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;

	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);

	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      if (pathKey !== undefined && pathKey in toObject(object)) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];

	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value && (value !== undefined || (key in toObject(object)));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');

	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);

	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;

	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;

	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;

	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;

	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);

	      view.set(new Uint8Array(buffer));
	      return result;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;

	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;

	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }

	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }

	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }

	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }

	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);

	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }

	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }

	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }

	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }

	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }

	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }

	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }

	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);

	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = func.name,
	          array = realNames[result],
	          length = array ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');

	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;

	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }

	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func);
	      if (!(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      var other = lodash[funcName];
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;

	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;

	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          result = [];

	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];

	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);

	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it is invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;

	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }

	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);

	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;

	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;

	      var interceptor = function(value) {
	        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      return baseAt(collection, baseFlatten(props));
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Checks if `value` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it is
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;

	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];

	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);

	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });

	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);

	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, isDeep);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, true);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 equivalents which return 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }

	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && reIsHostCtor.test(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object)));
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object != 'function' && isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object)) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);

	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });

	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it is invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : object[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : object[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }

	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it is created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it is set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);

	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }

	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);

	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);

	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), path + '');
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it is
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }

	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);

	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };

	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name,
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	try {
		var key = '__--foo--__',
			is_set = key in Object.keys(localStorage),
			val = localStorage.getItem(key);
		localStorage.setItem(key,'__--bar--__');
		if (is_set)
			localStorage.setItem(key,val);
		else
			localStorage.removeItem(key);
	} catch (er) {
		console.warn('localStorage.setItem() will not work (you are likely in a private session). The method has been reassigned to a console warning to avoid crashing the browser.');
		localStorage.setItem = function (key) {
			console.warn('localStorage.setItem was called. The attempt to assign `' + key + '` was ignored.');
		};
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
			obj = {
				at                       : __webpack_require__(9),
				bindFlipper              : __webpack_require__(10),
				transitionHandler        : __webpack_require__(11),
				createCallback           : __webpack_require__(12),
				createExtendableFunction : __webpack_require__(13),
				event                    : __webpack_require__(15),
				isPromise                : __webpack_require__(14),
				isLocalStorageSafe       : __webpack_require__(16),
				list                     : __webpack_require__(17),
				logPromise               : __webpack_require__(18),
				url_params               : __webpack_require__(19),
				urlParams                : __webpack_require__(20),
				use                      : __webpack_require__(21),
				randomID                 : __webpack_require__(22),
				reducedOrder             : __webpack_require__(23),
				keyCodes                 : __webpack_require__(24),
				showFocus                : __webpack_require__(25),
				consoleToggle            : __webpack_require__(26),
				runPromiseSequence       : __webpack_require__(27),
				string                   : __webpack_require__(28),
				speak                    : __webpack_require__(29),
				info                     : __webpack_require__(30),
				postMessage              : __webpack_require__(31),
				urlDelayedDeferred       : __webpack_require__(32)
			};

	_.extend(obj, __webpack_require__(33));
	_.extend(obj, __webpack_require__(34));

	// Extend jQuery selectors
	$.extend($.expr[':'], __webpack_require__(35));

	// Extend jQuery methods
	$.fn.extend({
		simulate: __webpack_require__(36)
	});

	obj.mixin = __webpack_require__(37);

	__webpack_require__(41);

	module.exports = obj;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	module.exports = function at (date) {

		var dfr = $.Deferred(),
			now = new Date(),
			delta = date - now;

		if (delta >= 0) {
			setTimeout(function () {
				dfr.resolve(delta);
			}, delta);
		} else {
			dfr.reject();
		}

		return dfr;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = bindFlipper;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	/**
	 * Binds flip open/close events & animation to two Card components.
	 * <br>Start a flip open by triggering 'request-open' on
	 * <em>opener</em>, and start a flip close by triggering
	 * 'request-close' on <em>closer</em>.
	 * @memberOf awf.util
	 * @param {awf.ui.TitledCard|awf.ui.IconCard} opener The component instance for the opener.
	 * @param {awf.ui.LargeCard} closer The component instance for the closer.
	 *
	 * @example
	 * // earlier in your code...
	 *
	 * var titled_card = new awf.ui.TitledCard(),
	 *     large_card = new awf.ui.LargeCard();
	 *
	 * // later in your code...
	 * awf.util.bindFlipper(titled_card, large_card)
	 *
	 * @fires opener#flip-start when opener starts to flip
	 * @fires opener#flip-half-complete when opener finishes flip and closer starts to flip
	 * @fires opener#flip-complete when closer finishes flip
	 * @fires closer#flip-start when closer starts to flip
	 * @fires closer#flip-half-complete when closer finishes flip and opener starts to flip
	 * @fires closer#flip-complete when opener finishes flip
	 */
	function bindFlipper (opener, closer) {
		var opener_is_titled_instance = opener instanceof awf.ui.TitledCard,
			opener_is_icon_instance = opener instanceof awf.ui.IconCard,
			opener_is_large_instance = opener instanceof awf.ui.LargeCard,
			closer_is_large_instance = closer instanceof awf.ui.LargeCard;

		if( ! opener || ! closer)
			throw new Error('Bind Flip: Flip animation cannot be applied without an opener AND closer');

		if( opener_is_large_instance || (! opener_is_icon_instance && ! opener_is_titled_instance))
			throw new Error('Bind Flip: The opener must be an instance of awf.ui.TitledCard or awf.ui.IconCard');

		if( ! closer_is_large_instance)
			throw new Error('Bind Flip: The closer must be an instance of awf.ui.LargeCard');

		//if duration is changed, here, it also needs
		//to be changed in Card component's CSS
		var duration = 200,
			delay = 200;

		opener.on('request-open', function () {
			// TODO: check if flip is allowed, including whether
			// 'modal' parameter has been passed.

			// Is modal_available_flag a thing?
			if (_.get(awf, 'app.experience.modal_available_flag')) {
				// Does it say that modal is unavailable?
				if ( ! awf.app.experience.modal_available_flag.value) {
					// Then don't do it!
					return false;
				}
			}

			if (awf.drag_handler.active) {
				return false;
			}

			if ($('body').hasClass('flipping')) {
				return false;
			}

			$('body').addClass('flipping');
			opener.triggerHandler('flip-start');
			opener.$el.addClass('-flip');

			if (closer.$el === null) {
				closer.render();
			}

			closer.$el
				.css('visibility','hidden')
				.addClass('-flip');

			setTimeout(function () {
				opener.$el.css('visibility','hidden');
				opener.triggerHandler('flip-half-complete');
			}, duration + (delay/2));
		});

		opener.on('flip-half-complete', function () {
			if ( ! awf.modal) {
				awf.modal = new awf.ui.Modal({ parent: $('body') });
			}

			awf.modal
				.render()
				.setContent(closer.$el)
				.setActiveState(true)
				.setWidth(awf.app.experience.modal_width);

			//TODO: move to setActiveState
			awf.modal.$el.hide().fadeIn('fast');

			awf.modal.on('request-close.' + closer.aria_id, function () {
				closer.triggerHandler('request-close');
			});

			// setTimeout(function () {
				closer.$el
					.css('visibility','')
					.removeClass('-flip');
			// }, delay);

			setTimeout(function () {
				closer.children.close.$el.focus();
				opener.triggerHandler('flip-complete');
			}, duration + delay);

		});

		opener.on('flip-complete', function () {
			$('body').removeClass('flipping');
		});


		//Reverse! Reverse!
		closer.on('request-close', function () {
			// TODO: check if flip is allowed, including whether
			// 'modal' parameter has been passed.

			if ($('body').hasClass('flipping'))
				return false;

			$('body').addClass('flipping');
			closer.triggerHandler('flip-start');
			closer.$el.addClass('-flip');
			opener.$el
				.css('visibility','hidden')
				.addClass('-flip');

			setTimeout(function () {
				closer.triggerHandler('flip-half-complete');
			}, duration + (delay/2));

		});

		closer.on('flip-half-complete', function () {
			awf.modal.$el.fadeOut('fast', function () {
				awf.modal.setActiveState(false);
				awf.modal.off('request-close.' + closer.aria_id);
				closer.destroy();
				awf.modal
					.setContent(null)
					.destroy();
			});

			setTimeout(function () {
				opener.$el
					.css('visibility','')
					.removeClass('-flip');
			}, delay);

			setTimeout(function () {
				opener._$card.focus();
				closer.triggerHandler('flip-complete');
			}, duration + delay);
		});

		closer.on('flip-complete', function () {
			$('body').removeClass('flipping');
		});

	}

	//                                                      _______
	//                                                .,add88YYYYY88ba,
	//                                           .,adPP""'         `"Yba___,aaadYPPba,
	//                                       .,adP""                .adP""""'     .,Y8b
	//                                    ,adP"'                __  d"'     .,ad8P""Y8I
	//                                 ,adP"'                  d88b I  .,adP""'   ,d8I'
	//                               ,adP"                     Y8P" ,adP"'    .,adP"'
	//                              adP"                        "' dP"     ,adP""'
	//                           ,adP"                             P    ,adP"'
	//                   .,,aaaad8P"                                 ,adP"
	//              ,add88PP""""'                                  ,dP"
	//           ,adP""'                                         ,dP"
	//         ,8P"'                                            d8"
	//       ,dP'                                              dP'
	//       `"Yba                                             Y8
	//         `"Yba                                           `8,
	//           `"Yba,                                         8I
	//              `"8b                                        8I
	//                dP                              __       ,8I
	//               ,8'                            ,d88b,    ,d8'
	//               dP                           ,dP'  `Yb, ,d8'
	//              ,8'                         ,dP"      `"Y8P'
	//              dP                        ,8P"
	//             ,8'                      ,dP"
	//             dP                     ,dP"
	//            ,8'                    ,8P'
	//            I8                    dP"
	//            IP                   dP'
	//            dI                  dP'
	//           ,8'                 dP'
	//           dI                 dP'
	//           8'                ,8'
	//           8                ,8I
	//           8                dP'
	//           8               ,8'
	//           8,              IP'
	//           Ib             ,dI
	//           `8             I8'
	//            8,            8I
	//            Yb            I8
	//            `8,           I8
	//             Yb           I8
	//             `Y,          I8
	//              Ib          I8,
	//              `Ib         `8I
	//               `8,         Yb
	//                I8,        `8,
	//                `Yb,        `8a
	//                 `Yb         `Yb,
	//                  I8          `Yb,
	//                  dP            `Yb,
	//                 ,8'              `Yb,
	//                 dP                 `Yb,
	//                d88baaaad88ba,        `8,
	//                   `"""'   `Y8ba,     ,dI
	//                              `""Y8baadP'


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = transitionHandler;

	var $ = __webpack_require__(4);

	/**
	 * Binds transition open/close events & animation to two Card components.
	 * <br>Start a transition open by triggering 'request-open' on
	 * <em>opener</em>, and start a transition close by triggering
	 * 'request-close' on <em>closer</em>.
	 * @memberOf awf.util
	 * @param {awf.ui.TitledCard|awf.ui.IconCard} opener The component instance for the opener.
	 * @param {awf.ui.LargeCard} closer The component instance for the closer.
	 *
	 * @example
	 * // earlier in your code...
	 *
	 * var titled_card = new awf.ui.TitledCard(),
	 *     large_card = new awf.ui.LargeCard();
	 *
	 * // later in your code...
	 * awf.util.transitionHandler(titled_card, large_card)
	 *
	 * @fires opener#transition-start when opener starts to transition
	 * @fires opener#transition-half-complete when opener finishes transition and closer starts to transition
	 * @fires opener#transition-complete when closer finishes transition
	 * @fires closer#transition-start when closer starts to transition
	 * @fires closer#transition-half-complete when closer finishes transition and opener starts to transition
	 * @fires closer#transition-complete when opener finishes transition
	 */
	function transitionHandler (opener, closer) {
		var opener_is_titled_instance = opener instanceof awf.ui.TitledCard,
			opener_is_icon_instance = opener instanceof awf.ui.IconCard,
			opener_is_large_instance = opener instanceof awf.ui.LargeCard,
			closer_is_large_instance = closer instanceof awf.ui.LargeCard;

		if( ! opener || ! closer)
			throw new Error('Bind Transition: Transition animation cannot be applied without an opener AND closer');

		if( opener_is_large_instance || (! opener_is_icon_instance && ! opener_is_titled_instance))
			throw new Error('Bind Transition: The opener must be an instance of awf.ui.TitledCard or awf.ui.IconCard');

		if( ! closer_is_large_instance)
			throw new Error('Bind Transition: The closer must be an instance of awf.ui.LargeCard');

		//if duration is changed, here, it also needs
		//to be changed in Modal component's CSS
		var duration = 200,
			delay = 10;

		opener.on('request-open', function () {
			// TODO: check if transition is allowed, including whether
			// 'modal' parameter has been passed.

			if (awf.drag_handler.active)
				return false;

			if ($('body').hasClass('awf-transitioning'))
				return false;

			$('body').addClass('awf-transitioning');
			opener.$el.animate({
				'opacity': 0
			}, (duration/2));
			opener.triggerHandler('transition-start');


			if(closer.$el === null)
				closer.render();

			opener.triggerHandler('transition-half-complete');
		});

		opener.on('transition-half-complete', function () {

			if ( ! awf.modal)
				awf.modal = new awf.ui.Modal({parent: $('body')});

			awf.modal
				.render()
				.setContent(closer.$el)
				.setWidth(awf.app.experience.modal_width)
				.setActiveState(true)
				.$el.addClass('awf-transition awf-transition--scale-fade -inner-hidden');

			awf.modal.on('request-close.' + closer.aria_id, function () {
				closer.triggerHandler('request-close');
			});

			setTimeout(function () {
				awf.modal.$el
					.removeClass('-inner-hidden');
			}, delay);

			setTimeout(function () {
				closer.children.close.$el.focus();
				opener.triggerHandler('transition-complete');
			}, duration + delay);

		});

		opener.on('transition-complete', function () {
			$('body').removeClass('awf-transitioning');
		});


		//Reverse! Reverse!
		closer.on('request-close', function () {
			// TODO: check if transition is allowed, including whether
			// 'modal' parameter has been passed.

			if ($('body').hasClass('awf-transitioning'))
				return false;

			$('body').addClass('awf-transitioning');
			closer.triggerHandler('transition-start');

			awf.modal.$el
				.removeClass('awf-transition')
				.addClass('-inner-hidden');

			setTimeout(function () {
				closer.triggerHandler('transition-half-complete');
			}, duration);

			opener.$el.animate({
				'opacity': 1
			}, (duration/2));
		});

		closer.on('transition-half-complete', function () {
			awf.modal.setActiveState(false);
			awf.modal.off('request-close.' + closer.aria_id);
			closer.destroy();
			awf.modal
				.setContent(null)
				.destroy();
			opener._$card.focus();


			closer.triggerHandler('transition-complete');
		});

		closer.on('transition-complete', function () {
			$('body').removeClass('awf-transitioning');
		});

	}


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = createCallback;

	var callback_index = 0,
		callbacks = {};

	/**
	 * Dynamically generates a global method to be called later
	 * @memberOf awf.util
	 * @param {function} fn - method to run when the callback is called.
	 * @returns {String} of the method name that can be used as the jsonp callback name of a request
	 */
	function createCallback (fn) {
		return new Callback(fn).string;
	}

	function Callback (fn)
	{
		var self = this;
		self.string = "awfcallback" + (++callback_index);

		window[self.string] = function () {
			fn.apply(window, arguments);
			window[self.string] = null;
		};
		window.last_awf_callback = self.string;
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
		isPromise = __webpack_require__(14);

	module.exports = function () {

			// All values will be functions
			var preps = {},
				callbacks = {},
				resolutions = [],
				rejections = [],
				self = this;

			// The returned function. Unless it is extended, it will do nothing but return a resolved promise.
			var extendableFunction = function () {

				var args = arguments;

				/*	Prep
				------------------------------------------*/
					_.forEach(preps, function (fn, id) {
						console.group('running init prep `' + id + '`');
						fn.apply(fn, args || [{}]);
						console.groupEnd();
					});


				/*	Callbacks
				------------------------------------------*/
					var dfr = $.Deferred(),

						active_callbacks = _.filter(callbacks, function (cb) { return ! cb.muted; }),

						responses = _.mapValues(active_callbacks, function (fn) {
							var ret;
							//try {
								ret = fn.apply(fn, args || [{}]);
							/*} catch (er) {
								dfr.reject(er);
								throw new Error(er);
							}*/
							return ret;
						}),
						response_done_count = 0,
						response_done_total = 0;

					dfr
						.done(function () {
							var args = arguments;
							_.forEach(resolutions, function (resolution) {
								resolution.apply(self, args);
							});
							resolutions = [];
						})
						.fail(function (er) {
							var args = arguments;
							_.forEach(rejections, function (rejection) {
								rejection.apply(self, args);
							});
							rejections = [];
						});

					// Gather totals first, otherwise if the first one returns a resolved promise, it'll resolve the main dfr without checking the rest.
					_.forEach(responses, function (response, key) {
						if (isPromise(response))
							response_done_total++;
					});

					// If none of the extended functions have promises, no waiting needed! resolve the main dfr immediately
					if (response_done_total === 0) {
						dfr.resolve(responses);
					} else {
						// otherwise, set it up to wait for all of them.
						_.forEach(responses, function (response, key) {
							if (isPromise(response)) {
								response
									.done(function () {
										// once a response dfr completes, update the response to the final result
										responses[key] = arguments;

										// if all promises have been resolved, resolve the main dfr
										if ((++response_done_count) == response_done_total)
											dfr.resolve(responses);
									})
									.fail(function (er) {
										dfr.reject(er);
									});
							}
						});
					}


				/*	return
				------------------------------------------*/
					return dfr.promise();
			};





		/*	Adding prep
		------------------------------------------*/
			extendableFunction.prep = function (obj) {
				_.extend(preps, obj);
				return this;
			};





		/*	Adding 'extend'
		------------------------------------------*/
			extendableFunction.extend = function (obj) {
				_.extend(callbacks, obj);
				return this;
			};



		/*	Adding 'done'
		------------------------------------------*/
			extendableFunction.done = function (callback) {
				resolutions.push(callback);
				return this;
			};



		/*	Adding 'fail'
		------------------------------------------*/
			extendableFunction.fail = function (callback) {
				rejections.push(callback);
				return this;
			};



		/*	Adding 'omit'
		------------------------------------------*/
			extendableFunction.omit = function (keys) {
				callbacks = _.omit(callbacks, keys);
			};




		/*	Adding 'mute'
		------------------------------------------*/
			extendableFunction.mute = function (keys) {
				if (typeof keys == 'string')
					keys = [keys];

				_.forEach(keys, function (key) {
					callbacks[key].muted = true;
				});
			};

		/*	Adding 'muteOthers'
		------------------------------------------*/
			extendableFunction.muteOthers = function (keys) {
				if (typeof keys == 'string')
					keys = [keys];

				_.forEach(callbacks, function (cb, key) {
					cb.muted = ! _.contains(keys, key);
				});
			};


		/*	Adding 'unmute'
		------------------------------------------*/
			extendableFunction.unmute = function (keys) {
				if (typeof keys == 'string')
					keys = [keys];

				_.forEach(keys, function (key) {
					callbacks[key].muted = false;
				});
			};


		/*	Adding 'unmuteAll'
		------------------------------------------*/
			extendableFunction.unmuteAll = function () {
				_.forEach(callbacks, function (val, key) {
					callbacks[key].muted = false;
				});
			};





		/*	Adding 'preps'
		 *	useful for debugging
		------------------------------------------*/
			Object.defineProperty(extendableFunction, "preps", {
				enumerable: true,
				get: function () { return _.keys(preps); }
			});


		/*	Adding 'callbacks'
		 *	useful for debugging
		------------------------------------------*/
			Object.defineProperty(extendableFunction, "callbacks", {
				enumerable: true,
				get: function () { return _.keys(callbacks); }
			});


		/*	Adding 'muted_callbacks'
		 *	useful for debugging
		------------------------------------------*/
			Object.defineProperty(extendableFunction, "muted_callbacks", {
				enumerable: true,
				get: function () {
					var ret = [];
					_.forEach(callbacks, function (cb, name) {
						if (cb.muted)
							ret.push(name);
					});
					return ret;
				}
			});


		/*	Adding 'active_callbacks'
		 *	useful for debugging
		------------------------------------------*/
			Object.defineProperty(extendableFunction, "active_callbacks", {
				enumerable: true,
				get: function () {
					var ret = [];
					_.forEach(callbacks, function (cb, name) {
						if ( ! cb.muted)
							ret.push(name);
					});
					return ret;
				}
			});


		return extendableFunction;

	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	module.exports = function isPromise (value) {
		if ( ! (value && typeof value.done === "function")) {
			return false;
		}
		var promiseDoneSrc = String(awf.$.Deferred().done),
			valueDoneSrc = String(value.done);
		return promiseDoneSrc === valueDoneSrc;
	};


/***/ },
/* 15 */
/***/ function(module, exports) {

	// todo: unit tests
	module.exports = {


		/**
		 * @name  event
		 * @namespace
		 * @memberOf awf.util
		 */


		/**
		 * Checks if passed key exists as a localStorage item.
		 * @memberOf awf.util.event
		 * @function
		 * @param {string} key The localStorage item to check
		 *
		 * @return {null|number} `null` if no localStorage item exists, otherwise
		 * it will return the number of milliseconds since the key was claimed
		 */
		check: function (key) {
			var value = localStorage.getItem('events:' + awf.app.id + ':' + key);

			if (value) {
				var now = new Date();
				value = new Date(value);
				return ( now.getTime() - value.getTime() );
			} else {
				return null;
			}
		},


		/**
		 * Sets localStorage item with passed key and sets the value
		 * to the time it was claimed (`new Date()`).
		 * @memberOf awf.util.event
		 * @function
		 * @param {string} key The localStorage item to claim
		 *
		 * @return {Date} The date/time the item was claimed ("now")
		 */
		claim: function (key) {
			var now = new Date();
			localStorage.setItem('events:' + awf.app.id + ':' + key, now);
			return now;
		},


		/**
		 * Removes the localStorage item with passed key, if it exists.
		 * @memberOf awf.util.event
		 * @function
		 * @param {string} key The localStorage item to claim
		 *
		 * @return {null|date} The date/time the item was claimed, or `null`
		 * if the item doesn't exist
		 */
		unClaim: function (key) {
			var value = localStorage.getItem('events:' + awf.app.id + ':' + key);

			if (value) {
				localStorage.removeItem('events:' + awf.app.id + ':' + key);
				return value;
			} else {
				return null;
			}
		}

	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = isLocalStorageSafe;

	/**
	 * Checks if localStorage will actually save a value from session to session
	 * @memberOf awf.util
	 * @return {Boolean}
	 */
	function isLocalStorageSafe () {

		var longevity_key = '__longevity_test__',
			longevity_val = localStorage.getItem(longevity_key);

		if (longevity_val === null) {
			// set a date to check later
			// do NOT declare this as safe or unsafe..
			localStorage.setItem(longevity_key, (new Date()).getTime());
		} else {
			var then = new Date(parseInt(longevity_val)),
				now = new Date(),
				delta = now - then;
			if (delta > (1000 * 60 * 60 * 48))
				return true;
		}




		var session_key = '__session_test__',
			first_time_this_session = sessionStorage.getItem(session_key) === null,
			local_val = localStorage.getItem(session_key);
		
		if (first_time_this_session)
			sessionStorage.setItem(session_key, 'ping');
			
		switch (local_val) {
			case null:
				if (first_time_this_session)		
					localStorage.setItem(session_key, '1');
				return false;

			case '1':
				if (first_time_this_session)
					localStorage.setItem(session_key, '2');
				return false;
		}

		return true;
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);

	module.exports = function list (arr, connector, wrapper) {
		if ( ! _.isArray(arr) ) {
			throw new Error('Cannot make list from a non-array');
		}

		connector = connector || 'and';
		wrapper = wrapper || '';

		switch (arr.length) {
			case 0:
				return '';

			case 1:
				return _.template('{{wrapper}}{{item}}{{wrapper}}')({
					item: arr[0],
					wrapper: wrapper
				});

			case 2:
				return _.template('{{wrapper}}{{first}}{{wrapper}} {{connector}} {{wrapper}}{{last}}{{wrapper}}')({
					first: arr[0],
					connector: connector,
					wrapper: wrapper,
					last: arr[1]
				});

			default:
				return _.map(arr, function (item, i) {
					if (i == arr.length - 1) {
						return _.template('{{connector}} {{wrapper}}{{item}}{{wrapper}}')({
							item: item,
							connector: connector,
							wrapper: wrapper
						});
					} else {
						return _.template('{{wrapper}}{{item}}{{wrapper}}')({
							item: item,
							wrapper: wrapper
						});
					}
				}).join(', ');
		}
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = logPromise;

	function logPromise (dfr, _label) {
		return (_label ? '`' + _label + '` ' : '') + 
			dfr
				.done(function (response) {
					console.log((_label ? '`' + _label + '` ' : '') + 'resolved: ', response);
				})
				.fail(function (er) {
					console.warn((_label ? '`' + _label + '` ' : '') + 'rejected');
					console.error(er);
				})
				.state();
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = _.object(_.compact(_.map(location.search.slice(1).split('&'), function(item) {  if (item) return item.split('='); })));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = urlParams;

	var _ = __webpack_require__(5);

	/**
	 * Converts an object to a url parameter string, starting with '?', and possibly adding '#'
	 * @memberOf awf.util
	 * @param {string|object}	prefix		the prefix string. NOTE: If this is the *only* argument, this is used as the key/value objec to convert.
	 * @param {object|null}		[params]	If falsey, this segment will add nothing to the string. Otherwise, it will add '?' + url parameters.
	 * @param {object|null}		[hash]		If falsey, this segment will add nothing to the string. Otherwise, it will add '#' + url parameters.
	 * @return {string}     A URL parameter string
	 *
	 * @example
	 * // 0 arguments returns an empty string
	 * awf.util.urlParams();
	 * 
	 * 
	 * @example
	 * // 1 argument: `null` returns an empty string
	 * awf.util.urlParams(null);
	 *
	 * 
	 * @example
	 * // 1 argument: 1 key returns `?a=alpha`
	 * awf.util.urlParams({
	 * 	a: 'alpha'
	 * });
	 *
	 * 
	 * @example
	 * // 1 argument: 2 keys returns `?a=alpha&b=bravo`
	 * awf.util.urlParams({
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * });
	 * 
	 * 
	 * @example
	 * // 2 arguments returns `//foobar.com/?a=alpha&b=bravo`
	 * awf.util.urlParams('//foobar.com/', {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * });
	 *
	 * 
	 * @example
	 * // 2 arguments (1st is null) returns `?a=alpha&b=bravo`
	 * awf.util.urlParams(null, {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * });
	 *
	 * 
	 * @example
	 * // 2 arguments (2nd is null) returns `//foobar.com/
	 * awf.util.urlParams('//foobar.com/', null);
	 *
	 * 
	 * @example
	 * // 2 arguments (both are null) returns an empty string
	 * awf.util.urlParams(null, null);
	 * 
	 * 
	 * @example
	 * // 3 arguments returns `//foobar.com/?a=alpha&b=bravo#c=charlie&d=delta`
	 * awf.util.urlParams('//foobar.com/', {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * },{
	 * 	c: 'charlie',
	 * 	d: 'delta'
	 * });
	 * 
	 * @example
	 * // 3 arguments (1st is null) returns `?a=alpha&b=bravo#c=charlie&d=delta`
	 * awf.util.urlParams(null, {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * },{
	 * 	c: 'charlie',
	 * 	d: 'delta'
	 * });
	 * 
	 * @example
	 * // 3 arguments (2nd is null) returns `//foobar.com/#c=charlie&d=delta`
	 * awf.util.urlParams('//foobar.com/', null, {
	 * 	c: 'charlie',
	 * 	d: 'delta'
	 * });
	 * 
	 * @example
	 * // 3 arguments (3rd is null) returns `//foobar.com/?a=alpha&b=bravo`
	 * awf.util.urlParams('//foobar.com/', {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * });
	 * 
	 * @example
	 * // 3 arguments (2nd and 3rd are null) returns `//foobar.com/
	 * awf.util.urlParams('//foobar.com/', null, null);
	 *
	 * 
	 * @example
	 * // 3 arguments (1st and 3rd are null) returns `?a=alpha&b=bravo`
	 * awf.util.urlParams(null, {
	 * 	a: 'alpha',
	 * 	b: 'bravo'
	 * });
	 * 
	 * @example
	 * // 3 arguments (1st and 2nd are null) returns `#c=charlie&d=delta`
	 * awf.util.urlParams(null, null, {
	 * 	c: 'charlie',
	 * 	d: 'delta'
	 * });
	 * 
	 * @example
	 * // 3 arguments (all are null) returns an empty string
	 * awf.util.urlParams(null, null, null);
	 *
	 */
	function urlParams (prefix, params, hash) {
		switch (arguments.length) {
			case 0:
				return '';

			case 1:
				if (prefix) {
					return '?' + (_.map(prefix, function (val, key) { return key + '=' + val; })).join('&');
				} else {
					return '';
				}
				break;

			case 2:
				return (prefix || '') + urlParams(params);

			default:
				if (hash) {
					return urlParams(prefix, params) + '#' + (_.map(hash, function (val, key) { return key + '=' + val; })).join('&');
				} else {
					return urlParams(prefix, params);
				}
				break;
		}
	}


/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = use;

	/**
	 * function to create subclasses
	 * @memberOf awf.util
	 * @param  {Function} Super The Super class
	 * @return {Object}   The returned object has function `toCreate`, which takes another Funciton (class definition)
	 * @example
	 * // Usage
	 * use(Super).toCreate(Child);
	 *
	 * @example
	 * // Full-blown example of creating `Dog` from `Animal`
	 *
	 * // Setup //
	 * function Animal (x, y) {
	 *   this.x = x;
	 *   this.y = y;
	 * }
	 *
	 * Animal.prototype.move = function (x, y) {
	 *   this.x += x;
	 *   this.y += y;
	 * }
	 *
	 * function Dog (name, x, y) {
	 *   Animal.call(this, x, y); // call the super's constructor
	 *   this.name = name;
	 * }
	 * 
	 * Dog.prototype.speak = function () {
	 *   alert("Bark!");
	 * }
	 *
	 * // Gives Animal prototype methods (`move`) to Dog
	 * // Makes (instance of Dog) instanceof Animal -> true
	 * use(Animal).toCreate(Dog);
	 *
	 *
	 *
	 * // Instances //
	 * 
	 * var dog = new Dog("Fido", 2, 7);
	 *
	 * dog.name; // returns "Fido" (defined from Dog)
	 * dog.x; // returns 2 (defined by Animal)
	 * dog.y; // returns 7 (defined by Animal)
	 *
	 * dog.move(1,2); // (defined by Animal)
	 * dog.x; // returns 3
	 * dog.y; // returns 9
	 *
	 * dog.speak(); // alerts "Bark!" (defined by Dog)
	 *
	 */
	function use (Super) {
		return {
			toCreate: function (Child) {
				Child.prototype = Object.create(Super.prototype);
				Child.prototype.constructor = Child;
				Child.prototype.parent = Super;
			}
		};
	}


/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = randomID;

	// counter to guarantee uniqueness
	var x = 0;

	/**
	 * Function to create a random ID. A counter is appended to the end of each
	 * generated ID. This will all but guarantee true uniqueness of the ID.
	 * @memberOf awf.util
	 * @param  {integer} len The length of the ID (default is 5)
	 * @param {string} chars The string of characters to use to generate the random ID (default A-Za-z)
	 * @return {string} A random string based on parameters
	 *
	 * @example
	 * // Default usage
	 * var aria_id = awf.util.randomID();
	 * // → "fAwfG-1"
	 *
	 * @example
	 * // Usage with parameters
	 * var item_id = awf.util.randomID(6,"1234567890abcdef.!$");
	 * // → "5.fd!2-2"
	 */
	function randomID (len,chars) {
		len = len || 5;
		chars = chars || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
		x++;

		var id = Array.apply(0, Array(len)).map(function() {
			return (function(charset){
				return charset.charAt(Math.floor(Math.random() * charset.length));
			}(chars));
		}).join('');

		id = id + "-" + x;

		return id;
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = reducedOrder;

	function reducedOrder (arr) {
		var indexes = [],
			order = [],
			i = 0;
		
		_.forEach(arr, function (val) {
			indexes.push(val);
			order.push(null);
		});

		while (i < order.length) {
			var min_val = _.min(indexes),
				min_ind = _.indexOf(indexes, min_val);
			indexes[min_ind] = '-';
			order[min_ind] = i++;
		}

		return order;
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	//Any changes to keycodes need to be reflecting in the Spec,
	//or it will likely fail

	/**
	 * object of key/values for keyboard keycodes
	 * @memberOf awf.util
	 * @property {integer} tab tab keycode (9)
	 * @property {integer} enter enter keycode (13)
	 * @property {integer} esc esc keycode (27)
	 * @property {integer} space space keycode (32)
	 * @property {integer} pageup pageup keycode (33)
	 * @property {integer} pagedown pagedown keycode (34)
	 * @property {integer} end end keycode (35)
	 * @property {integer} home home keycode (36)
	 * @property {integer} left left keycode (37)
	 * @property {integer} up up keycode (38)
	 * @property {integer} right right keycode (39)
	 * @property {integer} down down keycode (40)
	 *
	 * @example
	 * // checking an event keycode
	 *
	 * $('#element').on('keyup', function (e) {
	 * 	if (e.keyCode == awf.util.keyCodes.esc) {
	 * 		//execute codeblock
	 * 	}
	 * });
	 *
	 * @example
	 * // faking an event
	 * $('#element').trigger(
	 * 	$.Event( 'keydown', { keyCode: awf.util.keyCodes.space, which: awf.util.keyCodes.space } );
	 * );
	 */
	var keyCodes = {
		"tab": 9,
		"enter": 13,
		"esc": 27,

		"space": 32,
		"pageup": 33,
		"pagedown": 34,
		"end": 35,
		"home": 36,

		"left": 37,
		"up": 38,
		"right": 39,
		"down": 40
	};

	module.exports = keyCodes;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = showFocus;

		var $ = __webpack_require__(4);

	/**
	 * Causes all focusable elements on the page to have a distinct border/highlight
	 * when focused. It also provides some basic information in the console about
	 * the focused element. Helpful for debugging, confirming tab order of elements, etc.
	 * @memberOf awf.util
	 * @param  {boolean} crosshairs When true, there will be crosshairs at the top,
	 * left corner of the focused element, as well
	 *
	 * @example
	 * // Default usage
	 * // Enter the following into the browser console
	 * awf.util.showFocus();
	 *
	 * @example
	 * // To include crosshairs
	 * awf.util.showFocus(true);
	 */
	function showFocus (crosshairs) {

		// add elements to create crosshairs?
		if (crosshairs) {
			$('body')
				.append('<div id="ch-hor"></div>')
				.append('<div id="ch-ver"></div>');
		}

		$('body').on('focusin', function (ev) {
			var $target = $(ev.target),
				offset = $target.offset(),
				scroll_top = $(window).scrollTop(),
				scroll_left = $(window).scrollLeft(),
				offset_message = offset.top + ":" + offset.left;

			// Log some info in the console
			console.log("%cFocused Element Details:","color:red;text-decoration:underline");
			console.log("%c" + ev.target.tagName + " - " + "%c" + ev.target.className,"color:#916968;font-weight:bold;padding-left:10px","color:#B45331");
			console.log("%cOffset - " + "%c" + offset_message,"color:#916968;font-weight:bold;padding-left:10px","color:#B45331");
			console.log("%cFocused Object :", "padding-left:10px", ev.target);

			// cleanup
			$('.awf-show-focus')
				.removeClass('awf-show-focus')
				.css({
					'outline' : '',
					'box-shadow' : ''
				});

			// add focus styles to focused element
			$target
				.addClass('awf-show-focus')
				.css({
					'outline' : '2px dashed red',
					'box-shadow' : '0 0px 15px 5px #ff0000'
				});

			// add crosshairs to focused element's top, left corner
			if (crosshairs) {
				$('#ch-hor')
					.css({
						'width' :'300%',
						'height' : '1px',
						'background' : 'red',
						'position' : 'fixed',
						'left' : '-100%',
						'top' : (offset.top - scroll_top) + 'px',
						'z-index' : '1000'
					});
				$('#ch-ver')
					.css({
						'width' :'1px',
						'height' : '300%',
						'background' : 'red',
						'position' : 'fixed',
						'left' : (offset.left - scroll_left) + 'px',
						'top' : '-100%',
						'z-index' : '1000'
					});

				// make those crosshairs fall in line!
				$(window)
					.on('scroll resize', function() {
						$('#ch-hor')
							.css('top', ($target.offset().top - $(window).scrollTop()) + 'px');
						$('#ch-ver')
							.css('left', ($target.offset().left - $(window).scrollLeft()) + 'px');
					});
			}
		});
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5),

		keys = [
			"log",
			"info",
			"warn",
			"error",
			"group",
			"groupCollapsed",
			"groupEnd"
		],

		origs = _.zipObject(_.map(keys, function (key) {
			return [key, console[key]];
		}));


	module.exports = {

		/**
		 * Enables console methods
		 * @memberOf awf.util.consoleToggle
		 * @name enable()
		 */
		enable: function () {
			_.forEach(keys, function (key) {
				console[key] = origs[key];
			});
		},

		/**
		 * Disables console methods
		 * @memberOf awf.util.consoleToggle
		 * @name disable()
		 */
		disable: function () {
			_.forEach(keys, function (key) {
				console[key] = function () {};
			});
		}
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	module.exports = runPromiseSequence;

	function runPromiseSequence (callacks, first_args) {

		var self = this,
			callback_index = -1,
			dfr = $.Deferred();

		function runNextCallback (args) {
			callback_index++;
			
			// At the end? We're done.
			if (callback_index == callacks.length) {
				dfr.resolve(args);
				return false;
			}

			var callback = callacks[callback_index];
			try {
				callback.call(self, args)
					.done(function (response) {
						if (dfr.state() == 'pending') {
							runNextCallback(response);
						}
					})
					.fail(dfr.reject);
			} catch (er) {
				dfr.reject(er);
			}
		}

		runNextCallback(first_args);

		return dfr;
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (s) {
		return new AwfString(s);
	};

	var _ = __webpack_require__(5),
		use = __webpack_require__(21);

	use(String).toCreate(AwfString);
	function AwfString (value) {
		this.value = value || '';
		String.apply(this,arguments);
	}


	Object.defineProperty(AwfString.prototype, 'length', {
		get: function () {
			return this.value.length;
		}
	});


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(AwfString.prototype, {

			toString: function () {
				return this.value;
			},

			valueOf: function () {
				return this.value;
			},

			toJSON: function () {
				return this.value;
			},

			between: function (start, end) {
				return new AwfString(AwfString.between(this.value, start, end));
			},

			trim: function () {
				return new AwfString(_.trim(this.value));
			},

			trimEnd: function () {
				return new AwfString(_.trimEnd(this.value));
			},

			trimStart: function () {
				return new AwfString(_.trimStart(this.value));
			},

			toSnakeCase: function () {
				return new AwfString(_.snakeCase(this.value));
			},

			toKebabCase: function () {
				return new AwfString(_.kebabCase(this.value));
			},

			toCamelCase: function () {
				return new AwfString(_.camelCase(this.value));
			},

			toUpperCamelCase: function () {
				return new AwfString(_.capitalize(_.camelCase(this.value)));
			},

			toStartCase: function () {
				return new AwfString(_.startCase(this.value));
			},

			toUpperCase: function () {
				return new AwfString(this.value.toUpperCase());
			},

			toLowerCase: function () {
				return new AwfString(this.value.toLowerCase());
			},

			substring: function (start, length) {
				start = start || 0;
				length = length || 0;
				if (start < 0) {
					start = this.value.length + start;
				}
				var end = (length > 0) ? (start + length) : (this.value.length + length);
				return new AwfString(this.value.substring(start, end));
			},

			repeat: function (amount) {
				return new AwfString(_.repeat(this.value, amount));
			},

			endsWith: function (val, position) {
				return _.endsWith(this.value, val, position);
			},

			startsWith: function (val, position) {
				return _.startsWith(this.value, val, position);
			},

			escape: function () {
				return new AwfString(_.escape(this.value));
			},

			pad: function (amount, chars) {
				return new AwfString(_.pad(this.value, amount, chars));
			},

			padLeft: function (amount, chars) {
				return new AwfString(_.padLeft(this.value, amount, chars));
			},

			padRight: function (amount, chars) {
				return new AwfString(_.padRight(this.value, amount, chars));
			},

			pigLatin: function () {
				return new AwfString(AwfString.pigLatin(this.value));
			},

			parseInt: function () {
				return _.parseInt(this.value);
			},

			templateWith: function (data) {
				return new AwfString(_.template(this.value)(data));
			},

			truncate: function (limit) {
				return new AwfString(_.trunc(this.value, limit));
			},

			words: function () {
				return _.words(this.value);
			}

		});


	// Static Methods
		_.extend(AwfString, {

			between: function (value, start, end) {
				value = value.substring(value.indexOf(start) + start.length);
				value = value.substring(0, value.lastIndexOf(end));
				return value;
			},

			pigLatin: function (msg) {
				var mortars = msg.match(/\W/g),
					bricks = _.map(msg.split(/\W/), function (value) {
						if (value === '')
							return value;

						var caps = _.map(value, function (c) {
								return c.toUpperCase() == c;
							}),
							vowel_index = value.search(/a|e|i|o|u/i);

						var f = value.substring(0,vowel_index),
							r = value.substring(vowel_index);
						value = r + f;

						// Honor capping
						value = _.map(value, function (c, i) {
							return c[caps[i] ? 'toUpperCase' : 'toLowerCase']();
						}).join('');

						value += (vowel_index === 0 ? 'w' : '') + 'ay';

						return value;
					});
				var ret = _.map(mortars, function (mortar, i) {
					return bricks[i] + mortar;
				}).join('');


				if (mortars) {
					if (bricks.length > mortars.length)
						ret += bricks[bricks.length - 1];
				} else {
					ret = bricks[0];
				}

				return ret;
			}
		});





/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = speak;

	function speak (text, params, callback) {
		params = params || {};

		var id = params.id || "alex";

		if (typeof(id) == "string")
			id = speak.voice_ids[id.toLowerCase()];
		
		if (typeof(id) == "undefined")
			id = 13;

		if ('speechSynthesis' in window)
		{
			var msg = new SpeechSynthesisUtterance();
			var voices = window.speechSynthesis.getVoices();
			msg.voice = voices[id]; // Note: some voices don't support altering params
			msg.voiceURI = 'native';
			msg.volume = params.volume || 1; // 0 to 1
			msg.rate = params.rate || 1; // 0.1 to 10
			msg.pitch = params.pitch || 1; //0 to 2
			msg.text = text;
			msg.lang = 'en-US';

			if (callback)
				msg.onend = callback;

			//console.log("Speaking '", msg.text, "' with ", msg.voice.name);
			speechSynthesis.speak(msg);
			return msg;
		}

		return null;
	}


	if ('speechSynthesis' in window) {
		speak.voices = window.speechSynthesis.getVoices();
		speak.voice_ids = _.object(_.map(speak.voices, function (voice, i) {
			return [voice.name.toLowerCase(),i];
		}));
		
		window.speechSynthesis.onvoiceschanged = function() {
			speak.voices = window.speechSynthesis.getVoices();
			speak.voice_ids = _.object(_.map(speak.voices, function (voice, i) {
				return [voice.name.toLowerCase(),i];
			}));
		};
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

		function between (haystack, needle1, needle2) {
			var ret = haystack.substring(haystack.indexOf(needle1)+needle1.length);
			return ret.substring(0, ret.indexOf(needle2));
		}

		var info = {};

		info.browser = {
			chrome  : false,
			safari  : false,
			firefox : false,
			ie      : false
		};

		info.browser_version = null;

		var ua = navigator.userAgent,
			av = navigator.appVersion;

		/*	Chrome & Safari
		-------------------------------*/
			if (ua.indexOf("Safari") > -1)
			{
				if (ua.indexOf("Chrome") > -1)
				{
					info.browser.chrome = true;
					info.browser_version = parseInt(between(ua, "Chrome/","."), 10);
				} else {
					info.browser.safari = true;
					info.browser_version = parseInt(between(ua, "Version/","."), 10);
				}
			}

		/*	Firefox
		-------------------------------*/
			if (ua.indexOf("Firefox") > -1)
			{
				info.browser.firefox = true;
				info.browser_version = parseInt(between(ua, "Firefox/","."), 10);
			}

		/*	Internet Explorer
		-------------------------------*/
	        var ind = av.indexOf("MSIE ");
	        if (ind > -1)
	        {
	            info.browser.ie = true;
	            info.browser_version = parseInt(between(av, " MSIE ","."), 10);
	        }
	        else if (ua.indexOf("Trident") > -1 && ua.indexOf("rv:11") > -1)
	        {
	            info.browser.ie = true;
	            info.browser_version = 11;
	        }


		/*	Mobile Device?
		-------------------------------*/
			info.mobile = {
				android    : ua.match(/Android/i) ? true : false,
				blackberry : ua.match(/BlackBerry/i) ? true : false,
				ios        : ua.match(/iPhone|iPad|iPod/i) ? true : false,
				opera      : ua.match(/Opera Mini/i) ? true : false,
				windows    : ua.match(/IEMobile/i) ? true : false
			};

			info.isMobile = function () {
				var blnIsMobile = false,
					devices = info.mobile;

				for (var device in devices) {
					if (devices[device]) {
						return true;
					}
				}
				return false;
			};


		/*	Operating System
		-------------------------------*/
			info.os = {
				windows : ua.match(/Win/i) ? true : false,
				mac     : ua.match(/Mac/i) ? true : false,
				unix    : ua.match(/X11/i) ? true : false,
				linux   : ua.match(/Linux/i) ? true : false
			};





		module.exports = info;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = postMessage;


	var $ = __webpack_require__(4);

	/**
	 * This utility will create an awf.ui.Message instance and show it in the
	 * provided container. In addition, it will log the message in the browser's
	 * console.
	 *
	 * @memberOf awf.util
	 * @function
	 *
	 * @param  {object} $container A jQuery reference to a predefined, dedicated message container. (will be emptied prior to each message)
	 * @param {string} type The message type. Must be one of the following values:
	 * "error", "info", "warn", "success"
	 * @param {string} message The message to be displayed in the container and logged in the console.
	 * @param {boolean} [show_dismiss=true] If false, the message's dismiss button will be hidden, otherwise it will be shown.
	 *
	 * @return {awf.ui.Message} The message component instance
	 *
	 * @example
	 * var $container = $('YOUR_MESSAGE_CONTAINER_SELECTOR');
	 *
	 * // a warning that stays until a user dismisses it
	 * awf.util.postMessage($container, 'warn', "Please dismiss me");
	 *
	 * // information that dismisses itself after 5 seconds unless a user dismisses it manually, sooner
	 * awf.util.postMessage($container, 'info', "I will go away in 5 seconds, unless you dismiss me sooner than that.").andDismissIn(5);
	 *
	 * // a success message that doesn't have a dismiss button, but will dismiss itself after 3 seconds
	 * awf.util.postMessage($container, 'success', "Hello World!", false).andDismissIn(3);
	 *
	 */
	function postMessage ($container, type, message, show_dismiss) {

		var message_ui = null,
			icon_map = {
				"error" : "awficon-message-error",
				"info" : "awficon-message-information",
				"warn" : "awficon-message-warning",
				"success" : "awficon-message-success",
				"malkaris" : "awficon-malkaris"
			};

		if (show_dismiss !== false)
			show_dismiss = true;


		/* First run some checks to see if we have what we need
		*************************************************************************/

		// Do we have the expected number of arguments?
		if (arguments.length < 3) {
			console.error('Message Error! Three arguments are required for pushing a message. Actual arguments provided were: ' + arguments.length);
			return false;
		}

		// Are the arguments what we were expecting?
		if ( ! ($container instanceof $) || icon_map[type] === undefined || typeof message != 'string') {

			if ( ! ($container instanceof $) )
				console.error('Message Error! The container argument is expected to be a jQuery object.');

			if ( icon_map[type] === undefined )
				console.error('Message Error! The message type must be either "success", "warn", "error", or "info. Actual message type provided was: "' + type + '"');

			if ( typeof message != 'string' )
				console.error('Message Error! The message argument is expected to be a string.');

			return false;
		}


		/* We got this far, let's push the message!
		*************************************************************************/

		// Clean up the container, in case it isn't already
		$container.empty();


		// Create/Show the message
		message_ui = new awf.ui.Message({
			parent: $container,
			type: 'awf-message--' + type,
			icon: icon_map[type],
			show_dismiss: show_dismiss,
			message: message
		});

		message_ui.on('dismiss', function () {
			message_ui.hide();
		});

		switch (type) {
			case 'error':
			case 'warn':
			case 'info':
				console[type](message);
				break;
			default:
				console.log(message);
				break;
		}

		return message_ui;
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	module.exports = function (url_param_key) {

		var delayed_success_dfr = $.Deferred(),
			num = parseInt(awf.util.url_params[url_param_key]);

		if (isNaN(num)) {
			delayed_success_dfr.resolve();
		} else {
			setTimeout(delayed_success_dfr.resolve, num);
		}

		return delayed_success_dfr;

	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = {

		/**
		 * Returns a function that calls console.log with the given prefix. Makes for easy console filtering
		 * @param  {string|object|number} prefix This will be prepended to the arguments passed to console.log
		 * @return {function} a prefixed console.log
		 * @memberOf awf.util
		 */
		createPrefixedLog: function (prefix) {
			return function log () {
				var callbacks = [
						function (args) { console.log.call(console, prefix); },
						function (args) { console.log.call(console, prefix, args[0]); },
						function (args) { console.log.call(console, prefix, args[0], args[1]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]); },
						function (args) { console.log.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]); }
					];
				callbacks[arguments.length](arguments);
			};
		},


		/**
		 * Returns a function that calls console.warn with the given prefix. Makes for easy console filtering
		 * @param  {string|object|number} prefix This will be prepended to the arguments passed to console.warn
		 * @return {function} a prefixed console.warn
		 * @memberOf awf.util
		 */
		createPrefixedWarn: function (prefix) {
			return function warn () {
				var callbacks = [
						function (args) { console.warn.call(console, prefix); },
						function (args) { console.warn.call(console, prefix, args[0]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]); },
						function (args) { console.warn.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]); }
					];
				callbacks[arguments.length](arguments);
			};
		},


		/**
		 * Returns a function that calls console.error with the given prefix. Makes for easy console filtering
		 * @param  {string|object|number} prefix This will be prepended to the arguments passed to console.error
		 * @return {function} a prefixed console.error
		 * @memberOf awf.util
		 */
		createPrefixedError: function (prefix) {
			return function error () {
				var callbacks = [
						function (args) { console.error.call(console, prefix); },
						function (args) { console.error.call(console, prefix, args[0]); },
						function (args) { console.error.call(console, prefix, args[0], args[1]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]); },
						function (args) { console.error.call(console, prefix, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]); }
					];
				callbacks[arguments.length](arguments);
			};
		}

	};


/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = {

		/**
		 * Get Object from local storage
		 * @memberOf awf.util
		 * @function
		 * @param {string} key Name data is stored under
		 * @return {Object|false} Key value or `false` if the key does *not* exist
		 */
		getStoredObject: function (key) {
			if (window.localStorage) {
				var value = window.localStorage[key];
				if (value) {
					return JSON.parse(value) || false;
				}
			}
			return false;
		},

		/**
		 * Set Object in local storage
		 * @memberOf awf.util
		 * @function
		 * @param {string} key Name data is stored under
		 * @param {Object} value Data to store
		 * @return {undefined}
		 */
		setStoredObject: function (key, value) {
			if (window.localStorage) {
				value = JSON.stringify(value);
				window.localStorage[key] = value;
			}
		}

	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	function focusable( element, isTabIndexNotNaN ) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			map = element.parentNode;
			mapName = map.name;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
			return !!img && visible( img );
		}
		return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
			!element.disabled :
			"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible( element );
	}

	function visible( element ) {
		return $.expr.filters.visible( element ) &&
			!$( element ).parents().addBack().filter(function() {
				return $.css( this, "visibility" ) === "hidden";
			}).length;
	}

	module.exports = {

		focusable: function( element ) {
			return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
		},

	    tabbable: function( element ) {
			var tabIndex = $.attr( element, "tabindex" ),
				isTabIndexNaN = isNaN( tabIndex );
			return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
		}

	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	 /*!
	 * jQuery Simulate v@VERSION - simulate browser mouse and keyboard events
	 * https://github.com/jquery/jquery-simulate
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: @DATE
	 */

	var $ = __webpack_require__(4),
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|contextmenu)|click/;

	module.exports = function (type, options) {
		return this.each(function() {
			new $.simulate( this, type, options );
		});
	};

	$.simulate = function( elem, type, options ) {
		var method = $.camelCase( "simulate-" + type );

		this.target = elem;
		this.options = options;

		if ( this[ method ] ) {
			this[ method ]();
		} else {
			this.simulateEvent( elem, type, options );
		}
	};

	$.extend( $.simulate, {

		keyCode: {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			LEFT: 37,
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		},

		buttonCode: {
			LEFT: 0,
			MIDDLE: 1,
			RIGHT: 2
		}
	});

	$.extend( $.simulate.prototype, {

		simulateEvent: function( elem, type, options ) {
			var event = this.createEvent( type, options );
			this.dispatchEvent( elem, type, event, options );
		},

		createEvent: function( type, options ) {
			if ( rkeyEvent.test( type ) ) {
				return this.keyEvent( type, options );
			}

			if ( rmouseEvent.test( type ) ) {
				return this.mouseEvent( type, options );
			}
		},

		mouseEvent: function( type, options ) {
			var event, eventDoc, doc, body;
			options = $.extend({
				bubbles: true,
				cancelable: (type !== "mousemove"),
				view: window,
				detail: 0,
				screenX: 0,
				screenY: 0,
				clientX: 1,
				clientY: 1,
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				metaKey: false,
				button: 0,
				relatedTarget: undefined
			}, options );

			if ( document.createEvent ) {
				event = document.createEvent( "MouseEvents" );
				event.initMouseEvent( type, options.bubbles, options.cancelable,
					options.view, options.detail,
					options.screenX, options.screenY, options.clientX, options.clientY,
					options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
					options.button, options.relatedTarget || document.body.parentNode );

				// IE 9+ creates events with pageX and pageY set to 0.
				// Trying to modify the properties throws an error,
				// so we define getters to return the correct values.
				if ( event.pageX === 0 && event.pageY === 0 && Object.defineProperty ) {
					eventDoc = event.relatedTarget.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					Object.defineProperty( event, "pageX", {
						get: function() {
							return options.clientX +
								( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
								( doc && doc.clientLeft || body && body.clientLeft || 0 );
						}
					});
					Object.defineProperty( event, "pageY", {
						get: function() {
							return options.clientY +
								( doc && doc.scrollTop || body && body.scrollTop || 0 ) -
								( doc && doc.clientTop || body && body.clientTop || 0 );
						}
					});
				}
			} else if ( document.createEventObject ) {
				event = document.createEventObject();
				$.extend( event, options );
				// standards event.button uses constants defined here: http://msdn.microsoft.com/en-us/library/ie/ff974877(v=vs.85).aspx
				// old IE event.button uses constants defined here: http://msdn.microsoft.com/en-us/library/ie/ms533544(v=vs.85).aspx
				// so we actually need to map the standard back to oldIE
				event.button = {
					0: 1,
					1: 4,
					2: 2
				}[ event.button ] || ( event.button === -1 ? 0 : event.button );
			}

			return event;
		},

		keyEvent: function( type, options ) {
			var event;
			options = $.extend({
				bubbles: true,
				cancelable: true,
				view: window,
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				metaKey: false,
				keyCode: 0,
				charCode: undefined
			}, options );

			if ( document.createEvent ) {
				try {
					event = document.createEvent( "KeyEvents" );
					event.initKeyEvent( type, options.bubbles, options.cancelable, options.view,
						options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
						options.keyCode, options.charCode );
				// initKeyEvent throws an exception in WebKit
				// see: http://stackoverflow.com/questions/6406784/initkeyevent-keypress-only-works-in-firefox-need-a-cross-browser-solution
				// and also https://bugs.webkit.org/show_bug.cgi?id=13368
				// fall back to a generic event until we decide to implement initKeyboardEvent
				} catch( err ) {
					event = document.createEvent( "Events" );
					event.initEvent( type, options.bubbles, options.cancelable );
					$.extend( event, {
						view: options.view,
						ctrlKey: options.ctrlKey,
						altKey: options.altKey,
						shiftKey: options.shiftKey,
						metaKey: options.metaKey,
						keyCode: options.keyCode,
						charCode: options.charCode
					});
				}
			} else if ( document.createEventObject ) {
				event = document.createEventObject();
				$.extend( event, options );
			}

			if ( !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() ) || (({}).toString.call( window.opera ) === "[object Opera]") ) {
				event.keyCode = (options.charCode > 0) ? options.charCode : options.keyCode;
				event.charCode = null;
				delete event.charCode;
			}

			return event;
		},

		dispatchEvent: function( elem, type, event ) {
			if ( elem[ type ] ) {
				elem[ type ]();
			} else if ( elem.dispatchEvent ) {
				elem.dispatchEvent( event );
			} else if ( elem.fireEvent ) {
				elem.fireEvent( "on" + type, event );
			}
		},

		simulateFocus: function() {
			var focusinEvent,
				triggered = false,
				element = $( this.target );

			function trigger() {
				triggered = true;
			}

			element.bind( "focus", trigger );
			element[ 0 ].focus();

			if ( !triggered ) {
				focusinEvent = $.Event( "focusin" );
				focusinEvent.preventDefault();
				element.trigger( focusinEvent );
				element.triggerHandler( "focus" );
			}
			element.unbind( "focus", trigger );
		},

		simulateBlur: function() {
			var focusoutEvent,
				triggered = false,
				element = $( this.target );

			function trigger() {
				triggered = true;
			}

			element.bind( "blur", trigger );
			element[ 0 ].blur();

			// blur events are async in IE
			setTimeout(function() {
				// IE won't let the blur occur if the window is inactive
				if ( element[ 0 ].ownerDocument.activeElement === element[ 0 ] ) {
					element[ 0 ].ownerDocument.body.focus();
				}

				// Firefox won't trigger events if the window is inactive
				// IE doesn't trigger events if we had to manually focus the body
				if ( !triggered ) {
					focusoutEvent = $.Event( "focusout" );
					focusoutEvent.preventDefault();
					element.trigger( focusoutEvent );
					element.triggerHandler( "blur" );
				}
				element.unbind( "blur", trigger );
			}, 1 );
		}
	});




	function findCenter( elem ) {
		var offset,
			document = $( elem.ownerDocument );
		elem = $( elem );
		offset = elem.offset();

		return {
			x: offset.left + elem.outerWidth() / 2 - document.scrollLeft(),
			y: offset.top + elem.outerHeight() / 2 - document.scrollTop()
		};
	}

	function findCorner( elem ) {
		var offset,
			document = $( elem.ownerDocument );
		elem = $( elem );
		offset = elem.offset();

		return {
			x: offset.left - document.scrollLeft(),
			y: offset.top - document.scrollTop()
		};
	}

	$.extend( $.simulate.prototype, {
		simulateDrag: function() {
			var i = 0,
				target = this.target,
				eventDoc = target.ownerDocument,
				options = this.options,
				center = options.handle === "corner" ? findCorner( target ) : findCenter( target ),
				x = Math.floor( center.x ),
				y = Math.floor( center.y ),
				coord = { clientX: x, clientY: y },
				dx = options.dx || ( options.x !== undefined ? options.x - x : 0 ),
				dy = options.dy || ( options.y !== undefined ? options.y - y : 0 ),
				moves = options.moves || 3;

			this.simulateEvent( target, "mousedown", coord );

			for ( ; i < moves ; i++ ) {
				x += dx / moves;
				y += dy / moves;

				coord = {
					clientX: Math.round( x ),
					clientY: Math.round( y )
				};

				this.simulateEvent( eventDoc, "mousemove", coord );
			}

			if ( $.contains( eventDoc, target ) ) {
				this.simulateEvent( target, "mouseup", coord );
				this.simulateEvent( target, "click", coord );
			} else {
				this.simulateEvent( eventDoc, "mouseup", coord );
			}
		}
	});


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		properties: __webpack_require__(38),
		collection : __webpack_require__(39),
		collectionItem : __webpack_require__(40)
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = properties;

	function properties (instance, init_params, props) {

		init_params = init_params || {};
		if (init_params === true)
			init_params = {};

		// Define them all
		_.forEach(props, function (params, property) {

			var prop_key = _.snakeCase(property);

			//instance[prop_key] = (prop_key in init_params) ? init_params[prop_key] : params.default;

			// setProperty
			if ( ! (_.camelCase('set ' + property) in instance.constructor.prototype)) {
				instance.constructor.prototype[_.camelCase('set ' + property)] = function (new_val, _silent) {
					var this_instance = this;

					// If you're assigning the value to the existing value -- Stop here, do nothing
					if (_.isEqual(this_instance[prop_key], new_val))
						return this_instance;

					// Type validation
					if (params.types) {
						switch (typeof new_val) {
							case 'undefined':
								throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type ' + typeof(new_val));

							case 'object':
								if (new_val === null) {
									if ( ! _.contains(params.types, 'null')) {
										throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type null');
									}
								} else if (new_val instanceof Date) {
									if ( ! _.contains(params.types, 'date')) {
										throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type date');
									}
								} else if (_.isArray(new_val)) {
									 if( ! _.contains(params.types, 'array')) {
										throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type array');
									}
								} else {
									if ( ! _.contains(params.types, 'object')) {
										throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type object');
									}
								}
								break;

							case 'string':
							case 'number':
							case 'boolean':
								if ( ! _.contains(params.types, typeof new_val)) {
									throw new Error(_.camelCase('set ' + property) + ' does not accept a value of type ' + typeof(new_val));
								}
								break;
						}
					}

					var old_val = this_instance[prop_key];

					if (params.prep) {
						new_val = params.prep.call(this, new_val);
					}

					if (params.validator) {
						if (params.validator.call(this, new_val, old_val) === false) {
							throw new Error('Cannot set `' + prop_key + '` to the invalid value `' + new_val + '`.');
						}
					}

					// Update the property value
					this_instance[prop_key] = new_val;

					// Call handler
					if (params.handler) {
						params.handler.call(this_instance, new_val, old_val, _silent);
					}

					// If not silent...
					if ( ! _silent) {

						// If rendered, call renderHandler
						if (params.renderHandler && this_instance.$el) {
							params.renderHandler.call(this_instance, new_val, old_val);
						}

						// Emit change event
						this_instance.triggerHandler('change', [prop_key, new_val, old_val]);
						this_instance.triggerHandler('change:' + prop_key, [new_val,old_val]);
					}

					// Return self -- Chainable!
					return this_instance;
				};
			}

			// getProperty
			if (params.getter === true) {
				if ( ! (_.camelCase('get ' + property) in instance.constructor.prototype)) {
					instance.constructor.prototype[_.camelCase('get ' + property)] = function () {
						return this[prop_key];
					};
				}
			}
		});

		// Call them all
		_.forEach(props, function (params, property) {
			var prop_key = _.snakeCase(property);

			instance[prop_key] = (prop_key in init_params) ? init_params[prop_key] : params.default;
			if (typeof(instance[prop_key]) == "function") {
				instance[prop_key] = instance[prop_key].call(instance);
			}

			if (params.handler)
				params.handler.call(instance, instance[prop_key]);

			if (params.renderHandler) {
				if (instance.$el) {
					params.renderHandler.call(instance, instance[prop_key]);
				}

				instance.on('render', function () {
					params.renderHandler.call(instance, instance[prop_key]);
				});
			}
		});
	}


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = collection;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	function collection (self, params, handlers) {
		switch (arguments.length) {
			case 0: throw new Error('the collection mixin requires 2 arguments. Both are missing.');
			case 1: throw new Error('the collection mixin requires 2 arguments. The second is missing.');
		}

		handlers = handlers || {};

		self.Item = params.Item || self.Item;
		self.items = [];

		/**
		 * Adds a new item to the end of the collection
		 * @memberOf awf.util.mixin.collection
		 * @param {undefined|null|object|array|awf.ui.BaseObject} params_or_instance If an object, it will create a new this.Item(object). Otherwise, if an instance of CollectionItem, it will pull it in, reasign that item's collection, and render it if the collection is already rendered. This allows items to be moved from one collection to another.
		 * @return {awf.__.CollectionItem} the newly added item
		 */
		self.addItem = function (params_or_instance) {
			var self = this;

			if (_.isArray(params_or_instance)) {
				var added_items = [];
				_.forEach(params_or_instance, function (item) {
					added_items.push(self.addItem(item));
				});
				return added_items;
			}

			params_or_instance = params_or_instance || {};

			var item = null;

			if (params_or_instance instanceof self.Item) {
				item = params_or_instance;

				// If it was part of a different collection, remove it!
				if (item.collection)
					item.removeFromCollection();

				// One of us. One of us.
				item.collection = this;
				if ('render' in item)
					item.render();

			} else {
				params_or_instance.collection = this;
				//params_or_instance.render = false;
				item = new this.Item(params_or_instance);
			}

			this.items.push(item);

			if (handlers.addItem) {
				handlers.addItem.call(self, item);
			}

			item.on('change', function (ev, a, b, c) {
				self.triggerHandler('change:item', ev, a, b, c);
			});

			this.triggerHandler('add-item');
			this.triggerHandler('change', ['length',this.items.length, this.items.length - 1]);
			this.triggerHandler('change:length', this.items.length, this.items.length - 1);

			return item;
		};




		/**
		 * Removes an item, based on index
		 * @param  {number} index The index to remove
		 * @memberOf awf.util.mixin.collection
		 * @return {awf.ui.CollectionItem}       The removed item
		 */
		self.removeItem = function (index) {
			if (-1 < index && index < this.items.length) {
				var item = this.items[index];

				if (handlers.removeItem) {
					handlers.removeItem.call(self, item);
				}

				// item events
				item.triggerHandler('removed-from-collection');

				// collection events
				this.triggerHandler('remove-item', [item,index]);

				item.collection = null;
				this.items.splice(index,1);
				
				this.triggerHandler('change', ['length',this.items.length, this.items.length + 1]);
				this.triggerHandler('change:length', this.items.length, this.items.length + 1);

				return item;
			} else {
				throw new Error('Cannot remove item beyond range: ' + index);
			}
		};



		/**
		 * Removes all items, from last to first.
		 * @memberOf awf.util.mixin.collection
		 * @return {object} this (chainable)
		 */
		self.removeAllItems = function () {
			var self = this;
			_.forEachRight(this.items, function (item, i) {
				self.removeItem(i);
			});

			if (handlers.removeAllItems) {
				handlers.removeAllItems.call(self);
			}

			// Note: No triggerHandler's needed -- removeItem() takes care of them

			return this;
		};


		/**
		 * Takes a unique array of numbers from 0 to (n-1) and sorts the items acordingly
		 * @memberOf awf.util.mixin.collection
		 * @param {array} new_order An array of numbers that matches the length of items, each number must be unique, and includes exactly one of every index value
		 * @return {object} this (chainable)
		 */
		self.setOrder = function (new_order) {
			var self = this;

			/*	Validation
			------------------------------------------*/
				// miss-matched length
				if (new_order.length !== this.items.length)
					throw new Error('Cannot setOrder with an array of non-matching length. items: ' + this.items.length + ', given: ' + new_order.length);


				// Did anything actully change??
				var found_difference = false;
				_.forEach(new_order, function (given, expected) {
					if (given != expected)
						found_difference = true;
				});
				// No? Well.. we're done here. Exit now so events to report a false negative.
				if ( ! found_difference)
					return this;


				// non-unique values
				if (new_order.length !== _.unique(new_order).length)
					throw new Error('Cannot setOrder with an array with non-unique indexes.');

				// values that are not 0 through length-1
				var sorted_order = _.sortBy(new_order),
					is_valid = true;
				_.forEach(sorted_order, function (given, expected) {
					if (given != expected)
						is_valid = false;
				});
				if ( ! is_valid)
					throw new Error('Cannot setOrder with an array of incorrect or missing values.');

			/*	Sort 'em!
			------------------------------------------*/
				var items = [];
				_.forEach(new_order, function (new_index) {
					items.push(self.items[new_index]);
				});
				this.items = items;

			/*	setOrder handler
			------------------------------------------*/
				if (handlers.setOrder) {
					handlers.setOrder.call(self, new_order);
				}

			/*	Events
			------------------------------------------*/
				this.triggerHandler('change', ['order',new_order]);
				this.triggerHandler('change:order', [new_order]);

			/*	Chainable Return
			------------------------------------------*/
				return this;
		};



		_.forEach(params.items, function (item) {
			self.addItem(item);
		});

	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = collectionItem;

	var _ = __webpack_require__(5);

	function collectionItem (self, params) {
		switch (arguments.length) {
			case 0: throw new Error('The collectionItem mixin requires 2 arguments. Both are missing.');
			case 1: throw new Error('The collectionItem mixin requires 2 arguments. The second is missing.');
		}

		self.collection = params.collection || null;

		/**
		 * Removes this item from the parent collection.
		 * It calls the collection's removeItem method, passing the index.
		 * @instance
		 * @memberOf awf.util.mixin.collectionItem
		 * @return {object} this (chainable)
		 */
		self.removeFromCollection = function () {
			if ( ! this.collection)
				throw new Error('Cannot remove from collection: This item has no collection');

			this.collection.removeItem(this.index());

			return this;
		};




		/**
		 * Returns the index of this item from its collection.items array.
		 * It does NOT necessarily reflect the index of the DOM element. (though in normal circumstances it would match)
		 * @memberOf awf.util.mixin.collectionItem
		 * @instance
		 * @return {number} The index position from the collection.items array.
		 */
		self.index = function () {
			if ( ! this.collection)
				return -1;

			var self = this,
				_index_locater = awf.util.randomID();
			this._index_locater = _index_locater;
			var index = _.indexOf(self.collection.items, _.find(self.collection.items, {_index_locater:self._index_locater}));
			delete this._index_locater;
			return index;
		};



		/**
		 * If possible, it swaps position with the item ahead of it.
		 * @instance
		 * @memberOf awf.util.mixin.collectionItem
		 * @return {boolean} If it was able to move, true. Otherwise false.
		 */
		self.promote = function () {
			var self = this;

			// No collection? Do nothing
			if ( ! this.collection)
				return false;
			
			var index = this.index();

			// at the end aready? Do nothing
			if (index > this.collection.items.length - 2)
				return false;

			var positions = [];
			_.forEach(this.collection.items, function (item, i) { positions.push(i); });
			positions[index]++;
			positions[index+1]--;

			this.collection.setOrder(positions);
			return true;
		};

		/**
		 * If possible, it swaps position with the item behind it.
		 * @instance
		 * @memberOf awf.util.mixin.collectionItem
		 * @return {boolean} If it was able to move, true. Otherwise false.
		 */
		self.demote = function () {
			var self = this;

			// No collection? Do nothing
			if ( ! this.collection)
				return false;
			
			var index = this.index();

			// at the beginning aready? Do nothing
			if (index === 0)
				return false;

			var positions = [];
			_.forEach(this.collection.items, function (item, i) { positions.push(i); });
			positions[index]--;
			positions[index-1]++;

			this.collection.setOrder(positions);
			return true;
		};

	}


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	$.fn.removeStyle = function (style_key) {
		var $this = $(this);
		
		if (_.isArray(style_key)) {
			_.forEach(style_key, function (style) {
				$this.removeStyle(style);
			});
		} else {
			var style_attr = $this.attr('style');
			
			if ( ! style_attr) {
				return $this;
			}

			style_attr = style_attr
				.replace(/\*.*\*/g,'') // removes comments...mostly
				.replace(/\/\//g,''); // finishes removing comments

			var styles = style_attr.split(';'),
				keep = [];
			styles.pop();
			_.forEach(styles, function (style) {
				style = style.split(':');
				var key = _.trim(style[0]),
					val = _.trim(style[1]);
				if (style_key !== key) {
					keep.push(key +':'+val);
				}
			});

			if (keep.length === 0)
				$this.attr('style', null);
			else
				$this.attr('style', keep.join(';'));
		}

		return $this;
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	var $ = awf.$,
		originals = {
			deferred: $.Deferred,
			ajax: $.ajax
		};

	$.Deferred = function () {

		var dfr = originals.deferred(),
			cancel_dfr = originals.deferred(),
			start = new Date(),
			end = null;

		dfr.canceled = false;

		dfr.always(function () { end = new Date(); });

		return {
			cancel: function () {
				if (dfr.state() == 'pending') {
					dfr.canceled = true;
					cancel_dfr.resolve.apply(this, arguments);
				}
				return this;
			},

			canceled: cancel_dfr.done,

			resolve: function () {
				if ( ! dfr.canceled) {
					dfr.resolve.apply(dfr, arguments);
					return this;
				}
			},

			resolveWith: function () {
				if ( ! dfr.canceled) {
					dfr.resolveWith.apply(dfr, arguments);
					return this;
				}
			},

			reject: function () {
				if ( ! dfr.canceled) {
					dfr.reject.apply(dfr, arguments);
					return this;
				}
			},

			rejectWith: function () {
				if ( ! dfr.canceled) {
					dfr.rejectWith.apply(dfr, arguments);
					return this;
				}
			},

			notify: function () {
				if ( ! dfr.canceled) {
					dfr.notify.apply(dfr, arguments);
					return this;
				}
			},

			notifyWith: function () {
				if ( ! dfr.canceled) {
					dfr.notifyWith.apply(dfr, arguments);
					return this;
				}
			},

			state: function () {
				if (dfr.canceled) {
					return "canceled";
				} else {
					return dfr.state();
				}
			},

			then: function (doneFn, _errorFn) {

				if (doneFn) {
					dfr.done(doneFn);
				}

				if (_errorFn) {
					dfr.fail(_errorFn);
				}

				return this;

			},

			always   : dfr.always,
			promise  : dfr.promise,
			pipe     : dfr.pipe,
			done     : dfr.done,
			fail     : dfr.fail,
			progress : dfr.progress,

			duration: function () {
				if (end) {
					return end - start;
				} else {
					return null; //new Date() - start;
				}
			}
		};
	};


	$.ajax = function () {

		var dfr = $.Deferred(),
			ajax_call = originals.ajax.apply(this, arguments)
				.done(dfr.resolve)
				.fail(dfr.reject),

			newAjax = {},
			
			ajax_keys = [
				"getResponseHeader",
				"getAllResponseHeaders",
				"setRequestHeader",
				"overrideMimeType",
				"statusCode",
				"abort"
			],
			
			dfr_keys = [
				"always",
				"pipe",
				"progress",
				"cancel",
				"state",
				"fail",
				"promise",
				"done",
				"canceled"
			];

		_.forEach(ajax_keys, function (key) {
			newAjax[key] = ajax_call[key];
		});

		_.forEach(dfr_keys, function (key) {
			newAjax[key] = dfr[key];
		});

		newAjax.success = dfr.done;
		newAjax.error = dfr.fail;
		newAjax.complete = dfr.always;

		newAjax.then = function (doneFn, _errorFn) {

			if (doneFn) {
				newAjax.done(doneFn);
			}

			if (_errorFn) {
				newAjax.fail(_errorFn);
			}

			return this;

		};

		Object.defineProperty(newAjax, 'readyState', {
			enumerable: true,
			get: function () {
				return ajax_call.readyState;
			},
			set: function (val) {
				ajax_call.readyState = val;
			}
		});

		Object.defineProperty(newAjax, 'status', {
			enumerable: true,
			get: function () {
				return ajax_call.status;
			},
			set: function (val) {
				ajax_call.status = val;
			}
		});

		Object.defineProperty(newAjax, 'statusText', {
			enumerable: true,
			get: function () {
				return ajax_call.statusText;
			},
			set: function (val) {
				ajax_call.statusText = val;
			}
		});

		// canceling an ajax request should also abort the call
		newAjax.canceled(ajax_call.abort);

		return newAjax;

	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = {
		"major": 1,
		"minor": 0,
		"patch": 0,
		"name": "Beta"
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = {
		"date": "20160816",
		"iteration": 47
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Object to store/retrieve snippets
	 * @type {Object}
	 */
	awf.snippets = {};

	/**
	 * Registers a snippet
	 * @param  {String} id   ID of the snippet. Must be unique.
	 * @param  {String} text The content of the snippet.
	 * @return {Object}      this (chainable)
	 */
	awf.registerSnippet = function (id, text) {

		if (id in awf.snippets) {
			throw new Error('Cannot register snippet with the same id: `' + id + '`');
		}

		awf.snippets[id] = text;

		return this;

	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = init;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		extendJQueryEvents = __webpack_require__(3);


	// TODO: Review positioning of "app" in the startup sequence
	//       There are no conditionals on "app" initialization within init.
	//       As it is part of the Application Composition layer, awf.init() should not execute unless
	//       app.compose() and app.start() have completed first. This will be needed in cases where appCompConfig
	//       is meant to augment other config elemets (e.g. leftnav).
	//       Need to loosen the coupling between AWF Base and AWF App Composition
	// author: Mike
	// update: Mike & Josh discussed and are in agreement that this should be improved

	init.sequence = [
		{
			id: 'feature_toggles',
			fn: __webpack_require__(47)
		},
		{
			id: 'metrics',
			fn: __webpack_require__(48)
		},
		{
			id: 'search',
			fn: __webpack_require__(49)
		},
		{
			id: 'user',
			fn: __webpack_require__(50)
		},
		{
			id: 'page',
			fn: __webpack_require__(51)
		},
		{
			id: 'app',
			fn: __webpack_require__(52)
		}
	];

	// Dynamically add `external_handlers` to each sequence item
	_.forEach(init.sequence, function (item) {
		item.external_handlers = {};
	});


	/**
	 * @typedef awfConfig
	 * @memberof awf
	 * @type Object
	 * 
	 * @description The awfConfig object is used to initialize the AWF. There are two contexts in which it is used.
	 * <ul>
	 * <li>[awf.init(awfConfig)]{@link awf.init} - initializes a solution that is using AWF base layer capabilities (does NOT contain the "app" property)</li>
	 * <li>[awf.app.compose(awfConfig)]{@link awf.__.App.compose} - initializes an app that uses the AWF Application Composition layer (contains the "app" property)</li>
	 * </ul>
	 * 
	 * @property {string} id  - the unique identifier for this AWF solution
	 * @property {awf.__.FeatureToggler.featureTogglesConfig} [feature_toggles] configures the initialization of run time [feature toggling]{@link awf.__.FeatureToggler} capabilities
	 * @property {Object.<...string, boolean>} [metrics] - an object with one or more key value pairs where the key represents an external metrics handler and the boolean value indicates if the handler is active
	 * @property {awf.__.User.userConfig} [user] configures the initialization of an AWF [user]{@link awf.__.User}
	 * @property {awf.ui.Page.pageConfig} [page] configures the initialization of the AWF [Page]{@link awf.ui.Page}
	 * @property {awf.__.App.appCompConfig} [app] configures the initialization of an AWF [app]{@link awf.__.App}<br /><em>(Note: appCompConfig is part of the Application Compostition layer. Configurations containing this element must use [appCompose]{@link awf.__.App.compose} and [app.start]{@link awf.__.App.start} and should not call {@link awf.init} directly.)</em>
	 * 
	 * @example
	 * var config = {
	 *    "feature_toggles": {
	 *       "url": "data/feature-flags.json"
	 *    },
	 *    "page": {
	 *       "name": "My App",
	 *       "favicon": {
	 *          "active": "images/awf-logo-320.png"
	 *       }
	 *    }
	 * };
	 *
	 * awf.init(config);
	 * // or if using Application Compostition
	 * awf.app.compose(config);
	 * awf.app.start();
	 */


	/**
	 * @method init
	 * @memberOf awf
	 * @param  {awf.awfConfig|null} config the configuration used to initialize the AWF
	 * @return {$.Deferred}
	 * 
	 * @description Initialize awf - Get things started!<br />
	 * The returned deferred object will resolve when the initialization process has fully completed.
	 * Depending on the parameters given, certain network requests will need to be completed before the app is ready.
	 * When all of them are done, the returned deferred object will be resolved.
	 * If feature_toggles is defined, feature_toggles.url is required.
	 * 
	 * @example
	 * // No matter what goes into the parameters of init, when awf deems the application ready, it will resolve its returned promise.
	 * // Naturally, this means that chaining `then` is possible:
	 * awf.init().then(function () {
	 * 	// The application is ready!
	 * });
	 *
	 * @example
	 * // feature_toggles
	 *
	 * // This will create and initialize awf.flags
	 *
	 * // This is an object that takes two keys: `url` and `blocking`
	 *
	 * // `url` is a string. If relative, make sure it it relative to where the currently running page is.
	 * // The content of the file at that URL should return a flat JSON file where all values are either true or false
	 *
	 * // `blocking` [optional] is a boolean. Default: false.
	 * // When true, the init's promise will not resolve until after the data has been loaded and applied.
	 * // NOTE: Race conditions may occure during composition of your app if 'blocking' is set to false.
	 *
	 * awf.init({
	 * 	feature_toggles: {
	 * 		url: "data/features.json",
	 * 		blocking: true
	 * 	}
	 * });
	 */

	function init (config) {

		var dfr = $.Deferred(),
			cursor = -1;

		awf.app.experience_blockers = {};

		if ( ! config) {
			throw new Error('Cannot initialize awf with this composition object: ', config);
		}


		/*	App ID
		------------------------------------------*/
			if ( ! ('id' in config)) {
				throw new Error('Cannot initialize awf without a configured `id`.');
			}

		awf.app.id = config.id;


		// Calls the next item in `init.sequence`
		// When that one resolves, it automatically calls the next one.
		// When the last one completes, the originally returned promise is resolved
		// If *any* of the sequence items are rejected, the next sequence item is *not* called (the sequence halts), and the originally returned promise is rejected
		//
		// Note: The promises from each are merely a blocking hold, which means if one of them is "non-blocking",
		// their promise will be resolved immediately, allowing the sequence to continue without delay.
		// Naturally, this means that errors from a previous non-blocking sequence item could be shown while other sequence items are being processed.
		var current_step;
		
		function callNextSequenceItem () {
			if (++cursor < init.sequence.length) {
				current_step = init.sequence[cursor];
				init.progress.triggerHandler('change:complete', cursor);
				console.group('init sequence: `' + current_step.id + '`');
				console.time(current_step.id + ' - init step');

				var init_step_hold = $.Deferred();
				init_step_hold
					.always(function () {
						console.timeEnd(current_step.id + ' - init step');
					})
					.done(function (response) {
						console.log(response);
						console.groupEnd();
						callNextSequenceItem();
					})
					.fail(function (er) {
						console.error(er);
						console.groupEnd();
						init.progress.triggerHandler('fail', er);
						dfr.reject('init step failed: `' + current_step.id + '`');
					});

				current_step.fn.call(awf.app, config[current_step.id] || null, init_step_hold, current_step.external_handlers);

				// if not resolved immediately, it's blocking!
				if (init_step_hold.state() == 'pending') {
					console.log('blocking...');
				}

				/*if (current_step.id in config) {

				} else {
					init_step_hold.resolve('not configured');
					console.groupEnd();
				}*/
			} else {
				dfr.resolve();
				init.progress.triggerHandler('change:complete', cursor);
			}
		}

		console.groupCollapsed('init sequence');
		console.time('init sequence');
		dfr.always(function () {
			console.timeEnd(current_step.id + ' - init step');
			console.groupEnd();
			console.timeEnd('init sequence');
		});

		init.progress.triggerHandler('change:sequence', [init.sequence]);
		callNextSequenceItem();

		return dfr.promise();
	}


	// An object to allow events to emit as progress is completed
	init.progress = {};
	extendJQueryEvents(init.progress);

	awf.registerExternalInitHandler = __webpack_require__(53);

	// Temporary
	init.extend = function (obj) {

		_.forEach(obj, function (val, key) {

			console.warn('awf.init.extend still in use: ', key);

		});

	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initFeatureToggles;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);


	/**
	 * @typedef featureTogglesConfig
	 * @memberof awf.__.FeatureToggler
	 * @type Object
	 * 
	 * @description The featureTogglesConfig object is a sub-element of the AWF configuration object ([awfConfig]{@link awf.awfConfig}). It is used to configure run time feature toggling capabilities - sometimes referred to as feature flags.
	 * 
	 * @property {string} url               - a URL to the configuration file used to set runtime feature toggles
	 * @property {boolean} [blocking=false] - if true, prevents additional processing until loading of the configuration file completes (when set to false, race conditions may occur)
	 *
	 * @example <caption>A featureTogglesConfig object in the context of a larger AWF configuration ([awfConfig]{@link awf.awfConfig}) object</caption>
	 * var config = {
	 *    ...
	 *    "feature_toggles": {
	 *       "url": "data/feature-flags.json",
	 *       "blocking": true
	 *    },
	 *    ...
	 * };
	 *
	 * awf.init(config);
	 * // or if using Application Compostition
	 * awf.app.compose(config);
	 * awf.app.start();
	 */

	function initFeatureToggles (feature_toggles_config, dfr_hold, external_handlers) {


		/**
		 * @instance flags
		 * @memberOf awf
		 * @type {awf.__.FeatureToggler}
		 * 
		 * @description The default instance, created if [featureTogglesConfig]{@link awf.__.FeatureToggler.featureTogglesConfig} is included in the configuration for {@link awf.init} or [awf.app.compose]{@link awf.__.App.compose}
		 */
		
		awf.flags = new awf.__.FeatureToggler();

		if (feature_toggles_config) {

			try {
				console.log('initializing awf.flags using url `' + feature_toggles_config.url + '`');
				awf.flags.init(feature_toggles_config.url)
					.done(function (response) {
						dfr_hold.resolve('feature_toggles data has loaded');
					})
					.fail(dfr_hold.reject);
			} catch (er) {
				console.warn("awf.flags.init() failed");
				dfr_hold.reject(er);
			}

			if ( ! feature_toggles_config.blocking) {
				dfr_hold.resolve('non-blocking');
			}

		} else {

			dfr_hold.resolve('not configured');

		}

	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initMetrics;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	awf.tagMetric = function () { console.warn('Metrics has not yet been initialized.'); };

	awf.createMetricTagger = function () {
		console.warn('Metrics has not yet been initialized.');
		return function () {
			console.warn('Metrics has not yet been initialized.');
		};
	};

	function initMetrics (metrics_config, dfr_hold, external_handlers) {

		if (metrics_config) {

			/**
			 * @instance metrics
			 * @memberOf awf
			 * @type {object}
			 *
			 * @description An obect that provides the namespace for metrics related functions.
			 */

			// TODO: Verify that this doc is correct.
			//       Mike changed it from an empty @namespace to a static member of awf,
			//       but it appears as though awf.metrics is not really used, except as a holding place for external handlers.
			//       (e.g. Shouldn't awf.tagMetric be awf.metrics.tag?)

			awf.metrics = {};

			var tagger = new awf.__.BaseObject();

			awf.tagMetric = function (data) {
				tagger.triggerHandler('tag', [data]);
			};

			awf.tagMetric.extend = function (obj) {
				_.forEach(obj, function (fn, key) {
					tagger.on('tag.' + key, function (ev, data) {
						fn.call(awf.metrics[key], data);
					});
				});
			};



			awf.createMetricTagger = function (template) {
				return function (data) {
					awf.tagMetric(_.defaults({}, data, template));
				};
			};



			/*	External Handlers
			------------------------------------------*/
				var external_holds = [];

				console.group('external handlers');
				_.forEach(metrics_config, function (handler_config, key) {
					if (key in external_handlers) {
						var dfr = $.Deferred();
						console.group(key);
						dfr
							.done(function (response) {
								console.log('metrics external handler `' + key + '` has been resolved:');
								console.log(response);
							})
							.fail(function (er) {
								console.warn('metrics external handler `' + key + '` has been rejected:');
								console.error(er);
							});
						external_handlers[key].call(null, dfr, handler_config);
						if (dfr.state() == 'pending') {
							console.log('blocking');
						}
						console.groupEnd();
						external_holds.push(dfr);
					} else {
						console.warn('No external metric handler was registered for `' + key + '`.');
					}
				});
				console.groupEnd();

			// When all the external holds have been released, release the overal metrics hold
			$.when.apply($, external_holds)
				.done(dfr_hold.resolve)
				.fail(dfr_hold.reject);

		} else {
			dfr_hold.resolve('not configured');
		}

	}


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initSearch;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	function initSearch (config, dfr_hold, external_handlers) {

		awf.search = new awf.__.Search();

		console.group('Standard Search Channels');
		_.forEach(awf.search_registry.standard, function (params, id) {
			console.log(id);
			awf.search.addChannel(id, params);
		});
		console.groupEnd();


		console.group('Local Search Channels');
		_.forEach(awf.search_registry.local, function (params, id) {
			console.log(id);
			awf.search.addLocalChannel(id, params);
		});
		console.groupEnd();


		if (config) {

			dfr_hold.reject('initSearch() has not yet been refactored');

		} else {

			dfr_hold.resolve('not configured');

		}

	}


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initUser;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);


	/**
	 * @typedef userConfig
	 * @memberOf awf.__.User
	 * @type Object
	 * 
	 * @description The featureTogglesConfig object is a sub-element of the AWF configuration object ([awfConfig]{@link awf.awfConfig}). It is used to configure User Services for the application.
	 * 
	 * @property {boolean} blocking=false     - if true, prevents additional processing until configuration of the user object completes (when set to false, race conditions may occur)
	 * 
	 * @todo validate the blocking property
	 */

	function initUser (user_config, dfr_hold, external_handlers) {

		if (user_config) {

			/*	Set up user-based config flags
			------------------------------------------*/
				if (awf.flags) {
					awf.user.authentication.done(function () {
						awf.flags.apply();
					});
				}


			/*	External Handlers
			------------------------------------------*/
				var external_holds = [];

				console.group('external handlers');
				_.forEach(user_config, function (handler_config, key) {
					if (key in external_handlers) {
						var dfr = $.Deferred();
						dfr
							.done(function (response) {
								console.log('user external handler `' + key + '` has been resolved:');
								console.log(response);
							})
							.fail(function (er) {
								console.warn('user external handler `' + key + '` has been rejected:');
								console.error(er);
							});
						console.group(key);
						external_handlers[key].call(null, dfr, handler_config);
						if (dfr.state() == 'pending') {
							console.log('blocking');
						}
						console.groupEnd();
						external_holds.push(dfr);
					} else {
						console.warn('No external user handler was registered for `' + key + '`.');
					}
				});
				console.groupEnd();

			// When all the external holds have been released, release the overal user hold
			$.when.apply($, external_holds)
				.done(dfr_hold.resolve)
				.fail(dfr_hold.reject);


		} else {
			awf.user.authentication.reject('no user configured');
			dfr_hold.resolve('not configured');
		}

	}


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initPage;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	function initPage (config, dfr_hold, external_handlers) {

		if (config) {

			if (config === true) {
				config = {};
			}

			/*	Badges
			------------------------------------------*/
			awf.badge_db = new awf.__.BadgeDB();


			/*	Page UI
			------------------------------------------*/
			_.defaults(config, {
				parent: $('body')
			});


			/**
			 * @instance page
			 * @memberOf awf
			 * @type {awf.page}
			 * 
			 * @description The default instance, created if [pageConfig]{@link awf.ui.Page.pageConfig} is included in the configuration for {@link awf.init} or [awf.app.compose]{@link awf.__.App.compose}
			 */
			awf.page = new awf.ui.Page(config);

			dfr_hold.resolve('done');

		} else {

			dfr_hold.resolve('not configured');

		}

	}

	// The following doc describes the w3 Feature Pack.
	// TODO: Move to w3FeaturePack repo

	/**
	 * @module w3FeaturePack
	 * @name w3 Feature Pack
	 * 
	 * @description 
	 * With the w3 adapter for AWF, awf.init() and awf.app.compose() are
	 * able to help easily create a w3 masthead and footer for your solution.<br>
	 * The following examples show how it can be done.<br>
	 * 
	 * @see {@link awf}
	 * @see {@link awf.page}
	 * @see {@link awf.page.themes}
	 * @see {@link awf.page.children.masthead}
	 * @see {@link awf.page.children.masthead.masthead_trays}
	 * @see {@link awf.page.children.masthead.masthead_trays.items.settings}
	 * @see {@link awf.page.children.masthead.masthead_trays.items.settings.theme_switcher}
	 * @see {@link awf.page.children.footer}
	 *
	 * @example
	 * // awf.init();
	 * awf.init({ page: true });
	 *
	 * // or
	 *
	 * awf.init({
	 *   page: {
	 *     name: "Your Page Name"
	 *   }
	 * });
	 *
	 * @example
	 * // awf.app.compose();
	 * awf.app.compose({ layout: true }).start();
	 *
	 * @example
	 * // All examples to follow use awf.init(). They also could be
	 * // written using awf.app.compose() by simply renaming the passed
	 * // object's property 'page' to 'layout'.
	 *
	 * @example
	 * // Leave out a specific component by setting it to false.
	 * // The following will create the page without a footer.
	 * awf.init({
	 *   page: {
	 *     footer: false
	 *   }
	 * });
	 *
	 * @example
	 * // Default values exist for the page components.
	 * // See documentation for awf namespaces in order to override any defaults
	 *
	 * // The following will create the page with a custom name, custom header
	 * // logo, and custom footer links. It also disables settings.
	 * awf.init({
	 *   page: {
	 *     name: "My Page",
	 *     masthead: {
	 *       logo: "/relative/path/to/logo.png",
	 *       masthead_trays: {
	 *         settings: false
	 *       }
	 *     },
	 *     footer: {
	 *       links: [
	 *         {
	 *           label: "Google",
	 *           href: "http://www.google.com"
	 *         },
	 *         {
	 *           label: "Yahoo",
	 *           href: "http://www.yahoo.com"
	 *         }
	 *       ]
	 *     }
	 *   }
	 * });
	 *
	 * @example
	 * // Search Metrics
	 *
	 * // Search results click metrics are gathered using awf.tagMetric(). The
	 * // following information describes what is being tagged.
	 *
	 * awf.tagMetric({
	 *   ev: 'click: search result item', //static text
	 *   name: STRING, //the search input's value at the time of the metric
	 *   target: STRING, //the clicked result's title text
	 *   action: INTEGER, //the clicked result's order within its bucket
	 *   section: STRING, //the clicked result's bucket's ID value
	 *   group: INTEGER, //the clicked result's bucket's order within the results list
	 *   module: STRING //the clicked results's channel's ID value
	 * });
	 *
	 * @example
	 * // Search results click metrics are active 'out-of-the-box'. If they aren't wanted or needed,
	 * // a feature flag can be added to page init or app compose, and then leveraged in your app's
	 * // feature flag config file.
	 *
	 * awf.init({
	 *   page: {
	 *     masthead: {
	 *       search: {
	 *         metrics_flag: "metrics.search.results"
	 *       }
	 *     }
	 *   }
	 * });
	 *
	 * // OR
	 *
	 * awf.app.compose({
	 *   layout: {
	 *     masthead: {
	 *       search: {
	 *         metrics_flag: "metrics.search.results"
	 *       }
	 *     }
	 *   }
	 * }).start();
	 *
	 *
	 * // THEN
	 *
	 * // In the feature flag config file..
	 *
	 * {
	 *   ...,
	 *   metrics: {
	 *     search: {
	 *       results: false
	 *     }
	 *   },
	 *   ...
	 * }
	 *
	 */


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = initApp;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	// TODO: Move "starting_experience" and "leftnav" properties
	//       These don't feel like they are at the right level. Need to talk it through.
	// author: Mike

	/**
	 * @typedef appCompConfig
	 * @memberof awf.__.App
	 * @type Object
	 *
	 * @description The appCompConfig object is a sub-element of the AWF configuration object ([awfConfig]{@link awf.awfConfig}). It is used to describe the configurable elements that structure the app during [awf.app.compose()]{@link awf.__.App.compose}. The configuration will be executed at [awf.app.start()]{@link awf.__.App.start}.
	 *
	 * @property {boolean} [customization=false] - When true, enables remote storage of configuration for UI composition
	 * @property {Object.<...string, awf.__.Cog.cogConfig>} [cogs] - An object with one or more key value pairs where the key represents the Cog ID and the value is a cogConfig object. NOTE - This is a convenience method for registering cogs during app composition - [registerCog]{@link awf.__.App.registerCog} is preferred
	 * @property {Object.<...string, awf.__.Experience.experienceConfig>} [experiences] - An object with one or more key value pairs where the key represents the Experience ID and the value is an experienceConfig object. NOTE - This is a convenience method for registering experiences during app composition - [registerExperience]{@link awf.__.App.registerExperience} is preferred.
	 * @property {string} [starting_experience] - the id of the experience that the app will start with
	 * @property {Object} [leftnav] - an object describing the layout of the left navigator, the default experience switcher
	 *
	 * @example <caption>An appCompConfig object passed to the [compose]{@link awf.__.App.compose} method. (Not all properties are represented in this example.)</caption>
	 * var config = {
	 *    "id": "awf-example-app",
	 *    ...
	 *    "app": {
	 *       "customization": true,
	 *       "starting_experience": "home"
	 *    },
	 *    ...
	 * };
	 *
	 * awf.app.registerExperience("home", experience_params);
	 *
	 * awf.app.compose(config);
	 * awf.app.start();
	 */

	function initApp (app_config, dfr_app_hold, external_handlers) {

		var self = this;

		if (app_config) {

			/*	If provided, register cogs
			------------------------------------------*/
				/*if ('cogs' in app_config) {
					console.time('registering cogs');
					_.forEach(app_config.cogs, function (params, id) {
						self.registerCog(id, params);
					});
					console.timeEnd('registering cogs');
				}*/





			/*	If provided, register experiences
			------------------------------------------*/
				if ('experiences' in app_config) {
					console.time('registering experiences');
					_.forEach(app_config.experiences, function (params, id) {
						self.registerExperience(id, params);
					});
					console.time('registering experiences');
				}





			/*	Planting experience seeds
			------------------------------------------*/
				console.time('planting experience seeds');
				console.group('Planting experience seeds');
				var default_order = _.get(app_config, 'leftnav.default_order');
				if (default_order) {
					_.forEach(default_order, function (item, i) {
						if (typeof(item) == "string") {
							self.potential_experience_seeds.push({
								type: item,
								id: item
							});
						} else {
							self.potential_experience_seeds.push(item);
						}
						console.log(self.potential_experience_seeds[self.potential_experience_seeds.length - 1]);
					});
				}
				console.timeEnd('planting experience seeds');
				console.groupEnd();





			/*	Adding App-level Cogs
			------------------------------------------*/
				awf.app.cog_types = app_config.cogs;
				console.time('initializing app cogs');
				awf.app.initializeCogs();
				console.timeEnd('initializing app cogs');


				/*	Masthead Trays
				------------------------------------------*/
					if (_.get(awf, 'page.children.masthead.children.trays')) {

						console.time('masthead trays');

						/*	Settings
						------------------------------------------*/
							console.group("Creating Settings Cog");
							var settings_cog = new awf.__.Cog({
									id: "settings",
									views: {
										masthead_tray: {
											label: 'Settings',
											icon: 'awficon-settings',
											init: function () {
												this.namespace = 'masthead-tray';
											},
											render: function ($container) {

												var self = this;

												self.theme_switcher = new awf.ui.ThemeSwitcher({
														themes: awf.page.themes.items,
														parent: $container
													});

												// "Select" the current theme
												self.theme_switcher.renderCurrent(awf.page.themes.current_theme);

												//Listen for Theme Switcher events
												self.theme_switcher
													.on('select-theme.' + this.namespace, function (e, key) {
														awf.page.themes.setTheme(key);
													})
													.on('apply-theme.' + this.namespace, function (e, key) {
														awf.page.themes.applyTheme(key);
													})
													.on('reset-theme.' + this.namespace, function () {
														awf.page.themes.applyTheme();
													});

												//Listen for Themes event
												awf.page.themes
													.on('change.' + this.namespace, function (e, key) {
														self.theme_switcher.renderCurrent(key);
													});
											},
											destroy: function () {
												console.log('Destroying theme switcher');
												this.theme_switcher.destroy();
												delete this.theme_switcher;
												awf.page.themes.off('change.' + this.namespace);
											}
										}
									}
								});
							console.groupEnd();

							console.group("Adding Settings cog to masthead trays.");
							awf.page.children.masthead.children.trays.addItem(settings_cog);
							console.groupEnd();

						/*	App-level Cogs
						------------------------------------------*/
							if ('masthead_trays' in app_config) {

								console.group("Adding app-level cogs: Masthead Trays");

								_.forEach(app_config.masthead_trays, function (cog_id) {

									console.log('cog_id: ', cog_id);

									if (_.contains(awf.app.cog_types, cog_id)) {

										var cog;

										console.group('Setting up ', cog_id);

										try {
											cog = awf.app.getOrCreateCog(cog_id);
										} catch (er) {
											console.warn("Cannot get cog: ", cog_id);
											console.error(er);
										}

										console.groupEnd();


										if ( ! cog.isAvailable()) {
											console.info('The `' + cog.type + '` cog is disabled from the `' + cog.flag + '` feature flag.');
										} else if (cog.isViewAvailable('masthead_tray') === null) {
											console.info('The `' + cog.type + '` cog\'s masthead_tray view does not exist.');
										} else if (cog.isViewAvailable('masthead_tray') === false) {
											console.info('The `' + cog.type + '` cog\'s masthead_tray view is disabled from the `' + cog.views.masthead_tray.flag + '` feature flag.');
										} else {
											try {
												awf.page.children.masthead.children.trays.addItem(cog);
											} catch (er) {
												console.warn('Could not add cog `' + cog.id + '` to the Masthead trays.');
												console.error(er);
											}
										}

									} else {
										console.warn(_.template('Masthead tray `{{cog_id}}` was not listed in the available app-level cogs, therefore it will not be added.')({
											cog_id: cog_id
										}));
									}

								});

								console.groupEnd();
							} else {
								console.log('no masthead_trays configured');
							}

						console.time('masthead trays');
					} else {
						console.info('Skipping Masthead Trays: awf.page.children.masthead.children.trays does not exist.');
					}


				/*	Page Trays
				------------------------------------------*/
					if (_.get(awf, 'page')) {
						console.time('page trays');

						/*	App-level Cogs
						------------------------------------------*/
							if ('page_trays' in app_config) {

								console.group("Adding app-level cogs: Page Trays");

								_.forEach(app_config.page_trays, function (cog_id) {

									console.log('cog_id: ', cog_id);

									if (_.contains(awf.app.cog_types, cog_id)) {

										var cog;

										console.group('Setting up ', cog_id);

										try {
											cog = awf.app.getOrCreateCog(cog_id);
										} catch (er) {
											console.warn("Cannot get cog: ", cog_id);
											console.error(er);
										}

										console.groupEnd();


										if ( ! cog.isAvailable()) {
											console.info('The `' + cog.type + '` cog is disabled from the `' + cog.flag + '` feature flag.');
										} else if (cog.isViewAvailable('medium') === null) {
											console.info('The `' + cog.type + '` cog\'s medium view does not exist.');
										} else if (cog.isViewAvailable('medium') === false) {
											console.info('The `' + cog.type + '` cog\'s medium view is disabled from the `' + cog.views.medium.flag + '` feature flag.');
										} else {
											try {
												awf.page.addTray(cog);
											} catch (er) {
												console.warn('Could not add cog `' + cog.id + '` to the Page trays.');
												console.error(er);
											}
										}

									} else {
										console.warn(_.template('Page tray `{{cog_id}}` was not listed in the available app-level cogs, therefore it will not be added.')({
											cog_id: cog_id
										}));
									}

								});

								console.groupEnd();
							} else {
								console.log('no page_trays configured');
							}

						console.timeEnd('page trays');
					} else {
						console.info('Skipping Page Trays: awf.page does not exist.');
					}





			/*	Customization
			------------------------------------------*/
				console.time('construct');

				if (awf.app.id) {
					awf.construct.setAppid(awf.app.id);
					if (typeof(app_config.customization) == 'object') {
						if (typeof(app_config.customization.service) == 'object') {
							if (app_config.customization.service.timeout) {
								awf.construct.setTimeout(app_config.customization.service.timeout);
							}

							if (typeof(app_config.customization.service.endpoint) == 'string') {
								awf.construct.setEndpoint(app_config.customization.service.endpoint);

								//awf.user.authentication
									//.done(function (is_authenticated) {
										//if (is_authenticated) {
											console.log('Fetching all construct service items...');
											awf.construct.fetchAll(-1)
												.always(function () {
													console.timeEnd('construct');
												})
												.done(function () {
													_.forEach(awf.construct.toJSON(), function (val, key) {
														if (key.indexOf('experience : ') === 0) {
															awf.util.setStoredObject(key, val);
														}
													});
												});
										//} else {
										//	console.timeEnd('construct');
										//	awf.construct.ready.reject('anonymous');
										//	console.log('Construct service will not fetchAll -- you appear to be anonymous');
										//}
									//})
									//.fail(function () {
									//	console.timeEnd('construct');
								//		console.log('Construct service will not fetchAll -- authentication failed');
								//	});
							} else {
								console.timeEnd('construct');
								console.info('Cannot initialize awf.construct. `config.app.customization.service.endpoint` was not defined.');
							}
						} else {
							console.timeEnd('construct');
							console.info('Cannot initialize awf.construct. `config.app.customization.service` was not defined.');
						}
					} else {
						console.timeEnd('construct');
						console.info('Cannot initialize awf.construct. `config.app.customization` was not defined.');
					}
				} else {
					console.timeEnd('construct');
					console.warn('Cannot instantiate awf.construct: awf.app.id is not defined');
				}





			/*	Custom Name
			------------------------------------------*/
				console.time('custom name');
				// todo: Add unit test -- custom name instance
				$.when(awf.construct.ready, awf.user.authentication)
					.done(function () {
						console.log("Construct and User!! :");

						var custom_name_params = awf.page.children.masthead.custom_name_params,
							masthead = awf.page.children.masthead;

						if (masthead.customizable_name_spinner) {
							masthead.customizable_name_spinner.destroy();
						}

						if (/*custom_name_params.value && */masthead.customizable_name) {

							console.log('Adding custom_name');

							/**
							 * The default instance, created if included in awf.app.compose()
							 * @type {awf.ui.CustomName}
							 * @memberOf awf.page.children.masthead.children
							 * @name  awf.page.children.masthead.children.custom_name
							 * @namespace  awf.page.children.masthead.children.custom_name
							 * @see {@link awf.ui.CustomName} for more details
							 *
							 * @example
							 * // masthead
							 *
							 * // This will create and initialize awf.page.children.masthead.children.custom_name
							 *
							 * awf.app.compose({
							 * 	"id": "awf-example-main",
							 * 	"user": {
							 * 		"blocking": false
							 * 	},
							 * 	"construct_service": true,
							 * 	"page": {
							 * 		"name": "Josh's App",
							 * 		"masthead": {
							 * 			"customizable_name": true,
							 * 			"logo": "/path/to/logo.png"
							 * 		},
							 * 		...
							 * });
							 *
							 */
							masthead.children.custom_name = new awf.ui.CustomName({
								parent: masthead._$brand_name,
								name: masthead.name
							});

							masthead.children.custom_name.pref = awf.construct.getOrCreate("custom_name");

							_.extend(masthead.children.custom_name, {

								/**
								 * Hides and resets the edit form
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @instance
								 *
								 * @fires this#edit:cancel
								 */
								cancelEdit: function () {
									this._$input.val('').blur();
									masthead.$el.removeClass('edit-name-active');
									this._$button.focus();
									this.triggerHandler("edit:cancel");
								},

								/**
								 * If this.allow_edit is true, this method displays the edit form
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @instance
								 *
								 * @fires this#edit:start
								 */
								startEdit: function () {
									var self = this;
									if (self.allow_edit) {
										var value = self.cleanValue(self._$name.text());

										self._$input.val(value);
										masthead.$el.addClass('edit-name-active');
										setTimeout(function () {
											self._$input.select();
										}, 250);
										self.triggerHandler("edit:start");
										self.setRemainingCharCount();
									}
								},

								/**
								 * Updates the remaining characters count (this._$count) value
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @instance
								 */
								setRemainingCharCount: function () {
									var count = this.max_length;
									if (count)
										this._$count.html(count - this._$input.val().length);
								},

								/**
								 * Truncates passed value based on the limit set by this.max_length
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @param {string} value The string to potentially truncate
								 * @instance
								 *
								 * @return {string} The potentially truncated string
								 */
								cleanValue: function (value) {
									var max_char = this.max_length;
									value = value.trim();

									return (max_char && value.length > max_char) ? value.substring(0, max_char) : value;
								},

								/**
								 * Saves submitted form's input value to the construct service. This will also
								 * display meaningful save-status messages to the user via UI.
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @instance
								 *
								 * @fires this#save:finished
								 */
								saveChanges: function () {
									var self = this,
										value = self.cleanValue(self._$input.val());

									if (value) {
										var deferred = masthead.children.custom_name.pref.setValue(value).save();

										self._$name.html("<strong>saving...</strong>");
										self.setAllowEdit(false);
										deferred.done(function () {
											self._$name.html("<strong>saved!</strong>");
											_.delay(function() {
												self._$name.hide().html(_.escape(value)).fadeIn(500);
											}, 500);
										})
										.fail(function () {
											self._$name.html("<strong>save failed. :(</strong>");
											_.delay(function() {
												self._$name.hide();
												self.updateMastheadName();
												self._$name.fadeIn(500);
											}, 1000);
										})
										.always(function () {
											_.delay(function() {
												self.setAllowEdit(true);
												self._$button.focus();
												self.triggerHandler("save:finished");
											}, 1100);
										});
									}

									self.cancelEdit();
								},

								/**
								 * When the user is authenticated, this method updates the masthead title, otherwise
								 * it will disable the ability to edit.
								 * @memberOf awf.page.children.masthead.children.custom_name
								 * @instance
								 *
								 * @example
								 * // The fired event for this method can be leveraged in your application's code
								 * // to do more detailed updating to the masthead title.
								 *
								 * // For example, if there is no custom_name in the construct service, you may
								 * // want to fall back on the user's name/nickname.
								 *
								 * masthead.children.custom_name.on('update', function (ev, val) {
								 * 	if ( ! val) {
								 * 		var user_name = awf.user.info.nickname || awf.user.info.name;
								 * 		if (user_name)
								 * 			user_name = user_name + "&#8217;s App";
								 * 		masthead.children.custom_name.setName(user_name || awf.page.name);
								 * 	}
								 * });
								 *
								 * @fires this#update:name passing the updated value
								 */
								updateMastheadName: function () {
									if (awf.user.is_authenticated) {
										var custom_name_value = _.escape(masthead.children.custom_name.pref.value);

										if (! (custom_name_value === "" || custom_name_value === null)) {
											this.setName(custom_name_value);
											this.triggerHandler('update:name', custom_name_value);
										} else {
											this.setName(null);
											this.triggerHandler('update:name', null);
										}

										this.setAllowEdit(true);
									} else {
										this.setAllowEdit(false);
									}
								}

							});

							masthead.children.custom_name
								.on('click:cancel keyup:esc', masthead.children.custom_name.cancelEdit)
								.on('click:edit', masthead.children.custom_name.startEdit)
								.on('click:save keyup:enter', masthead.children.custom_name.saveChanges)
								.on('input:keyup', masthead.children.custom_name.setRemainingCharCount);

							masthead.children.custom_name.pref.on("change:value", function () {
								masthead.children.custom_name.updateMastheadName();
							});

							// awf.user.authentication
							// 	.done(function () {
							// 		masthead.children.custom_name.updateMastheadName();
							// 	});

							$(window).on("resize.custom_name", function () {
								if (masthead.$el.hasClass('edit-name-active')) {
									masthead.children.custom_name.cancelEdit();
								}
							});

							masthead.children.custom_name.updateMastheadName();

						} else {
							console.log('not configured: `custom_name`');
						}

					})
					.fail(function (er) {
						console.log("NOPE!! Construct and User!! :");
						console.error(er);

						if (_.get(awf, 'page.children.masthead.customizable_name_spinner')) {
							awf.page.children.masthead.customizable_name_spinner.destroy();
						}

						if (_.get(awf, 'page.children.masthead')) {
							awf.page.children.masthead
								.setCustomizableName(false)
								.setName(awf.page.name);
						}

						if (awf.user.is_authenticated) {
							awf.app.postMessage('error', "Cannot retrieve the application's custom name", false).andDismissIn(5);
						}

						console.log('cannot configure `custom_name`, construct service failed to load.');
					})
					.always(function () {
						console.timeEnd('custom name');
					});





			/*	Select the right one
			------------------------------------------*/
				awf.app.logExperienceBlockers();

				var experience_dfr = $.when.apply($, _.values(self.experience_blockers)),
					is_tracking = experience_dfr.state() == 'pending';

				if (is_tracking) {
					console.time('experience blocking');
				}

				experience_dfr
					.always(function () {
						if (is_tracking){
							console.timeEnd('experience blocking');
						}
					})
					.done(function () {

						/*	LeftNav
						------------------------------------------*/
							console.group('Connecting leftnav to experiences');

							console.time('rendering leftnav');

							if (_.get(awf, 'page.leftnav_spinner.$el')) {
								awf.page.leftnav_spinner.destroy();
							}

							_.forEach(self.potential_experience_seeds, function (seed) {

								var experience_params = self.registered_experiences[seed.type];

								self.kinetic_experience_seeds.push(seed);
								_.last(self.kinetic_experience_seeds).potential = seed;
								seed.kinetic = _.last(self.kinetic_experience_seeds);

								console.log(_.template('Adding experience to leftnav: `{{label}}`')({
									label: experience_params.label
								}));

								/*	Create a LeftNav Item
								------------------------------------------*/
									var leftnav_item = awf.page.children.leftnav.addItem({
											label: experience_params.label,
											icon: experience_params.icon,
											active_icon: experience_params.active_icon
										});

									leftnav_item.experience_id = seed.id;

								/*	Watch for LeftNav changes
								------------------------------------------*/
									leftnav_item.on('change:active_state', function (ev, val) {
										if (val === true) {
											console.log('leftnav item clicked. Exp id:', this.experience_id);
											self.setCurrentExperience(this.experience_id);
										}
									});


								/*	Watch for Feature Flag Changes
								------------------------------------------*/
									if ('flag' in experience_params) {
										awf.flags.runAndWatch(experience_params.flag, function (is_active) {
											if (is_active || app_config.starting_experience == seed.id) {
												leftnav_item.$el.show();
												console.log(_.template('Showing leftnav item `{{id}}`: "{{label}}"')({
													label: experience_params.label,
													id: seed.id
												}));
											} else {
												leftnav_item.$el.hide();
												console.log(_.template('Hiding leftnav item `{{id}}`: "{{label}}"')({
													label: experience_params.label,
													id: seed.id
												}));

												// Move to default if currently on this experience
												if (seed.id === _.get(awf, 'app.experience.id')) {

													if (app_config.starting_experience) {
														var index = _.indexOf(_.map(awf.page.children.leftnav.items, 'experience_id'), app_config.starting_experience);
														awf.page.children.leftnav.setActiveIndex(index);
													}

												}

											}
										});
									}

								/*
								} else {
									console.log(_.template('Not showing leftnav `{{type}}`: feature flag `{{flag}}` is currently inactive.')({
										type: seed.type,
										flag: experience_params.flag
									}));
								}*/

							});


							/*	Watch for experience changes
							------------------------------------------*/
								self.on('change:experience', function (ev, index) {
									console.group('Switching to experience [' + index + ']');
									console.log(self.kinetic_experience_seeds[index]);

									awf.page.children.leftnav.setActiveIndex(index);

									console.groupEnd(); // for 'Switching to experience: {id}'
								});
								//console.groupEnd(); // for 'Setting up leftnav'

							console.timeEnd('rendering leftnav');





						console.time('launching default experience');
						console.log('starting_experience: ', app_config.starting_experience);
						if (app_config.starting_experience) {

							var exp = _.find(self.potential_experience_seeds, function (item) {
									return item.id == app_config.starting_experience;
								}),
								flag = self.registered_experiences[exp.type].flag,
								index = _.indexOf(_.map(awf.page.children.leftnav.items, 'experience_id'), app_config.starting_experience);

							if (flag) {
								awf.app.postMessage('warn', 'The default experience is feature-flagged. This is being ignored.');
							}

							awf.page.children.leftnav.setActiveIndex(index);

						}
						console.timeEnd('launching default experience');

					})
					.fail(function () {

						// todo: What do we do now?!??

					});





			/*	Events
			------------------------------------------*/
				console.group("Events");

				console.time('events');

				_.forEach(awf.app.events, function (params, key) {

					if (awf.util.event.check(key)) {

						console.log('Not running event `' + key + '`, it has already been claimed.');

					} else {
						if ( ! ('flag' in params) || (params.flag && awf.flags.isActive(params.flag))) {

							var now = new Date(),
								start = new Date(params.start);

							if (now >= start) {

								var end = new Date(params.end);

								if (now < end) {

									console.group('Running event `' + key + '`.');
									awf.util.event.claim(key);
									try {
										params.callback.call(params);
									} catch (er) {
										console.warn('Event `' + key + '` failed.');
										console.error(er);
									}
									console.groupEnd();

								}  else {
									console.log('Not running event `' + key + '`, it\'s end time has passed.');
								}

							} else {
								console.log('Not running event `' + key + '`, it\'s start time has not yet happened.');
							}

						} else {
							console.log('Not running event `' + key + '`, feature flag has prevented it.');
						}

					}
				});

				console.timeEnd('events');

				console.groupEnd();





			/*	Custom Background
			------------------------------------------*/
				console.time('custom background');


				/*	Custom Background Image
				------------------------------------------*/
					var bg_img_pref = awf.construct.getOrCreate('background'),

						bg_img_dfr = bg_img_pref.fetch(-1)
							.done(function (val) {
								if (val !== null) {
									awf.page.setBackground(val);
								}

								// watch for page updates
								awf.page.on('change:background', function (ev, bg) {
									bg_img_pref
										.setValue(bg)
										.save();
								});
							});


				/*	Custom Background Position
				------------------------------------------*/
					var bg_pos_pref = awf.construct.getOrCreate('background-position'),

						bg_pos_dfr = bg_pos_pref.fetch(-1)
							.done(function (val) {
								if (val !== null) {
									awf.page.setBackgroundPosition(val);
								}

								// watch for page updates
								awf.page.on('change:background_position', function (ev, bg_pos) {
									bg_pos_pref
										.setValue(bg_pos)
										.save();
								});
							});


					/*	All Done
					------------------------------------------*/
						$.when(bg_img_dfr, bg_pos_dfr)
							.always(function () {
								console.timeEnd('custom background');
							});





			dfr_app_hold.resolve('app init complete');

		} else {

			dfr_app_hold.resolve('not configured');

		}

	}


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = registerExternalInitHandler;

	var _ = __webpack_require__(5);

	function registerExternalInitHandler (step, id, handler) {

		/*	check that the step exists
		------------------------------------------*/
		var steps = _.map(awf.init.sequence, 'id'),
			step_index = _.indexOf(_.map(awf.init.sequence, 'id'), step);

		if (step_index == -1) {
			throw new Error(_.template('Cannot register external init handler: `{{step}}`. That sequence step does not exist.')({
				step: step
			}));
		}


		/*	Check that the ID is not already taken
		------------------------------------------*/
		if (id in awf.init.sequence[step_index].external_handlers) {
			throw new Error(_.template('Cannot register external init `{{step}}` handler for `{{id}}`. That id is already taken for that step.')({
				step: step,
				id: id
			}));
		}


		/*	Add the handler
		------------------------------------------*/
		awf.init.sequence[step_index].external_handlers[id] = handler;
	}


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/*	Base
	------------------------------------------*/
		awf.__.App                       = __webpack_require__(55);
		awf.app                          = new awf.__.App();

		awf.__.Color                     = __webpack_require__(56);

		awf.__.BaseModel                 = __webpack_require__(57);


	/*	Web Workers
	------------------------------------------*/
		awf.__.CustomWorker              = __webpack_require__(58);
		awf.__.LocalSearchWorker         = __webpack_require__(59);


	/*	Cache
	------------------------------------------*/
		awf.__.DeferredCache             = __webpack_require__(60);


	/*	Services
	------------------------------------------*/
		awf.__.Service                   = __webpack_require__(61);
		awf.__.CallbackService           = __webpack_require__(62);
		awf.__.AjaxService               = __webpack_require__(63);
		awf.__.SaveableService           = __webpack_require__(64);
		awf.__.LocalStorageService       = __webpack_require__(65);


	/*	Construct Service
	------------------------------------------*/
		awf.__.ConstructServiceItem      = __webpack_require__(66);
		awf.__.ConstructService          = __webpack_require__(67);


	/*	Drag Handler
	------------------------------------------*/
		awf.__.DragHandler               = __webpack_require__(68);


	/*	Collection
	------------------------------------------*/
		awf.__.CollectionItem            = __webpack_require__(70);
		awf.__.Collection                = __webpack_require__(71);


	/*	DB
	------------------------------------------*/
		awf.__.DBDimensionGroup          = __webpack_require__(72);
		awf.__.DBDimension               = __webpack_require__(73);
		awf.__.DB                        = __webpack_require__(74);


	/*	Badge DB
	------------------------------------------*/
		awf.__.BadgeDBItem               = __webpack_require__(75);
		awf.__.BadgeDB                   = __webpack_require__(76);


	awf.__.Cog                           = __webpack_require__(77);

	awf.__.Experience                    = __webpack_require__(78);

	awf.__.Map                           = __webpack_require__(79);


	__webpack_require__(80);
	__webpack_require__(85);


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = App;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4);

	awf.util.use(awf.__.BaseObject).toCreate(App);

	/**
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseObject}
	 *
	 * @classdesc
	 * The App class provides the base for the Application Composition capabilities of the AWF. Through the {@link awf.__.App.compose} method, many of the elements of a single page application are created for you. Where appropriate, the instance names of elements created through the use of Application Composition will be provided to you within the documentation for the individual classes behind those elements.
	 *
	 * @description
	 * Constructs an AWF App. The AWF creates an instance of this class, globally available at awf.app.
	 *
	 * @property {Object.<...string, awf.__.Cog.cogConfig>} registered_cogs Storage for the parameters needed to instantate cogs as needed.
	 * @property {Object.<...string, awf.__.Experience.experienceConfig>} registered_experiences Storage for the parameters needed to instantate experiences as needed.
	 * @property {object} composition An object that will be passed to awf.init when the [start]{@link awf.__.App.start} method is called. Though derived from [appCompConfig]{@link awf.__.App.appCompConfig}, it is not the same thing.
	 * @property {null|awf.__.Experience} experience The current experience instance.
	 * @property {array} potential_experience_seeds An array of objects, each with the data required to produce the leftnav, and intantiate that experience as needed.
	 * @property {array} kinetic_experience_seeds An array of objects, each with the data required to produce the leftnav, and intantiate that experience as needed.
	 */
	function App (params) {

		params = params || {};

		// An object to contain cog instantiation parameters
		this.registered_cogs = {};

		// An object to contain experience instantiation parameters
		this.registered_experiences = {};

		this.composition = {};
		this.composition_handlers = {};

		this.experience = null;
		this.potential_experience_seeds = [];
		this.kinetic_experience_seeds = [];

		this.events = {};

		// App level cogs
		this.cog_types = _.extend([], this.cogs, params.cogs);
		this.cogs = {};
	}



	_.extend(App.prototype, {

		/**
		 * registerCog
		 * @name registerCog
		 * @function
		 * @memberOf awf.__.App
		 * @param {string} id The registered cog type's ID
		 * @param {awf.__.Cog.cogConfig} cog_params The configuration that will _later_ be used to instantiate a new Cog.
		 * @see awf.__.Cog
		 * @return {object} this (chainable)
		 */
		registerCog: function (id, cog_params) {
			if (id in this.registered_cogs)
				throw new Error("Cannot register cog `" + id + "`. Cog registration ids must be unique.");
			console.info('Registering cog: ', id);
			this.registered_cogs[id] = cog_params;

			return this;
		},

		/**
		 * registerExperience
		 * @name registerExperience
		 * @function
		 * @memberOf awf.__.App
		 * @param {string} id The registered experience type's ID
		 * @param {awf.__.Experience.experienceConfig} experience_params The configuration that will _later_ be used to instantiate a new Experience.
		 * @see awf.__.Experience
		 * @return {object} this (chainable)
		 */
		registerExperience: function (id, experience_params) {
			if (id in this.registered_experiences)
				throw new Error("Cannot register experience `" + id + "`. Experience registration ids must be unique.");
			console.info('Registering experience: ', id);
			this.registered_experiences[id] = experience_params;

			return this;
		},

		/**
		 * setCurrentExperience
		 * @name setCurrentExperience
		 * @description Changes the current experience. Looks through this.potential_experience_seeds for the matching ID
		 *
		 * @function
		 * @memberOf awf.__.App
		 *
		 * @param {string} id The id to the desired new current experience.
		 *
		 * @emits change:experience
		 *
		 * @return {object} this (chainable)
		 */
		setCurrentExperience: function (id) {

			var index = _.indexOf(this.kinetic_experience_seeds, _.find(this.kinetic_experience_seeds, 'id', id));

			if (index == -1)
				throw new Error('Cannot load experience "' + id + '" -- an experience seed with that id cannot be found.');

			var seed = this.kinetic_experience_seeds[index];

			if ( ! seed.type)
				throw new Error('Cannot load experience "' + id + '" -- no type was defined.');

			if ( ! this.registered_experiences[seed.type])
				throw new Error('Cannot load experience `' + id + '` -- Its type (' + seed.type + ') is not registered!');

			if (this.experience) {
				this.experience.teardown();
			}

			this.triggerHandler('change', ['experience', index, id]);
			this.triggerHandler('change:experience', [index, id]);

			this.experience = new awf.__.Experience(_.extend({}, this.registered_experiences[seed.type], {
				id: id,
				type: seed.type
			}));
			this.experience.setup();

			return this;
		},



		addCompositionHandler: function (id, handler) {
			if (id in this.composition_handlers) {
				console.warn('Cannot add composition handler `' + id + '` -- This id is already in use.');
			} else {
				this.composition_handlers[id] = handler;
			}
		},


		/**
		 * compose
		 * @name compose
		 * @function
		 * @description Composes the app using the provided config. See the {@tutorial app-comp} tutorial to learn more about configuring the app.
		 * @memberOf awf.__.App
		 *
		 * @param {awf.__.App.appComposeConfig} config The configuration of the application
		 *
		 * @return {object} this
		 */

		compose: function (config) {

			console.groupCollapsed('app composition');

			_.forEach(this.composition_handlers, function (handler, id) {
				console.group(id);
				handler.call(self, config);
				console.groupEnd();
			});

			this.composition = config;
			console.log('App Composition:', this.composition);

			console.groupEnd();

			return this;
		},


		/**
		 * start
		 * @name start
		 * @description Starts the application, expecting compose to have been completed.
		 *
		 * @function
		 * @memberOf awf.__.App
		 *
		 * @return {promise} The promise for when awf.init is complete
		 */

		start: function () {

			return awf.init(this.composition);

		},


		/**
		 * Creates an instance of awf.ui.Message, and displays the message in a dedicated DOM element, `#awf-app-message`.
		 * @param {null|string} type The type of message. Must be null, "error", "warn", "info", or "success".
		 * @param {null|string} message The message to post.
		 * @param {boolean} [show_dismiss=true] If false, the message's dismiss button will be hidden, otherwise it will be shown.
		 * @memberOf awf.__.App
		 * @instance
		 * @see awf.ui.Message
		 *
		 * @return {awf.ui.Message} The awf.ui.Message instance
		 *
		 * @example
		 * // a warning that stays until a user dismisses it
		 * awf.app.postMessage('warn', "Please dismiss me");
		 *
		 * // information that dismisses itself after 5 seconds unless a user dismisses it manually, sooner
		 * awf.app.postMessage('info', "I will go away in 5 seconds, unless you dismiss me sooner than that.").andDismissIn(5);
		 *
		 * // a success message that doesn't have a dismiss button, but will dismiss itself after 3 seconds
		 * awf.app.postMessage('success', "Hello World!", false).andDismissIn(3);
		 */
		postMessage: function (type, message, show_dismiss) {

			var $container = $('#awf-app-message');

			if ($container.length > 0) {
				return awf.util.postMessage($container, type, message, show_dismiss);
			}

			console.warn('The application does not have a message container.');
			return null;
		},




		initializeCogs: function () {

			console.group("initializeCogs()");

			var self = this;

			_.forEach(this.cog_types, function (cog_params) {
				console.log('getOrCreateCog: ', cog_params);
				self.getOrCreateCog(cog_params);
			});

			console.groupEnd();

			return this;
		},




		/**
		 * Return an existing cog instance, or create a new one and return it. Adds it to this.cogs
		 * @memberOf awf.__.App
		 * @instance
		 * @param  {string|object} cog_params If a string, it will used as an object where both id and type are pulled from the string value
		 * @param {string} cog_params.id The id of the cog instance. If this is in use, the function will return the existing instance
		 * @param {string} cog_params.type The type of the cog instance. Must be found among awf.app.registered_cogs AND this.cog_types.
		 * @return {awf.__.Cog}            Either the preexisting cog with the given ID, or a new one based on ID and type
		 */
		getOrCreateCog: function (cog_params) {

			if (typeof(cog_params) == "string") {
				cog_params = {
					id: cog_params, // + '-' + _.filter(this.cogs, 'type', cog_params).length,
					type: cog_params
				};
				console.log('Converting to ', cog_params);
			}

			// Do we have it already? Return it!
			if (this.cogs[cog_params.id]) {
				return this.cogs[cog_params.id];
			}

			// Is this cog type listed against this app?
			if ( ! _.contains(this.cog_types, cog_params.type))
				throw new Error('Cannot create cog of type `' + cog_params.type + '` for app type `' + this.type + '`. Update the app\'s cogs array to include `' + cog_params.type + '`.');

			// (else) Make a new one!

			// Is it a registered type?
			if ( ! (cog_params.type in awf.app.registered_cogs)) {
				throw new Error('Cannot create cog of type `' + cog_params.type + '` -- It has not been registered!');
			}

			// Include the ID with the instantiation parameters
			cog_params = _.extend({}, awf.app.registered_cogs[cog_params.type], {
				id: cog_params.id,
				type: cog_params.type
			});

			// Intantiate it!
			console.group("Initializing cog:", cog_params);
			this.cogs[cog_params.id] = new awf.__.Cog(cog_params);
			console.groupEnd();

			return this.cogs[cog_params.id];
		},


		/**
		 * @memberOf awf.__.App
		 * @instance
		 * @param  {string} id Id of the event to register (must be unique)
		 * @param {appEventConfig} params The parameters of the event to register
		 *
		 * @return {object} this (chainable)
		 */
		registerEvent: function (id, params) {

			if (id in this.events) {
				throw Error('Cannot register event with existing id: `' + id + '`');
			}

			this.events[id] = params;

			return this;
		},

		logExperienceBlockers: function () {
			var self = this,
				experience_dfr = $.when.apply($, _.values(self.experience_blockers));

			console.group('Experience blockers: ' + experience_dfr.state());
			
			var max_len = _.max(_.map(_.keys(self.experience_blockers), 'length'));
			_.forEach(self.experience_blockers, function (dfr, id) {
				console.log(_.padRight(id, max_len+3) + dfr.state() + _.padLeft(dfr.duration(), 10));
			});
			
			console.groupEnd();

			return self;
		}
	});

	/**
	 * @typedef appEventConfig
	 * @memberof awf.__.App
	 * @type Object
	 * @description The appEventConfig object is used to describe the configurable elements of an app event.
	 * @see  awf.util.event
	 *
	 * @property {string|date} start When the event should start. Can be a valid date string or a Date Object.
	 * @property {string|date} end When the event should end. Can be a valid date string or a Date Object.
	 * @property {string} [flag] The event's feature flag, if applicable.
	 * @property {function} callback The callback function for the event.
	 *
	 * @example
	 * // This will register an app event with the appropriate and necessary configuration
	 *
	 * // Once occurred, the event is "claimed" and will no longer occur unless it is
	 * // "unclaimed", or the user clears their local storage
	 *
	 * awf.app.registerEvent('2016-takeover', {
	 *   start: '2016/08/01',
	 *   end: '2016/09/01',
	 *   flag: 'events.takeover',
	 *   callback: function () {
	 *
	 *     console.log("Hello World!");
	 *
	 *   }
	 * });
	 */


/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = Color;

	/**
	 * Converts an rgb string (e.g.: "#f90") to an object (e.g.: {r:255,g:153,b:0}). Inverse of convertRGBValuesToString()
	 * @memberOf awf.__.Color
	 * @param  {String} rgb_string An rgb hexidecimal string. The '#' is optional, and can handle 3 or 6 digits (meaning, "f90" and "ff9900" are the same thing)
	 * @return {Object}            Has properties r, g, and b, each ranging from 0 to 255
	 */
	function convertRGBStringToValues (rgb_string) {
		if (rgb_string.charAt(0) == '#')
			rgb_string = rgb_string.substring(1);

		if (rgb_string.length == 3) {
			rgb_string = rgb_string.charAt(0) + rgb_string.charAt(0) +
						 rgb_string.charAt(1) + rgb_string.charAt(1) +
						 rgb_string.charAt(2) + rgb_string.charAt(2);
		}

		return {
			r: parseInt(rgb_string.substring(0,2), 16),
			g: parseInt(rgb_string.substring(2,4), 16),
			b: parseInt(rgb_string.substring(4,6), 16)
		};
	}


	/**
	 * Returns the luminance value an rgb string (e.g.: "#f90")
	 * @memberOf awf.__.Color
	 * @param  {String} rgb_string An rgb hexidecimal string. The '#' is optional, and can handle 3 or 6 digits (meaning, "f90" and "ff9900" are the same thing)
	 * @return {Number}            Ranges from 0 to 1
	 */
	function luminance (rgb_string)
	{
		var vals = convertRGBStringToValues(rgb_string);

		// vals properties are 0 to 255, they need to be 0 to 1
		vals.r /= 256;
		vals.g /= 256;
		vals.b /= 256;

		// maths from: http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var r = (vals.r <= 0.03928) ? vals.r / 12.92 : Math.pow(((vals.r + 0.055) / 1.055), 2.4),
			g = (vals.g <= 0.03928) ? vals.g / 12.92 : Math.pow(((vals.g + 0.055) / 1.055), 2.4),
			b = (vals.b <= 0.03928) ? vals.b / 12.92 : Math.pow(((vals.b + 0.055) / 1.055), 2.4),
			lum = (0.2126 * r) + (0.7152 * g) + (0.0722 * b);

		return lum;
	}


	/**
	 * Converts an object (e.g.: {r:255,g:153,b:0}) to an rgb string (e.g.: "#f90"). Inverse of convertRGBStringToValues()
	 * @memberOf awf.__.Color
	 * @param  {Object} rgb_values It expects properties r, g, and b, each ranging from 0 to 255.
	 * @return {String}	An rgb hexidecimal string (e.g.: "#FF9900")
	 */
	function convertRGBValuesToString (rgb_values) {
		var r = (rgb_values.r).toString(16),
			g = (rgb_values.g).toString(16),
			b = (rgb_values.b).toString(16);

		if (r.length == 1)
			r = '0' + r;

		if (g.length == 1)
			g = '0' + g;

		if (b.length == 1)
			b = '0' + b;

		return '#'+r+g+b;
	}

	/**
	 * Converts an object with cmyk values to an object with rgb values. Inverse of convertRGBtoCMYK().
	 * @memberOf awf.__.Color
	 * @param  {Object} cmyk_values	It expects properties c, m, y, and k.
	 * @return {Object}             Object that represents the same color, but reflected using properties r, g, and b.
	 */
	function convertCMYKtoRGB (cmyk_values) {
		return {
			r: Math.round(Math.max(0, Math.min(255, 255 * (1 - cmyk_values.c) * (1 - cmyk_values.k)))),
			g: Math.round(Math.max(0, Math.min(255, 255 * (1 - cmyk_values.m) * (1 - cmyk_values.k)))),
			b: Math.round(Math.max(0, Math.min(255, 255 * (1 - cmyk_values.y) * (1 - cmyk_values.k))))
		};
	}

	/**
	 * Converts an object with rgb values to an object with cmyk values. Inverse of convertCMYKtoRGB().
	 * @memberOf awf.__.Color
	 * @param  {Object} rgb_values	It expects properties r, g, and b.
	 * @return {Object}             Object that represents the same color, but reflected using properties c, m, y, and k.
	 */
	function convertRGBtoCMYK (rgb_values) {
		if (typeof(rgb_values) == "string")
			rgb_values = convertRGBStringToValues(rgb_values);

		var r = rgb_values.r / 255,
			g = rgb_values.g / 255,
			b = rgb_values.b / 255,
			k = 1 - Math.max(r, g, b),
			c, m, y;

		if (k == 1)
		{
			c = 0;
			m = 0;
			y = 0;
		} else {
			c = (1 - r - k) / (1 - k);
			m = (1 - g - k) / (1 - k);
			y = (1 - b - k) / (1 - k);
		}

		return {
			c: c,
			m: m,
			y: y,
			k: k
		};
	}





	/**
	 * An Object definition for storing, inspecting, and manipulating colors.
	 * @class
	 * @memberOf awf.__
	 * @param {String|Object} rgb The original color to start. Can be an rgb string ("#0000"), rgb value ({r:0,g:0,b:0}), or cmyk value ({c:0,m:0,y:0,k:0})
	 */
	function Color (rgb) {

		var self = this,
			the_color = null;

		if (typeof(rgb) == "string") {
			the_color = convertRGBValuesToString(convertRGBStringToValues(rgb));
		} else if (typeof(rgb) == "object") {
			if (typeof(rgb.r) !== "undefined") {
				the_color = convertRGBValuesToString(rgb);
			} else {
				the_color = convertRGBValuesToString(convertCMYKtoRGB(rgb));
			}
		}

		/**
		 * The red value
		 * @property {Number} r The value of red, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'r', {
			emumerable: true,
			get: function () {
				return self.rgbValues().r;
			},
			set: function (new_value) {
				var values = convertRGBStringToValues(the_color);
				values.r = Math.round(Math.max(0, Math.min(255, new_value)));
				the_color = convertRGBValuesToString(values);
			}
		});


		/**
		 * The green value
		 * @property {Number} g The value of green, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'g', {
			emumerable: true,
			get: function () {
				return self.rgbValues().g;
			},
			set: function (new_value) {
				var values = convertRGBStringToValues(the_color);
				values.g = Math.round(Math.max(0, Math.min(255, new_value)));
				the_color = convertRGBValuesToString(values);
			}
		});

		/**
		 * The blue value
		 * @property {Number} b The value of blue, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'b', {
			emumerable: true,
			get: function () {
				return self.rgbValues().b;
			},
			set: function (new_value) {
				var values = convertRGBStringToValues(the_color);
				values.b = Math.round(Math.max(0, Math.min(255, new_value)));
				the_color = convertRGBValuesToString(values);
			}
		});


		/**
		 * The cyan value
		 * @property {Number} r The value of cyan, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'c', {
			emumerable: true,
			get: function () {
				return self.cmykValues().c;
			},
			set: function (new_value) {
				var cmyk_values = convertRGBtoCMYK(the_color);
				cmyk_values.c = Math.max(0, Math.min(1, new_value));
				rgb_values = convertCMYKtoRGB(cmyk_values);
				the_color = convertRGBValuesToString(rgb_values);
			}
		});


		/**
		 * The magenta value
		 * @property {Number} m The value of magenta, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'm', {
			emumerable: true,
			get: function () {
				return self.cmykValues().m;
			},
			set: function (new_value) {
				var cmyk_values = convertRGBtoCMYK(the_color);
				cmyk_values.m = Math.max(0, Math.min(1, new_value));
				rgb_values = convertCMYKtoRGB(cmyk_values);
				the_color = convertRGBValuesToString(rgb_values);
			}
		});


		/**
		 * The yellow value
		 * @property {Number} y The value of yellow, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'y', {
			emumerable: true,
			get: function () {
				return self.cmykValues().y;
			},
			set: function (new_value) {
				var cmyk_values = convertRGBtoCMYK(the_color);
				cmyk_values.y = Math.max(0, Math.min(1, new_value));
				rgb_values = convertCMYKtoRGB(cmyk_values);
				the_color = convertRGBValuesToString(rgb_values);
			}
		});


		/**
		 * The black value
		 * @property {Number} k The value of black, ranging from 0 to 255
		 */
		Object.defineProperty(this, 'k', {
			emumerable: true,
			get: function () {
				return self.cmykValues().k;
			},
			set: function (new_value) {
				var cmyk_values = convertRGBtoCMYK(the_color);
				cmyk_values.k = Math.max(0, Math.min(1, new_value));
				rgb_values = convertCMYKtoRGB(cmyk_values);
				the_color = convertRGBValuesToString(rgb_values);
			}
		});

		/**
		 * The luminance value - this one cannot be set
		 * @property {Number} luminance Ranges from 0 to 1
		 */
		Object.defineProperty(this, "luminance", {
			get: function () {
				return luminance(the_color);
			},
			set: function () {
				console.warn("luminance cannot be set; it is a read only value");
			}
		});

		/**
		 * Compares itself with the given color and returns the contrast ratio (ranges from 1 to 21)
		 * @param  {String|Object} Can be another instance of Color, an rgb string ("#0000"), rgb value ({r:0,g:0,b:0}), or cmyk value ({c:0,m:0,y:0,k:0})
		 * @return {Number}             The contrast ratio between this color and the one passed in. Ranges from 1 to 21.
		 */
		this.contrastRatio = function (other_color) {
			if ( ! (other_color instanceof Color))
				other_color = new Color(other_color);

			var l1 = self.luminance,
				l2 = other_color.luminance;

			if (l1 > l2)
				return (l1 + 0.05) / (l2 + 0.05);
			else
				return (l2 + 0.05) / (l1 + 0.05);
		};

		/**
		 * Returns the '#' hexidecimal string of the color
		 * @return {String} the '#' hexidecimal string of the color
		 */
		this.toString = function () {
			return the_color;
		};

		/**
		 * Returns an object that represents this color with properties r, g, and b.
		 * @return {Object} Represents this color with properties r, g, and b.
		 */
		this.rgbValues = function () {
			return convertRGBStringToValues(the_color);
		};

		/**
		 * Returns an object that represents this color with properties c, m, y, and k.
		 * @return {Object} Represents this color with properties c, m, y, and k.
		 */
		this.cmykValues = function () {
			return convertRGBtoCMYK(the_color);
		};

		/**
		 * Logs a group of all the values, so you can see them at a glance.
		 */
		this.logSummary = function () {
			console.group(self.toString());
			console.log("luminance: ", self.luminance);
			console.log("     cmyk: ", self.cmykValues());
			console.log("      rgb: ", self.rgbValues());
			console.groupEnd();
		};


		/**
		 * The yiq value - this one cannot be set
		 * @author Jason Horwitz
		 * @property {Number} yiq Ranges from 0 to 1
		 */
		Object.defineProperty(this, "yiq", {
			enumberable: true,
			get: function () {
				var rgb_values = convertRGBStringToValues(the_color);
				return ((rgb_values.r * 299) + (rgb_values.g * 587) + (rgb_values.b * 114)) / 1000;
			},
			set: function () {
				console.warn("yiq cannot be set; it is a read only value");
			}
		});


		/**
		 * Returns true if the yiq value is less than the passed parameter (between 0 and 255), or 128 if left undefined
		 * @author Jason Horwitz
		 * @param  {Number}  compare_to The YIQ value to check against. If left undefined, 128 will be assigned automatically
		 * @return {Boolean}            If the color is considered "dark": true, otherwise false
		 */
		this.isDark = function (compare_to) {
			if (typeof(compare_to) == "undefined")
				compare_to = 128;

			return this.yiq < compare_to;
		};


		this.isValid = function () {
			if (isNaN(this.b) || isNaN(this.c) || isNaN(this.g) || isNaN(this.k) || isNaN(this.m) || isNaN(this.r) || isNaN(this.y))
				return false;
			return true;
		};
	}


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = BaseModel;


	var BaseObject = awf.__.BaseObject,
		use = __webpack_require__(21);

	use(BaseObject).toCreate(BaseModel);

	/**
	 * BaseModel
	 * @class
	 * @extends {awf.__.BaseObject}
	 * @memberOf awf.__
	 */
	function BaseModel () {
		BaseObject.apply(this, arguments);
	}


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = CustomWorker;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	/*	CustomWorker Class
	------------------------------------------*/
		awf.util.use(awf.__.BaseModel).toCreate(CustomWorker);

		/**
		 * Custom Worker
		 * @class
		 * @memberOf awf.__
		 * @augments {awf.__.BaseModel}
		 * @param {Function} fn The script to hand off to a web worker
		 *
		 * @property {string} script The stringified version of `fn`
		 * @property {Worker} worker The instance of the web worker
		 * @property {function} worker.onmessage The function that handles incoming messages from the web worker
		 * @property {object} drfs For internal use -- An object with all pending responses.
		 */
		function CustomWorker (fn) {

			if (fn === undefined) {
				throw new Error('Cannot create CustomWorker without a script.');
			}

			var self = this;
			
			// Pull the script out of the function
			this.script = fn.toString();
			this.script = this.script.substring(this.script.indexOf('{') + 1);
			this.script = this.script.substring(0, this.script.lastIndexOf('}'));

			var blob = new Blob([this.script]),
				blobURL = window.URL.createObjectURL(blob);
			
			this.worker = new Worker(blobURL);

			this.dfrs = {};

			awf.__.BaseModel.call(self);

			this.worker.onmessage = function (e) {
				switch (e.data.ev) {
					case "resolve":
						self.dfrs[e.data.id].resolve(e.data.response);
						delete self.dfrs[e.data.id];
						break;

					case "reject":
						self.dfrs[e.data.id].reject(e.data.er);
						delete self.dfrs[e.data.id];
						break;
				}
			};
		}


	_.extend(CustomWorker.prototype, {

		/**
		 * Shortcut to post messages to the worker -- limited to one argument
		 * @memberOf awf.__.CustomWorker
		 * @instance
		 * @param  {string|number|object|null|undefined} obj The object to pass to the web worker. Can be anything stringifiable.
		 * @return {object}     The object from postMessage
		 */
		post: function (obj) {
			return this.worker.postMessage(obj);
		},


		/**
		 * @typedef IdentifiedDeferred
		 * @type Object
		 * @property {string} id The id of the Deferred, to be used as a key in dfrs
		 * @property {Deferred} dfr The Deferred object
		 */


		/**
		 * Creates a deferred object and stores it in dfrs by random ID.
		 * @memberOf awf.__.CustomWorker
		 * @instance
		 * @return {IdentifiedDeferred} The newly created object
		 */
		createPromise: function () {
			var id = awf.util.randomID();

			this.dfrs[id] = $.Deferred();

			return {
				id: id,
				dfr: this.dfrs[id]
			};
		}

	});


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = LocalSearchWorker;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	function LocalSearchWorker (params) {

		params = params || {};

		this.custom_worker = new awf.__.CustomWorker(function () {




			/*  ----------------------------------------------  SCOPE REMINDER  -----------------------------------------------  */
			/*                                                                                                                   */
			/*  Welcome to the land of Plain Old Javascript.                                                                     */
			/*  There is no jQuery. There is no Lodash. There is no AWF.                                                         */
			/*  This is a web worker script.                                                                                     */
			/*  It is stringified and passed as a Blob.                                                                          */
			/*  Nothing exists here unless it is specifically loaded or passed in.                                               */
			/*  Think of this script as a standalone script that is (nearly) completely cut off from the rest of the code.       */
			/*                                                                                                                   */
			/*  `onmessage` is how this script is able to listen to the parent                                                   */
			/*  `postMessage` is how this script is able to talk to the parent                                                   */
			/*  `self` is a reserved word, similar to `window`                                                                   */
			/*                                                                                                                   */
			/*  For more information, visit: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers  */
			/*                                                                                                                   */
			/*  ---------------------------------------------------------------------------------------------------------------  */


			// `self` is reserved in this scope. Using `me` instead
			var me = this;

			me.data = null;

			/*function pause (seconds) {
				var target = new Date();
				target.setTime(target.getTime() + (1000 * seconds));
				while (new Date() < target);
			}*/

			this.onmessage = function (e) {

				//console.log('LocalSearchWorker\'s worker got a message: ', e);

				var edata = e.data;

				switch (edata.ev) {

					case "set-data":
						//console.log('set-data has been called');
						me.data = edata.data;
						self.postMessage({
							ev: 'resolve',
							id: edata.id,
							response: 'data received'
						});
						break;

					case "query":
						if (me.data === null) {
							self.postMessage({
								ev: 'reject',
								id: edata.id,
								er: 'no data'
							});
							return false;
						}

						var responses = {
								0: [],
								1: [],
								2: [],
								3: [],
								4: []
							};

						term = edata.term.toLowerCase();

						for (var i = 0; i < me.data.length; i++) {
							var item = me.data[i],
								lower_title = item.data.title.toLowerCase(),
								title_index = lower_title.indexOf(term),
								lower_description = item.data.description.toLowerCase(),
								description_index = lower_description.indexOf(term);


							if (title_index === 0) {
								item.rank = 0;
								responses[0].push(item);
							} else if (title_index > 0) {
								item.rank = 1;
								responses[1].push(item);
							} else if (description_index === 0) {
								item.rank = 2;
								responses[2].push(item);
							} else if (description_index > 0) {
								item.rank = 3;
								responses[3].push(item);
							} else {
								if (item.data.tags) {
									var tag_found = false;
									for (var j = 0; j < item.data.tags.length; j++) {
										if (term == item.data.tags[j])
											tag_found = true;
									}
									if (tag_found) {
										item.rank = 4;
										responses[4].push(item);
									}
								}
							}
						}

						var response = responses[0].concat(responses[1],responses[2],responses[3],responses[4]);

						// (pause for effect)
						//pause(Math.ceil(Math.random() * 3));

						self.postMessage({
							ev: 'resolve',
							id: edata.id,
							response: response
						});

						break;
				}

			};

		});

		if (params.data) {
			this.setData(params.data);
		}

	}

	_.extend(LocalSearchWorker.prototype, {

		setData: function (data) {
			var p = this.custom_worker.createPromise();

			this.custom_worker.post({
				ev: 'set-data',
				id: p.id,
				data: data
			});

			return p.dfr.promise();
		},

		query: function (term) {
			var p = this.custom_worker.createPromise();

			this.custom_worker.post({
				ev: 'query',
				id: p.id,
				term: term
			});

			return p.dfr.promise();
		}

	});


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = DeferredCache;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	awf.util.use(awf.__.BaseModel).toCreate(DeferredCache);

	/**
	 * @class
	 * @extends {awf.__.BaseModel}
	 *
	 * @param {object}		params
	 * @param {string}		[params.key]		The local storage key
	 * @param {null|string}	[params.date]		The date when the last fetch was made
	 * @param {null|object}	[params.response]	The data from the last fetch's response
	 * @param {null|number}	[params.duration]	The duration (milliseconds) that the last fetch took to respond

	 * @property {string}		key				The local storage key
	 * @property {null|string}	date=null		The date when the last fetch was made
	 * @property {null|object}	response=null	The data from the last fetch's response
	 * @property {null|number}	duration=null	The duration (milliseconds) that the last fetch took to respond
	 *
	 */
	function DeferredCache (params) {

		params = params || {};

		var self = this;

		awf.__.BaseModel.apply(this, arguments);

		this.dfr = null;

		awf.util.mixin.properties(this, params, {

			/**
			 * @name setKey
			 * @memberof awf.__.DeferredCache
			 * @function
			 * @instance
			 * @param {string} val Sets the new value for `key`
			 * @fires change:key
			 * @return {object} self chainable
			 */
			key: {
			    "default": '',
			    "types": [
			        "string"
			    ],
			    handler: function (new_val, old_val) {
			    	// console.log('new_val: ', new_val);
			    	// console.log('old_val: ', old_val);
			    	if (old_val) {
				    	awf.util.setStoredObject(new_val, awf.util.getStoredObject(old_val));
				    	localStorage.removeItem(old_val);
				    }
			    }
			}
		});


		var data = awf.util.getStoredObject(self.key) || {};

		awf.util.mixin.properties(this, _.defaults(params, data), {
			/**
			 * @name setDate
			 * @memberof awf.__.DeferredCache
			 * @function
			 * @instance
			 * @param {null|date} val=null Sets the new value for `date`
			 * @fires change:date
			 * @return {object} self chainable
			 */
			date: {
			    "default": null,
			    "types": [
			        "null",
			        "date"
			    ],
			    handler: function (val) {
			    	var data = awf.util.getStoredObject(self.key) || {};
			    	data.date = val;
			    	awf.util.setStoredObject(self.key, data);
			    }
			},


			/**
			 * @name setResponse
			 * @memberof awf.__.DeferredCache
			 * @function
			 * @instance
			 * @param {null|object} val=null Sets the new value for `response`
			 * @fires change:response
			 * @return {object} self chainable
			 */
			response: {
			    "default": null,
			    "types": [
			        "null",
			        "object"
			    ],
			    handler: function (val) {
			    	var data = awf.util.getStoredObject(self.key) || {};
			    	data.response = val;
			    	awf.util.setStoredObject(self.key, data);
			    	var dfr = $.Deferred();
			    	if (val) {
				    	switch (val.state) {
				    		case 'resolved':
				    			dfr.resolve(val.data);
				    			break;

				    		case 'rejected':
				    			dfr.reject(val.er);
				    			break;
				    	}
				    }
			    	this.dfr = dfr;
			    }
			},


			/**
			 * @name setDuration
			 * @memberof awf.__.DeferredCache
			 * @function
			 * @instance
			 * @param {null|number} val=null Sets the new value for `duration`
			 * @fires change:duration
			 * @return {object} self chainable
			 */
			duration: {
			    "default": null,
			    "types": [
			        "null",
			        "number"
			    ],
			    handler: function (val) {
			    	var data = awf.util.getStoredObject(self.key) || {};
			    	data.duration = val;
			    	awf.util.setStoredObject(self.key, data);
			    }
			}

		});

	}



	_.extend(DeferredCache.prototype, {

		setResolution: function (response) {
			return this.setResponse({
				state: 'resolved',
				data: response
			});
		},

		setRejection: function (er) {
			return this.setResponse({
				state: 'rejected',
				er: er
			});
		}

	});




/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Service;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4);

	awf.util.use(awf.__.BaseModel).toCreate(Service);

	/**
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseModel}
	 *
	 * @description A pattern for services. Why use this? You get events, ability to fetch with cache age limits, and metrics on request times for free.
	 * @param {object}		params
	 * @param {function}	params.onFetch	When a new request (aka, age_limit did not intervene) this method will be called. Usually, the actual $.ajax() call will need to be made here.
	 * @param {null|string} [params.local_storage_key] If set, it will use this as a localStorage key to store responses.
	 *
	 * @property {null|$.Deferred}	last_fetch_dfr			The $.Deferred object from the last fetch call that was not intervene by age_limit
	 * @property {null|Date}		last_fetch_date			A date object for when the last fetch _started_
	 * @property {null|number}		last_fetch_duration		The number of milliseconds that the last fetch took to complete (either resolved or rejected)
	 * @property {null|function}	onFetch					May be set by params.onFetch -- When a new request (aka, age_limit did not intervene) this method will be called. Usually, the actual $.ajax() call will need to be made here.
	 *
	 * @example
	 * var service = new awf.__.Service({
	 * 	onFetch: function (dfr) {
	 * 		$.ajax('foobar.com')
	 * 			.done(dfr.resolve)
	 * 			.fail(dfr.reject);
	 * 	}
	 * });
	 *
	 * @example
	 * // map the values before resolving the promise
	 * var service = new awf.__.Service({
	 * 	onFetch: function (dfr) {
	 * 		$.ajax('foobar.com')
	 * 			.done(function (response) {
	 * 				dfr.resolve(_.map(response, 'properties'));
	 * 			})
	 * 			.fail(dfr.reject);
	 * 	}
	 * });
	 *
	 *
	 *
	 * @example
	 * // Resolve the first properties object value
	 * // And treat a 404 like it's actually a successful return with no data.
	 * // (this is what the construct service does, and this Service example catches this and turns failure into a meaningful success)
	 * var service = new awf.__.Service({
	 * 	onFetch: function (dfr) {
	 * 		$.ajax('foobar.com')
	 * 			.done(function (response) {
	 * 				dfr.resolve(response.properties[0].value));
	 * 			})
	 * 			.fail(function (er) {
	 * 				if (er.status == 404) {
	 * 					dfr.resolve(null);
	 * 				} else {
	 * 					dfr.reject(er);
	 * 				}
	 * 			});
	 * 	}
	 * });
	 *
	 */
	function Service (params) {

		params = params || {};

		var self = this;

		this._last_fetch_params = null;

		if ( ! ('cache' in params)) {
			params.cache = true;
		}

		this.cache = params.cache;

		this.local_storage_key = params.local_storage_key || this.local_storage_key || null;
		
		this._fetch_dfrs = {};
		this._fetch_dates = {};
		this._fetch_durations = {};


		if (this.local_storage_key) {

			this.dfr_cache = new awf.__.DeferredCache({
				key: self.local_storage_key
			});

			if (this.dfr_cache.response) {
				var dfr = $.Deferred(),
					ls_dfr = this.dfr_cache.response;
				
				if (ls_dfr.state == 'resolved') {
					dfr.resolve(ls_dfr.data);
				} else if (ls_dfr.state == 'rejected') {
					dfr.reject(ls_dfr.er);
				}
				self._fetch_dfrs[self.local_storage_key] = dfr;
			}

			/*var start = self.local_storage_key + ':dfr:';
			_.forEach(Object.keys(localStorage), function (key) {
				if (key.indexOf(start) === 0) {
					var dfr = $.Deferred(),
						ls_dfr = awf.util.getStoredObject(key);
					
					if (ls_dfr.state == 'resolved') {
						dfr.resolve(ls_dfr.data);
					} else if (ls_dfr.state == 'rejected') {
						dfr.reject(ls_dfr.er);
					}
					self._fetch_dfrs[key.substring(start.length)] = dfr;
				}
			});*/
		}


		this._lazy_dfr = $.Deferred();
		this._lazy_dfr_needs_reset = false;


		/*	this.last_fetch
		------------------------------------------*/
			Object.defineProperty(this, 'last_fetch_dfr', {
				enumerable: true,
				get: function () {
					return self._fetch_dfrs[self._last_fetch_params || '{}'];
				},
				set: function (val) {
					if (self.dfr_cache) {
						val
							.done(function (response) {
								self.dfr_cache.setResolution(response);
							})
							.fail(function (er) {
								self.dfr_cache.setRejection(er);
							});
					}
					self._fetch_dfrs[self._last_fetch_params || '{}'] = val;
				}
			});


		/*	this.last_fetch_date
		------------------------------------------*/
			Object.defineProperty(this, 'last_fetch_date', {
				enumerable: true,
				get: function () {
					if (self.dfr_cache) {
						return self.dfr_cache.date;
					} else {
						return self._fetch_dates[self._last_fetch_params || '{}'];
					}
				},
				set: function (val) {
					if (self.dfr_cache) {
						self.dfr_cache.setDate(val);
					} else {
						self._fetch_dates[self._last_fetch_params || '{}'] = val;
					}
				}
			});


		/*	this.last_fetch_duration
		------------------------------------------*/
			Object.defineProperty(this, 'last_fetch_duration', {
				enumerable: true,
				get: function () {
					if (self.dfr_cache) {
						return self.dfr_cache.duration;
					} else {
						return self._fetch_durations[self._last_fetch_params || '{}'];
					}
				},
				set: function (val) {
					if (self.dfr_cache) {
						self.dfr_cache.setDuration(val);
					} else {
						self._fetch_durations[self._last_fetch_params || '{}'] = val;
					}
				}
			});


		this.onFetch = params.onFetch || this.onFetch || null;

	}

	_.extend(Service.prototype, {

		/**
		 * @description Fetches data by calling the provided onFetch method, and stores the last promise, start date, and duration.
		 * @memberOf awf.__.Service
		 * @instance
		 * @param  {number} [age_limit] If undefined, a new request is made, regardless of cache. If `-1`, cache will always be used (otherwise a new request is made), If > -1, and if the previous fetch occurred less than `age_limit` milliseconds, the last fetch promise is immediately returned without making a new request.
		 * @param {object} [params] Used when unique data is needed for each fetch call
		 * @return {$.Deferred}         A promise that will resolve/reject according to the onFetch method
		 *
		 * @example
		 * // this will make a new request, regardless of previous cache
		 * service.fetch();
		 *
		 * @example
		 * // If this is the first fetch, OR the last fetch was made MORE THAN a minute ago, a new request will be made.
		 * // Otherwise, the Deferred object from the last fetch will be returned immediately as if the request had completed instantly, but does NOT actually make the new request.
		 * service.fetch(60 * 1000);
		 */
		fetch: function (age_limit, params) {

			params = params || {};

			var self = this;

			this._last_fetch_params = JSON.stringify(params);

			this.triggerHandler('fetch:start');

			/*	Are we within the age limit? Send it back immediately!
			------------------------------------------*/
				if (self.last_fetch_dfr && age_limit !== undefined && self.last_fetch_date !== undefined && (age_limit === -1 || ((new Date()) - self.last_fetch_date) < age_limit)) {
					this.triggerHandler('fetch:start:cached');
					self.triggerHandler('fetch:complete:cached', [self.last_fetch_dfr, self.last_fetch_duration]);
					return self.last_fetch_dfr.promise();
				}


			/*	We're doing a new fetch -- prep the `last` properties
			------------------------------------------*/
				self.last_fetch_dfr       = $.Deferred();
				self.last_fetch_date      = new Date();
				self.last_fetch_duration  = null;


			/*	Lazy fetch setup
			------------------------------------------*/
				if (self._lazy_dfr_needs_reset) {
					self._lazy_dfr = $.Deferred();
				}
				self._lazy_dfr_needs_reset = true;



			/*	Connect the metrics capture and event handling
			------------------------------------------*/
				self.last_fetch_dfr
					.done(function (response) {
						self.last_fetch_duration = new Date() - self.last_fetch_date;
						self.triggerHandler('fetch:done', [response, self.last_fetch_duration]);
					})
					.fail(function (er) {
						self.last_fetch_duration = new Date() - self.last_fetch_date;
						self.triggerHandler('fetch:fail', [er, self.last_fetch_duration]);
					})
					.always(function () {
						self.triggerHandler('fetch:complete', [self.last_fetch_dfr, self.last_fetch_duration]);
						self.triggerHandler('fetch:complete:new', [self.last_fetch_dfr, self.last_fetch_duration]);
					});


			this.triggerHandler('fetch:start:new', self.last_fetch_date);

			/*	Call the provided onFetch method
			------------------------------------------*/
				if (this.onFetch) {
					this.onFetch.call(this, self.last_fetch_dfr, params);
				}


			/*	Lazy bums go last!
			------------------------------------------*/
				self.last_fetch_dfr
					.done(self._lazy_dfr.resolve)
					.fail(self._lazy_dfr.reject);


			return self.last_fetch_dfr.promise();
		},


		/**
		 * @memberOf awf.__.Service
		 * @instance
		 * @return {$.Deferred} A promise that will resolve immediately if fetch has already returned something, OR it will be resolved/rejected with the next one
		 */
		lazyFetch: function () {
			return this._lazy_dfr.promise();
		}

	});


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = CallbackService;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
		Parent = awf.__.Service;

	awf.util.use(Parent).toCreate(CallbackService);

	function CallbackService (params) {
		params = params || {};
		this.url = params.url || this.url || null;
		this.data = params.data || this.data || null;

		this.ajax_params = _.defaults(params, {
				jsonp: "callback",
				dataType: "jsonp"
			});

		Parent.apply(this, arguments);
	}

	_.extend(CallbackService.prototype, {

		onFetch: function (dfr) {
			$.ajax(this.ajax_params)
			.done(dfr.resolve)
			.fail(dfr.reject);
		}

	});


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = AjaxService;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
		Parent = awf.__.Service;

	awf.util.use(Parent).toCreate(AjaxService);

	function AjaxService (params) {
		params = params || {};
		this.ajax_params = params;

		Parent.call(this);
	}

	_.extend(AjaxService.prototype, {

		onFetch: function (dfr) {
			$.ajax(this.ajax_params)
				.done(dfr.resolve)
				.fail(dfr.reject);
		}

	});


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = SaveableService;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
		Parent = awf.__.Service;

	awf.util.use(Parent).toCreate(SaveableService);

	/**
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.Service}
	 *
	 * @param {object}		params
	 * @param {function}	params.onSave	A function to define what to do when save is called.
	 *
	 * @property {null|$.Deferred}	last_save_dfr		The $.Deferred object from the last save call that was not intervene by age_limit
	 * @property {null|Date}		last_save_date		A date object for when the last save _started_
	 * @property {null|number}		last_save_duration	The number of milliseconds that the last save took to complete (either resolved or rejected)
	 * @property {null|function}	onSave				May be set by params.onSave
	 * 
	 */
	function SaveableService (params) {
		params = params || {};
		Parent.apply(this, arguments);
		
		this.onSave = params.onSave || this.onSave || null;
		this.last_save_dfr = null;
		this.last_save_date = null;
		this.last_save_duration = null;

		if ( ! this.onSave) {
			throw new Error('Cannot create SaveableService without an onSave function');
		}
	}

	_.extend(SaveableService.prototype, {

		/**
		 * @description Saves data by calling the provided onSave method, and stores the last promise, start date, and duration.
		 * @memberOf awf.__.SaveableService
		 * @instance
		 * @param {null|string|number|array|object} [data] Used when unique data is needed for each save call
		 * @return {$.Deferred}         A promise that will resolve/reject according to the onSave method
		 */
		save: function (data) {
			var self = this;
			
			this.last_save_dfr = $.Deferred();

			this.last_save_date = new Date();
			this.last_save_duration = null;
			this.triggerHandler('save:start');

			this.last_save_dfr
				.done(function (response) {
					self.last_save_duration = new Date() - self.last_save_date;
					self.triggerHandler('save:done', [response, self.last_save_duration]);
				})
				.fail(function (er) {
					self.last_save_duration = new Date() - self.last_save_date;
					self.triggerHandler('save:fail', [er, self.last_save_duration]);
				});

			if (this.onSave) {
				this.onSave.call(this, this.last_save_dfr, data);
			}

			return this.last_save_dfr.promise();
		}

	});


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = LocalStorageService;

	var _ = __webpack_require__(5),
		$ = __webpack_require__(4),
		Parent = awf.__.SaveableService;

	awf.util.use(Parent).toCreate(LocalStorageService);

	function LocalStorageService (params) {
		params = params || {};
		this.key = params.key || this.key || null;

		Parent.apply(this, arguments);

		/*	properties
		------------------------------------------*/
			awf.util.mixin.properties(this, params, {
				value: {
					default: null,
					types: ['null','string','number','object','array']
				}
			});
	}

	_.extend(LocalStorageService.prototype, {

		onFetch: function (dfr) {
			if (this.key) {
				var val = localStorage.getItem(this.key);
				setTimeout(function () {
					dfr.resolve(val);
				}, this.fetch_timeout || 0);
			} else {
				dfr.reject('no key');
			}
		},

		onSave: function (dfr) {
			var self = this;

			if (this.key) {
				var is_valid = true,
					val = null;
				
				try {
					if (_.isObject(self.value)) {
						val = JSON.stringify(self.value);
					} else {
						val = self.value;
					}
				} catch (er) {
					dfr.reject('cannot stringify value');
					is_valid = false;
				}
				
				if (is_valid) {
					var key = this.key;
					setTimeout(function () {
						localStorage.setItem(key, val);
						dfr.resolve({success:true});
					}, this.save_timeout || 0);
				}
			} else {
				dfr.reject('no key');
			}
		}

	});


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ConstructServiceItem;

	/*	Requirements
	------------------------------------------*/
		var $ = __webpack_require__(4),
			_ = __webpack_require__(5);


	/*	Constructor
	------------------------------------------*/
		awf.util.use(awf.__.BaseModel).toCreate(ConstructServiceItem);

		/**
		 * @class
		 * @memberOf awf.__
		 * @extends {awf.__.BaseModel}
		 * 
		 * @param {object}		params
		 * @param {string}		params.key		The key for this item
		 * @param {string}		params.endpoint	The construct service endpoint
		 * @param {string}		params.appid	The application ID -- If using app composition, this will match awf.app.id
		 * @param {null|string}	params.value	The value of this item
		 *
		 * @property {string}					key			(readonly) The key for this item
		 * @property {string}					endpoint	(readonly) The construct service endpoint
		 * @property {string}					appid		(readonly) The application ID
		 * @property {awf.__.SaveableService}	service 	A service that will communicate with the construct service on a per-item level
		 * @property {null|string}				value		The value of this item
		 *
		 */
		function ConstructServiceItem (params) {
			var self = this;

			params = params || {};

			this.owner = params.owner || this.owner || null;

			awf.__.BaseModel.apply(this, arguments);

			/*	key
			------------------------------------------*/
				if ( ! ('key' in params)) {
					throw new Error('Cannot create ConstructServiceItem without a key');
				}

				var key = params.key;
				Object.defineProperty(this, 'key', {
					enumerable: true,
					set: function () {
						console.warn('`key` is a readonly property');
					},
					get: function () {
						return key;
					}
				});


			/*	appid
			------------------------------------------*/
				if ( ! ('appid' in params)) {
					throw new Error('Cannot create ConstructServiceItem without an appid');
				}

				var appid = params.appid;
				Object.defineProperty(this, 'appid', {
					enumerable: true,
					set: function () {
						console.warn('`appid` is a readonly property');
					},
					get: function () {
						return self.owner ? self.owner.appid : appid;
					}
				});


			/*	endpoint
			------------------------------------------*/
				if ( ! ('endpoint' in params)) {
					throw new Error('Cannot create ConstructServiceItem without an endpoint');
				}

				var endpoint = params.endpoint;
				if (endpoint) {
					if (endpoint.charAt(endpoint.length - 1) != '/') {
						endpoint += '/';
					}
				}

				Object.defineProperty(this, 'endpoint', {
					enumerable: true,
					set: function () {
						console.warn('`endpoint` is a readonly property');
					},
					get: function () {
					return self.owner ? self.owner.endpoint : endpoint;
					}
				});


			/*	service
			------------------------------------------*/
				this.service = new awf.__.SaveableService({
					local_storage_key: params.local_storage_key,
					onFetch: function (dfr) {

						function fetch (delayed) {

							console.time('cs fetch: ' + self.key);
							dfr.always(function () {
								console.timeEnd('cs fetch: ' + self.key);
							});

							if (self.owner && delayed) {
								dfr.resolve(self.value);
							} else {

								$.ajax({
										url: self.endpoint + self.appid + '/' + self.key + '/',
										xhrFields: {
											withCredentials: true
										},
										contentType: "application/json",
										method: "GET"
									})
									.done(function (response) {
										var val = ConstructServiceItem.parseRawValue(response.properties[0].value);
										self.setValue(val);
										dfr.resolve(val);
									})
									.fail(function (er) {
										if (er.status == 404) {
											self.setValue(null);
											dfr.resolve(null);
										} else {
											dfr.reject(er);
										}
									});
							}
						}

						if (self.owner) {
							self.owner.ready.done(function() {
								fetch(true);
							});
						} else {
							fetch(false);
						}
					},
					onSave: function (dfr) {
						var data;

						try {
							var escaped_val = self.value;
							if (typeof(escaped_val) == "object") {
								escaped_val = JSON.stringify(escaped_val);
							}
							escaped_val = _.escape(escaped_val);

							data = JSON.stringify({
								key: self.key,
								value: escaped_val
							});
						} catch (er) {
							dfr.reject(er);
							return false;
						}

						function save () {
							$.ajax({
									url: self.endpoint + self.appid + '/',
									xhrFields: {
										withCredentials: true
									},
									contentType: "application/json",
									method: "PUT",
									data: data
								})
								.done(function (response) {
									var val = response.properties[0].value;
									dfr.resolve(val, key);
								})
								.fail(function (er) {
									dfr.reject(er);
								});
						}

						if (self.owner) {
							self.owner.ready.done(save);
						} else {
							save();
						}
					}
				});


			/*	properties
			------------------------------------------*/
				awf.util.mixin.properties(this, params, {
					/**
					 * Sets the value for this item. NOTE: This does *not* automatically update the construct service. You must call save() to do that.
					 * @name setValue
					 * @function
					 * @memberOf awf.__.ConstructServiceItem
					 * @instance
					 * @param  {null|string|number|array|object}	val		The new value
					 * @return {object} this (chainable)
					 *
					 * @example
					 * // sets the value to 'foo' -- does NOT update the construct service
					 * item.setValue('foo');
					 *
					 * // sets the value to 'bar' and updates the construct service
					 * item.setValue('bar').save();
					 */
					value: {
						default: null,
						types: ['null','string','number','object','array']
					}
				});
		}


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(ConstructServiceItem.prototype, {

			/**
			 * Fetches the value from the construct service.
			 * @memberOf awf.__.ConstructServiceItem
			 * @instance
			 * @param  {number}	[age_limit]		If defined, and the previous fetch occurred less than `age_limit` milliseconds, the last fetch promise is immediately returned without making a new request.
			 * @return {$.Deferred}             A promise that will resolve/reject when fetch is complete
			 */
			fetch: function (age_limit) {
				return this.service.fetch(age_limit);
			},


			/**
			 * This does *not* make a fetch request. If a fetch has occurred, it returns the existing promise, otherwise, it returns a promise that will be resolved/rejected with the next fetch.
			 * @memberOf awf.__.ConstructServiceItem
			 * @instance
			 * @return {$.Deferred} A promise that lazily resolves/rejects with an actual fetch.
			 */
			lazyFetch: function () {
				return this.service.lazyFetch();
			},


			/**
			 * Saves the value from the construct service. NOTE: this merely saves this.value, so be sure to call setValue() first if you want to store an updated value.
			 * @memberOf awf.__.ConstructServiceItem
			 * @instance
			 * @return {$.Deferred}              A promise that will resolve/reject when save is complete
			 */
			save: function () {
				return this.service.save();
			}

		});


	/*	Static Methods
	------------------------------------------*/
		_.extend(ConstructServiceItem, {

			/**
			 * Parses the raw reponse from a construct service lookup and converts as needed to other types of objects.
			 * @memberOf awf.__.ConstructServiceItem
			 * @param  {string} val The raw response value
			 * @return {null|string|number|array|object} The converted value
			 */
			parseRawValue: function (val) {
				val = _.unescape(val);

				if (val === "null") {
					val = null;
				} else if (val === "false") {
					val = false;
				} else if (val === "true") {
					val = true;
				} else if (val.charAt(0) == '[' || val.charAt(0) == '{') {
					try {
						// keep this in two lines
						var json = JSON.parse(val);
						val = json;
					} catch (er) {}
				} else if ((val.match(/\d|\./g) || []).length == val.length) {
					if (val.indexOf('.') > -1) {
						try {
							// keep this in two lines
							var fnum = parseFloat(val);
							val = fnum;
						} catch (er) {}
					} else {
						try {
							// keep this in two lines
							var inum = parseInt(val);
							val = inum;
						} catch (er) {}
					}
				}

				return val;
			}

		});


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ConstructService;

	/*	Requirements
	------------------------------------------*/
		var $ = __webpack_require__(4),
			_ = __webpack_require__(5);


	/*	Constructor
	------------------------------------------*/
		awf.util.use(awf.__.BaseModel).toCreate(ConstructService);

		/**
		 * A parent controller for a construct service that uses a single endpoint (url) and appid combination
		 *
		 * @class
		 * @memberOf awf.__
		 * @extends {awf.__.BaseModel}
		 *
		 * @param {object}	params
		 * @param {string}	params.url				The construct service endpoint
		 * @param {string}	params.appid			The application ID -- If using app composition, this will match awf.app.id
		 * @param {boolean}	[params.active_state]	True when the construct service has everything it needs
		 *
		 * @property {object} 						items		As items are created, they will be stored here
		 * @property {awf.__.ConstructServiceItem}	items{} 	An individual construct service item
		 * @property {awf.__.Service}				service		The service that is able to fetch all values for the given endpoint and appid
		 * @property {boolean}	active_state		True when the construct service has everything it needs
		 */
		function ConstructService (params) {
			var self = this;

			params = params || {};

			awf.__.BaseModel.apply(this, arguments);

			this.items = {};

			self.local_storage_key = params.local_storage_key || this.local_storage_key || null;

			self.ready = $.Deferred();
			self._whenCallsAreAvailable = $.Deferred();

			self._whenCallsAreAvailable.done(function () {
				console.log('--- construct service calls are now avilable ---');
			});

			function maybeResolveWhenCallsAreAvailable () {
				if (self.appid && self.endpoint) {
					self._whenCallsAreAvailable.resolve();
				}
			}

			function whenCallsAreAvailable (callback) {
				self._whenCallsAreAvailable.done(callback);
			}


			awf.util.mixin.properties(this, params, {
				/**
				 * @name setAppid
				 * @memberof awf.__.ConstructService
				 * @function
				 * @instance
				 * @param {null|string} val Sets the new value for `appid`
				 * @fires change:appid
				 * @return {object} self chainable
				 */
				appid: {
				    default: null,
				    types: [
				    	"null",
				        "string"
				    ],
				    handler: maybeResolveWhenCallsAreAvailable
				},



				/**
				 * Sets this.timeout
				 * @memberOf awf.__.ConstructService
				 * @name setTimeout
				 * @function
				 * @instance
				 *
				 * @param  {string|null} value the service's timeout URL
				 *
				 * @return {Object} this chainable
				 *
				 * @fires this#change:timeout
				 */
				timeout: {
					default: null,
					types: ['null','number']
				},



				/**
				 * @name setEndpoint
				 * @memberof awf.__.ConstructService
				 * @function
				 * @instance
				 * @param {null|string} val Sets the new value for `endpoint`
				 * @fires change:endpoint
				 * @return {object} self chainable
				 */
				endpoint: {
				    default: null,
				    types: [
				    	"null",
				        "string"
				    ],
				    prep: function (val) {
				    	if (val.charAt(val.length - 1) != '/') {
							val += '/';
						}
						return val;
				    },
				    handler: maybeResolveWhenCallsAreAvailable
				},



				/**
				 * @name setActiveState
				 * @memberof awf.__.ConstructService
				 * @function
				 * @instance
				 * @param {boolean} val Sets the new value for `active_state`
				 * @fires change:active_state
				 * @return {object} self chainable
				 */
				active_state: {
				    "default": false,
				    "types": [
				        "boolean"
				    ]
				}
			});


			this.service = new awf.__.Service({
				local_storage_key: self.local_storage_key,
				onFetch: function (dfr) {

					// wait until calls can be made
					whenCallsAreAvailable(function () {

						// Keeping all the events in one place.. easier to manager this way
						dfr
							.done(function () {
								self.setActiveState(true);
								self.ready.resolve();
								self.triggerHandler('fetch-success');
							})
							.fail(function () {
								self.ready.reject();
								self.triggerHandler('fetch-fail');
							})
							.always(function () {
								self.triggerHandler('fetch-complete');
							});


						awf.user.authentication
							.done(function (is_authenticated) {

								if (is_authenticated) {
									switch (awf.util.url_params.construct_service) {

										case "fail":
											setTimeout(function () {
												dfr.reject('fake failure');
											}, 500);
											break;


										case "timeout":
											setTimeout(function () {
												dfr.reject('fake timeout');
											}, self.timeout || 5000);
											break;


										case "hang":
											console.info(' -- construct lookup is set to hang --');
											break;


										default:

											var delayed_success_dfr = awf.util.urlDelayedDeferred('construct_service');

											$.ajax({
												url: self.endpoint + self.appid + '/',
												xhrFields: {
													withCredentials: true
												},
												contentType: "application/json",
												method: "GET",
												timeout: self.timeout
											})
											.done(function (response) {

												delayed_success_dfr.done(function () {

													_.forEach(response.properties, function (data) {
														var item = self.getOrCreate(data.key);

														// sync up the item's fetch data with the owner
														// this allows item fetch cache to be honored
														if (self.service.local_storage_key) {
															item.service.local_storage_key = self.service.local_storage_key + ':' + data.key;
														}
														item.service.last_fetch_date = self.service.last_fetch_date;
														item.service.last_fetch_duration = self.service.last_fetch_duration;

														var val = awf.__.ConstructServiceItem.parseRawValue(data.value);

														// Create a promise that mimics the item's fetch response.
														var item_dfr = $.Deferred();
														item_dfr.resolve(val);
														item.service.last_fetch_dfr = item_dfr.promise();

														// Apply the fetched value.
														// This will naturally trigger `change` when applicable
														item.setValue(val);

													});

													dfr.resolve(self.items);

												});
											})
											.fail(function (er) {
												if (er.status == 404) {
													
													_.forEach(self.items, function (item, key) {
														item.setValue(null);
													});

													dfr.resolve(null);
												} else {
													dfr.reject(er);
												}
											});

									}

								} else {
									dfr.reject('user is not authenticated');
								}

							})
							.fail(function () {
								dfr.reject('user authentication failed');
							});
					});
				}
			});

		}


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(ConstructService.prototype, {

			/**
			 * Fetches all values for the endpoint and appid
			 * @memberOf awf.__.ConstructService
			 * @instance
			 * @param  {number} [age_limit] If defined, and the previous fetch occurred less than `age_limit` milliseconds, the last fetch promise is immediately returned without making a new request.
			 * @return {$.Deferred}         A promise that will resolve/reject when fetchAll is complete
			 */
			fetchAll: function (age_limit) {
				return this.service.fetch(age_limit);
			},

			/**
			 * This does *not* make a fetch request. If a fetch has occurred, it returns the existing promise, otherwise, it returns a promise that will be resolved/rejected with the next fetch.
			 * @memberOf awf.__.ConstructService
			 * @instance
			 * @return {$.Deferred} A promise that lazily resolves/rejects with an actual fetch.
			 */
			lazyFetchAll: function () {
				return this.service.lazyFetch();
			},

			/**
			 * returns the existing item, or creates a new one and returns it
			 * @memberOf awf.__.ConstructService
			 * @instance
			 * @param  {string} key The key for the item
			 * @return {awf.__.ConstructServiceItem}     The existing or newly created item
			 */
			getOrCreate: function (key) {
				var self = this;

				if ( ! (key in self.items)) {
					self.items[key] = new awf.__.ConstructServiceItem({
						owner: self,
						endpoint: self.endpoint,
						appid: self.appid,
						key: key,
						local_storage_key: self.local_storage_key ? (self.local_storage_key + ':' + key) : null
					});
				}

				return self.items[key];
			},


			/**
			 * @description returns a key/value object with the item keys/values
			 * @memberOf awf.__.ConstructService
			 * @instance
			 * @return {object} A key/value object with the item keys/values
			 */
			toJSON: function () {
				return _.mapValues(this.items, function (item) {
					return item.value;
				});
			}

		});




/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = DragHandler;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		Parent = awf.__.BaseObject;

	awf.util.use(Parent).toCreate(DragHandler);


	/**
	 * Handles the drag events for one or more grids (or other draggable elements)
	 * @class
	 *
	 * @param {object} $parent The jQuery DOM element that will capture mouse events.
	 *
	 * @memberOf awf.__
	 *
	 * @property {boolean} ready Is true when a draggable element has been pressed
	 * @property {boolean} active Is true when a draggable element has been pressed AND has started dragging
	 * @property {object} start The x,y position of the mouse when mousedown first occurred
	 * @property {number} start.x The x position of the mouse when mousedown first occurred
	 * @property {number} start.y The y position of the mouse when mousedown first occurred
	 * @property {object} delta The x,y position of the mouse relative to start
	 * @property {number} delta.x The x position of the mouse relative to start x
	 * @property {number} delta.y The y position of the mouse relative to start y
	 * @property {object} $target The jQuery DOM element that was targeted for drag
	 *
	 * @fires drag:start
	 * @fires drag:move
	 * @fires drag:end
	 *
	 */
	function DragHandler ($parent) {

		if ( ! $parent)
			throw new Error("Cannot create a Drag Handler instance without a parent.");

		var self = this;

		self.ready = false;
		self.active = false;
		self.start = { x:0 , y:0 };
		self.delta = { x:0 , y:0 };
		self.$target = null;

		self.active_participant = null;

		this.participants = {};

		$parent

			// Let's get started!
			.on('mousedown', function (ev) {
				if ($(ev.target).hasClass('js-drag-handle') || $(ev.target).closest('.js-drag-handle').length > 0) {
					//console.log('mousedown ev: ', ev);
					self.ready = true;
					self.active = false;
					self.start = {
						x: awf.mouse.x,
						y: awf.mouse.y
					};
					self.delta = {
						x: 0,
						y: 0
					};
					self.$target = $(ev.target);

					$(window).on('mousemove.drag-handler', function (ev) {
						var new_scroll_top,
							current_scroll_top = $(window).scrollTop(),
							top_zone = 100,
							bottom_zone = $(window).height() - 100;

						ev.preventDefault();
						if (self.ready) {
							self.delta = {
								x: awf.mouse.x - self.start.x,
								y: awf.mouse.y - self.start.y
							};
							if ( ! self.active && Math.max(Math.abs(self.delta.x),Math.abs(self.delta.y)) > 0) {
								self.active = true;
								self.triggerHandler('drag:start', [self.$target, self.delta]);
							}
						}

						if (awf.mouse.offset.y < top_zone) {
							new_scroll_top = current_scroll_top - ((top_zone - awf.mouse.offset.y) * 0.5);
							$('html, body').animate({ scrollTop: new_scroll_top }, 0);
						}

						if (awf.mouse.offset.y > bottom_zone) {
							new_scroll_top = current_scroll_top + ((awf.mouse.offset.y - bottom_zone) * 0.5);
							$('html, body').animate({ scrollTop: new_scroll_top }, 0);
						}

						if (self.active)
							self.triggerHandler('drag:move', [self.$target, self.delta]);
					});
				}
			})



			// Mouse up (or clicked contextmenu)
			.on('mouseup contextmenu', function (ev) {
				//console.log('  mouseup ev: ', ev);
				if (self.ready) {
					ev.preventDefault();
					setTimeout(function () {
						self.killDrag();
					}, 100);
				}
			})


			// Elvis has left the building
			.on('mouseleave.drag-handler', function () {
				if( ! self.active)
					return false;

				self.exit_timeout = setTimeout(function () {
					self.killDrag();
				}, 500);

				$(this)
					.off('mouseenter.drag-handler')
					.on('mouseenter.drag-handler', function () {
						clearTimeout(self.exit_timeout);
					});
			});
	}



	_.extend(DragHandler.prototype, {
		/**
		 * Stops an active dragging process
		 * @memberOf awf.__.DragHandler
		 * @return {object} this (chainable)
		 */
		killDrag: function () {
			var self = this;

			if (self.active) {
				self.triggerHandler('drag:end', [self.$target]);
				self.active = false;
				self.setActiveParticipant(null);
			}

			self.ready = false;
			self.$target = null;
			$(window).off('mousemove.drag-handler');

			setTimeout(function () {
				_.forEach(self.participants, function (participant, id) {
					participant.applyPositions();
				});
			}, 100);

			return self;
		},


		registerParticipant: function (id, instance) {
			var self = this;

			this.participants[id] = instance;
			console.group('Drag participant: ', id);

			if (instance instanceof awf.ui.ArrangeableGrid) {
				DragHandler.type_handlers.grid.call(this, id, instance);
			}

			console.groupEnd();

			return this;
		},


		setActiveParticipant: function (new_val) {
			// if both new/old are null, or the IDs of new/old are the same: do nothing
			if ((new_val === null && this.active_participant === null) || _.get(new_val, 'id') === _.get(this.active_participant, 'id'))
				return this;

			var old_val = this.active_participant;
			this.active_participant = new_val;

			this.triggerHandler('change:active_participant', [new_val,old_val]);

			return this;
		}
	});





	/*	Default Type Handlers
	------------------------------------------*/
		DragHandler.type_handlers = {
			grid: __webpack_require__(69)
		};


/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = function (id, grid) {
		var drag_handler = this;

		grid.dnd_id = id;

		grid.on('change:order', function (ev, new_order) {
			drag_handler.triggerHandler('change:order', [grid, new_order]);
		});

		drag_handler
			.on('drag:start', function (ev, $target, delta) {
				if ( ! $target.closest('.grid').is(grid.$el))
					return false;

				$target.addClass('-grabbed');

				var grid_item = $target.closest('.grid__item').data('component');

				drag_handler.setActiveParticipant(grid_item.collection);

				if ( ! grid_item.$el)
					return false;

				grid_item.orig_pos = {
					x: parseFloat(grid_item.$el.css('left')),
					y: parseFloat(grid_item.$el.css('top'))
				};

				grid_item.$el
					.addClass('-dragging')
					.css({
						transform: 'translate(' + delta.x + 'px, ' + delta.y + 'px)'
					});

				grid.setGrabbedItem(grid_item);
				grid.setGhost(grid_item);
				awf.page.setSelectableState(false);



				var tile_center = grid_item.getCenter(),
					tile_offset = {
						x: (grid.$el.width() / grid.columns) * grid_item.col,
						y: (grid.tile.height * grid_item.row) + (grid.tile.margin * (grid_item.row - 1))
					},
					grid_drop_point = {
						x: tile_center.x + tile_offset.x + delta.x,
						y: tile_center.y + tile_offset.y + delta.y
					},
					grid_offset = grid.$el.offset(),
					page_drop_point = {
						x: grid_offset.left + grid_drop_point.x,
						y: grid_offset.top + grid_drop_point.y
					};


				// you always start in the grid
				grid._is_dragging_within_domain = true;
				drag_handler.triggerHandler('within-domain-drag:start', [id, grid, grid_item, page_drop_point]);

				grid_item.delta = delta;
			})


			/*	Drag Move
			------------------------------------------*/
			.on('drag:move', function (ev, $target, delta) {
				if ( ! $target.closest('.grid').is(grid.$el))
					return false;

				var grid_item = $target.closest('.grid__item').data('component');

				if ( ! grid_item.$el)
					return false;

				var tile_center = grid_item.getCenter(),
					tile_offset = {
						x: (grid.$el.width() / grid.columns) * grid_item.col,
						y: (grid.tile.height * grid_item.row) + (grid.tile.margin * (grid_item.row - 1))
					},
					grid_drop_point = {
						x: tile_center.x + tile_offset.x + delta.x,
						y: tile_center.y + tile_offset.y + delta.y
					},
					loc = grid.getLocation(grid_drop_point),
					grid_offset = grid.$el.offset(),
					page_drop_point = {
						x: grid_offset.left + grid_drop_point.x,
						y: grid_offset.top + grid_drop_point.y
					};

				grid.setGhost(loc);

				if (grid.ghost.is_in_domain) {
					// handle the switch events
					if ( ! grid._is_dragging_within_domain) {
						grid._is_dragging_within_domain = true;
						drag_handler.triggerHandler('beyond-domain-drag:end', [id, grid, grid_item]);
						// where one ends, the other begins
						drag_handler.triggerHandler('within-domain-drag:start', [id, grid, grid_item, page_drop_point]);
					} else {
						// trigger the domain-specific move event
						drag_handler.triggerHandler('within-domain-drag:move', [id, grid, grid_item, page_drop_point]);
					}
				} else {
					// handle the switch events
					if (grid._is_dragging_within_domain) {
						grid._is_dragging_within_domain = false;
						drag_handler.triggerHandler('within-domain-drag:end', [id, grid, grid_item]);
						// where one ends, the other begins
						drag_handler.triggerHandler('beyond-domain-drag:start', [id, grid, grid_item, page_drop_point]);
					} else {
						// trigger the domain-specific move event
						drag_handler.triggerHandler('beyond-domain-drag:move', [id, grid, grid_item, page_drop_point]);
					}
				}

				grid.applyPositions();

				grid_item.delta = delta;
				grid_item.$el.css({
					transform: 'translate(' + delta.x + 'px, ' + delta.y + 'px)'
				});
			})


			/*	Drag End
			------------------------------------------*/
			.on('drag:end', function (ev, $target) {
				if ( ! $target.closest('.grid').is(grid.$el))
					return false;

				$target.removeClass('-grabbed');

				var grid_item = $target.closest('.grid__item').data('component');

				if ( ! grid_item.$el)
					return false;

				/*if (grid._is_dragging_within_domain) {
					drag_handler.triggerHandler('within-domain-drag:end', [id, grid, grid_item]);
				} else {
					drag_handler.triggerHandler('beyond-domain-drag:end', [id, grid, grid_item]);
				}*/

				var new_order = grid.getNewOrder();

				grid.setGhost(null);
				grid.setGrabbedItem(null);
				awf.page.setSelectableState(true);

				grid.setOrder(new_order);

				/*	Repositioning
				------------------------------------------*/
				if (grid_item && grid_item.$el) {
					var final_pos = {
							x: parseFloat(grid_item.$el.css('left')),
							y: parseFloat(grid_item.$el.css('top'))
						},
						delta_pos = {
							x: final_pos.x - grid_item.orig_pos.x,
							y: final_pos.y - grid_item.orig_pos.y
						};


					grid_item.delta.x -= delta_pos.x;
					grid_item.delta.y -= delta_pos.y;

					delete grid_item.orig_pos;

					grid_item.$el
						.css({
							transform: 'translate(' + grid_item.delta.x + 'px, ' + grid_item.delta.y + 'px)'
						});

					setTimeout(function () {
						if (grid_item && grid_item.$el) {
							grid_item.$el
								.removeClass('-dragging')
								.css({
									transform: 'translate(0, 0)'
								});
						}
					}, 0);
				}
			});
	};


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = CollectionItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21);

	use(awf.__.BaseModel).toCreate(CollectionItem);




	/**
	 * CollectionItem Component
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseModel}
	 */
	function CollectionItem (params) {
		params = params || {};
		awf.util.mixin.collectionItem(this, params);
		awf.__.BaseModel.apply(this, arguments);

		/**
		 * @name removeFromCollection
		 * @description Removes this item from the parent collection. It calls the collection's removeItem method, passing the index. If not part of a collection, an error is thrown.
		 * @memberOf awf.__.CollectionItem
		 * @instance
		 * @function
		 * @return {object} this (chainable)
		 */


		/**
		 * @name index
		 * @description Returns the index of this item from its collection.items array. It does NOT necessarily reflect the index of the DOM element. (though in normal circumstances it would match)
		 * @memberOf awf.__.CollectionItem
		 * @instance
		 * @function
		 * @return {number} The index position from the collection.items array.
		 */


		/**
		 * @name promote
		 * @description If possible, it swaps position with the item ahead of it.
		 * @memberOf awf.__.CollectionItem
		 * @instance
		 * @function
		 * @return {boolean} If it was able to move, true. Otherwise false.
		 */


		/**
		 * @name demote
		 * @description If possible, it swaps position with the item behind it.
		 * @memberOf awf.__.CollectionItem
		 * @instance
		 * @function
		 * @return {boolean} If it was able to move, true. Otherwise false.
		 */
	}


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Collection;

	var _ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseModel = awf.__.BaseModel;

	use(BaseModel).toCreate(Collection);




	/**
	 * Collection Component
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseModel}
	 * 
	 * @param {object} [params]
	 * @param {array} [params.items] The items to include in the collection
	 * @param {object} [params.Item] The constructor to use when creating new items. Only use when you want to use something *other than* the default
	 *
	 * @property {array} items The array of collection items
	 * @property {awf.__.CollectionItem} Item The constructor to use when creating new items
	 */
	function Collection (params) {
		params = params || {};
		BaseModel.apply(this, arguments);
		awf.util.mixin.collection(this, params);

		/**
		 * @name addItem
		 * @description Adds a new item to the end of the collection
		 * @memberOf awf.__.Collection
		 * @instance
		 * @function
		 * @param {undefined|null|object|array|awf.ui.BaseObject} params_or_instance If an object, it will create a new this.Item(object). Otherwise, if an instance of CollectionItem, it will pull it in, reasign that item's collection, and render it if the collection is already rendered. This allows items to be moved from one collection to another.
		 * @return {awf.__.CollectionItem} the newly added item
		 */


		/**
		 * @name removeItem
		 * @description Adds a new item to the end of the collection
		 * @memberOf awf.__.Collection
		 * @instance
		 * @function
		 * @param  {number} index The index to remove
		 * @return {awf.__.CollectionItem}       The removed item
		 */


		/**
		 * @name removeAllItems
		 * @description Removes all items, from last to first.
		 * @memberOf awf.__.Collection
		 * @instance
		 * @function
		 * @return {object} this (chainable)
		 */
		
		/**
		 * @name setOrder
		 * @description Takes a unique array of numbers from 0 to (n-1) and sorts the items acordingly
		 * @memberOf awf.__.Collection
		 * @instance
		 * @function
		 * @param {array} new_order An array of numbers that matches the length of items, each number must be unique, and includes exactly one of every index value
		 * @return {object} this (chainable)
		 */
	}

	_.extend(Collection.prototype, {

		Item: awf.__.CollectionItem

	});


/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = DBDimensionGroup;

	var Parent = awf.__.BaseModel;

	awf.util.use(Parent).toCreate(DBDimensionGroup);

	/*	Constructor
	------------------------------------------*/
		function DBDimensionGroup (owner, key) {
			if ( ! owner)
				throw new Error('Cannot construct DBDimensionGroup without an owner');

			if ( ! key)
				throw new Error('Cannot construct DBDimensionGroup without a key');

			this.items = [];
			this.id = awf.util.randomID();
			this.owner = owner;
			this.key = key;

			Parent.call(this);
		}


	/*	Prototype methods
	------------------------------------------*/
		_.extend(DBDimensionGroup.prototype, {
			addItem: function (item) {
				var self = this;

				item.on('change.dimension-group-' + self.id, function (ev, prop, n, o) {
					self.triggerHandler('change:item', [this, prop, n, o]);
					self.triggerHandler('change', ['item', this, prop, n, o]);
				});

				this.items.push(item);
				this.triggerHandler('add:item', [item]);
				this.triggerHandler('add', ['item',item]);
				this.triggerHandler('change:length', [this.items.length, this.items.length - 1]);
				this.triggerHandler('change', ['length', this.items.length, this.items.length - 1]);
				return item;
			},

			removeItem: function (items) {
				var self = this,
					removed_items = _.remove(this.items, items);


				this.triggerHandler('remove:item', [removed_items]);
				//this.triggerHandler('remove', ['item',removed_items]);
				this.triggerHandler('change:length', [this.items.length, this.items.length + removed_items.length]);
				this.triggerHandler('change', ['length', this.items.length, this.items.length + removed_items.length]);
				
				_.forEach(removed_items, function (item) {
					item.off('change.dimension-group-' + self.id);
				});

				if (this.items.length === 0) {
					//console.group('after removing an item, db-d-g discovered that this was the last one. Removing group `' + this.key + '`');
					this.owner.removeGroup(this.key);
					//console.groupEnd();
				}

				return removed_items;
			}
		});


/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = DBDimension;

	var Parent = awf.__.BaseModel;

	awf.util.use(Parent).toCreate(DBDimension);

	/*	Constructor
	------------------------------------------*/
		function DBDimension (key) {

			if ( ! key)
				throw new Error('Cannot construct DBDimension without a key');

			this.id = awf.util.randomID();
			this.key = key;
			this.groups = {};

			Parent.call(this);
		}


	/*	Prototype methods
	------------------------------------------*/
		_.extend(DBDimension.prototype, {

			getOrCreateGroup: function (key) {
				var self = this,
					group = null;
				
				if ( ! (key in this.groups)) {
					group = new awf.__.DBDimensionGroup(this, key);
					this.groups[key] = group;
					this.triggerHandler('add:group', [group]);

					// watching for property changes to self-adjust groups
					group.on('change:item', function (ev, changed_item, prop, n, o) {
						if (prop == self.key) {
							//self.triggerHandler('remove:item', [changed_item,self.key]);
							this.removeItem(changed_item);
							self.addItem(changed_item);
						}
					});
				}

				return group;
			},


			removeGroup: function (key) {
				var group = this.groups[key];
				//group.triggerHandler('delete');
				//console.group('Dimension is removing group ['+key+']');
				this.triggerHandler('remove:group', [group]);
				//console.groupEnd();
				delete this.groups[key];
			},


			addItem: function (item) {
				
				// console.log('About to create group for item: ', item);
				// console.log('this.id: ', this.id);
				// console.log('this.key: ', this.key);
				// console.log('item[this.key]: ', item[this.key]);


				var self = this,
					item_key = item[this.key];

				if (item_key) {
					var group = this.getOrCreateGroup(item_key);
					this.groups[item[this.key]].addItem(item);
					this.triggerHandler('add:item', [this.item,this.key]);
				}
				return item;
			},


			removeItem: function (item) {
				if ( ! (item[this.key] in this.groups)) {
					return null;
				}
				var removed_item = this.groups[item[this.key]].removeItem(item);
				this.triggerHandler('remove:item', [removed_item,this.key]);
				return removed_item;
			},


			keys: function () {
				return _.keys(this.groups);
			}

		});


/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = DB;

	var Parent = awf.__.BaseModel;

	awf.util.use(Parent).toCreate(DB);

	/*	Constructor
	------------------------------------------*/
		/**
		 * A multi-dimensional database that automatically stores data according to the keys given. Mixes in collection.
		 * @extends {awf.__.BaseModel}
		 * @extends {awf.__.Collection}
		 * @class
		 * @memberOf awf.__
		 * @param {object}	[params]
		 * @param {array}	[params.keys] The dimensions that this database should maintain
		 */
		function DB (params) {
			params = params || {};

			var self = this;

			this.keys = params.keys || this.keys || [];

			this.dimensions = {};
			_.forEach(this.keys, function (key) {
				self.dimensions[key] = new awf.__.DBDimension(key);
			});

			Parent.apply(this, arguments);

			awf.util.mixin.collection(this, params, {

				addItem: function (item) {
					_.forEach(self.dimensions, function (dimension, key) {
						dimension.addItem(item);
					});
				},

				removeItem: function (item) {
					_.forEach(self.dimensions, function (dimension, key) {
						//console.group('removing item (' + item.data.title + ') from dimension [' + dimension.key + ']');
						dimension.removeItem(item);
						//console.groupEnd();
					});
				}

			});
		}



	/*	Prototype methods
	------------------------------------------*/
		_.extend(DB.prototype, {
			/**
			 * The item class when creating new items
			 * @instance
			 * @memberOf awf.__.DB
			 * @type {awf.__.CollectionItem}
			 */
			Item: awf.__.CollectionItem
		});


/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = BadgeDBItem;

	var Parent = awf.__.CollectionItem;

	awf.util.use(Parent).toCreate(BadgeDBItem);

	/*	Constructor
	------------------------------------------*/
		/**
		 * A Badge DB
		 * @extends {awf.__.CollectionItem}
		 * @class
		 * @memberOf awf.__
		 * @param {object}		params
		 * @param {string}		[params.content]	The content of the badge
		 * @param {null|string}	[params.experience]	Which experience this badge belongs to
		 * @param {null|string}	[params.cog]		Which cog this badge belongs to
		 * @param {null|string}	[params.view]		Which view this badge belongs to

		 * @property {string}		content		The content of the badge
		 * @property {null|string}	experience	Which experience this badge belongs to
		 * @property {null|string}	cog			Which cog this badge belongs to
		 * @property {null|string}	view		Which view this badge belongs to
		 * 
		 */
		function BadgeDBItem (params) {
			params = params || {};
			var self = this;
			Parent.apply(this, arguments);

			awf.util.mixin.properties(this, params, {

				/**
				 * @name setContent
				 * @memberof awf.__.BadgeDBItem
				 * @function
				 * @instance
				 * @param {string} val Sets the new value for `content`
				 * @fires change:content
				 * @return {object} self chainable
				 */
				content: {
					"default": "",
					"types": [
						"string"
					]
				},


				/**
				 * @name setExperience
				 * @memberof awf.__.BadgeDBItem
				 * @function
				 * @instance
				 * @param {null|string} val=null Sets the new value for `experience`
				 * @fires change:experience
				 * @return {object} self chainable
				 */
				experience: {
					"default": null,
					"types": [
						"null",
						"string"
					]
				},


				/**
				 * @name setCog
				 * @memberof awf.__.BadgeDBItem
				 * @function
				 * @instance
				 * @param {null|string} val=null Sets the new value for `cog`
				 * @fires change:cog
				 * @return {object} self chainable
				 */
				cog: {
					"default": null,
					"types": [
						"null",
						"string"
					]
				},


				/**
				 * @name setView
				 * @memberof awf.__.BadgeDBItem
				 * @function
				 * @instance
				 * @param {null|string} val=null Sets the new value for `view`
				 * @fires change:view
				 * @return {object} self chainable
				 */
				view: {
					"default": null,
					"types": [
						"null",
						"string"
					]
				}

			});
		}



	/*	Prototype Extentions
	------------------------------------------*/
		_.extend(BadgeDBItem.prototype, {

			//

		});


/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = BadgeDB;

	var Parent = awf.__.DB;

	awf.util.use(Parent).toCreate(BadgeDB);

	/*	Constructor
	------------------------------------------*/
		/**
		 * A Badge DB
		 * @extends {awf.__.DB}
		 * @class
		 * @memberOf awf.__
		 * @param {object} params
		 */
		function BadgeDB (params) {
			params = params || {};

			var self = this;

			this.keys = ['experience','cog'];
			Parent.apply(this, arguments);
		}



	/*	Prototype Extentions
	------------------------------------------*/
		_.extend(BadgeDB.prototype, {

			/**
			 * The item class when creating new items
			 * @instance
			 * @memberOf awf.__.BadgeDB
			 * @type {awf.__.BadgeDBItem}
			 */
			Item: awf.__.BadgeDBItem
		});


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Cog;

	var _ = __webpack_require__(5);

	awf.util.use(awf.__.BaseModel).toCreate(Cog);

	/**
	 * @class Cog
	 * @memberOf awf.__
	 * @type {object}
	 * @extends {awf.__.BaseModel}
	 *
	 * @classdesc The Cog class provides a structure for the basic building block of the Application Composition capabilities of the AWF. They often represent a single widget within an [Experience]{@link awf.__.Experience}.
	 *
	 * @description A Cog. The Application Composition capabilities of the AWF will take care of construction and teardown of Cogs at the appropriate time in the lifecycle of the App. You should not need to use this constructor in your code.
	 *
	 * @param {awf.__.Cog.cogConfig} [params] The configuration object used to construct an Cog
	 *
	 * @property {object} data - An object passed as `this` to all setup, teardown, render, and init functions defined by the parameters
	 * @property {object} views - A collection of views available for this cog
	 * @property {object} context - Reserved property for the forthcoming Context Adaptive Enabler
	 * @property {string|null} id - The unique identifier for this cog instance
	 * @property {string|null} type - The id of the cog type as defined by the id parameter used when the cog was registered
	 * @property {string|null} [flag] - The flag used by the run time Feature Toggler to represent this cog type
	 * @property {boolean} _is_setup - Flag to ensure that setup is called only once for this cog
	 * @property {null|function} _setup - The setup method (if one was provided) for the cog
	 * @property {null|function} _teardown - The teardown method (if one was provided) for the cog
	 * @property {array} _view_instances - When a view is rendered, that instnace is pushed here so it can be recursively destroyed with the cog later.
	 */
	function Cog (params) {
		params = params || {};
		awf.__.BaseModel.apply(this, arguments);

		var data = new awf.__.BaseModel();		// what is .data used for?
		this.data = _.extend(data, params.data, this.data);
		this.views = _.extend({}, params.views, this.views);
		_.forEach(this.views, function (view, type) {
			view.type = type;
		});

		this.context = _.extend({}, params.context, this.context);

		this.id = params.id || this.id || null;		// where is the instance specific id?
		this.type = params.type || this.type || null;
		this.flag = params.flag || this.flag || null;

		this._is_setup = false;
		this._setup = params.setup;
		this._teardown = params.teardown;

		this._view_instances = [];
	}


	_.extend(Cog.prototype, {

		/**
		 * If a setup method was provided, it is called with cog.data as `this`.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {object} this (chainable)
		 */
		setup: function () {
			var self = this;

			if (this._setup)
				this._setup.call(this.data, {
					postBadge: function (params) {
						params = params || {};
						if (typeof params == "string") {
							params = {
								content: params
							};
						}

						params.cog = self.id;
						params.experience = awf.app.experience.id;
						return awf.badge_db.addItem(params);
					}
				});
			return this;
		},


		/**
		 * If a teardown method was provided, it is called with cog.data as `this`.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {object} this (chainable)
		 */
		teardown: function () {
			this._setup = false;

			this.destroyAllViews();
			if (this._teardown)
				this._teardown.call(this.data);

			_.forEach(this.views, function (view, id) {
				view._initialized = false;
			});

			return this;
		},


		/**
		 * Returns false if a flag has been set AND that flag is inactive. True if unset or the flag likes you.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {Boolean} [description]
		 */
		isAvailable: function () {
			if (this.flag) {
				return awf.flags.isActive(this.flag);
			} else {
				return true;
			}
		},

		/**
		 * Returns an array of strings, each an available view. If a view has a blocking feature flag, that view will not be listed.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {array} An array of avaialble view types
		 */
		availableViews: function () {
			var available_views = [];
			_.forEach(this.views, function (view, type) {
				if ('flag' in view) {
					if (awf.flags.isActive(view.flag)) {
						available_views.push(type);
					}
				} else {
					available_views.push(type);
				}
			});
			return available_views;
		},

		/**
		 * Returns false if the given view type does not exist or has a blocking flag. Otherwise returns true
		 * @instance
		 * @memberOf awf.__.Cog
		 * @param  {string}  type The view type
		 * @return {Boolean}      [description]
		 */
		isViewAvailable: function (type) {
			if (type in this.views)
				return _.contains(this.availableViews(), type);
			else
				return null;
		},


		/**
		 * Renders a view to a container. If setup hasn't been called, it will be. If that view's init hasn't been called, it will be.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @param {string} type The type of view to be rendered. If this type is unknown to the cog, an error will be thrown.
		 * @param {object} $container A jquery object of the DOM element to pass to the render function
		 * @return {CogView} The view instance rendered
		 */
		renderView: function (type, $container, api, init_api) {

			var view = this.views[type];

			if (view === undefined)
				throw new Error('Cannot render view of unknown type: ' + type);

			if ( ! view.render)
				throw new Error('Cannot render `' + type + '` view -- it has has no render function defined.');

			this._maybeSetupCog();

			this._maybeInitializeView(type, init_api);

			var view_methods = {};

			if (type in Cog.render_methods) {
				view_methods = Cog.render_methods[type].call(this, api || {});
			}

			var view_instance = new CogView(this, type, $container, view_methods);
			this._view_instances.push(view_instance);

			view_instance.render();

			this.triggerHandler('render:' + type);

			return view_instance;
		},


		/**
		 * Destroys all the views that have been created by this cog, calling destroy() for each one.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {object} this (chainable)
		 */
		destroyAllViews: function () {
			var self = this;

			_.forEach(self._view_instances, function (instance) {
				console.log('destroying `' + instance.type + '` instance: ', instance);
				instance.destroy();

				self.triggerHandler('destroy:' + instance.type);
			});

			self._view_instances = [];

			return self;
		},


		/**
		 * If _is_setup is false, it will call setup() and set _is_setup to true.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {object} this (chainable)
		 */
		_maybeSetupCog: function () {
			if ( ! this._is_setup) {
				this.setup();
				this._is_setup = true;
			}

			return this;
		},


		/**
		 * If the view has not yet had its init method called, it will call it.
		 * @instance
		 * @memberOf awf.__.Cog
		 * @return {object} this (chainable)
		 */
		_maybeInitializeView: function (type, api) {
			api = api || {};

			var self = this,
				view = self.views[type];

			//console.log('_maybeInitializeView view: ', view);

			if ( ! view._initialized) {
				if (view.init) {

					_.extend(api, {
						postBadge: function (msg) {
							var params = {
									cog: self.id,
									experience: awf.app.experience.id,
									view: view.type,
									content: msg
								};
							return awf.badge_db.addItem(params);
						}
					});

					view.init.call(this.data, api);
				}
				view._initialized = true;
			}

			return this;
		}
	});








	_.extend(Cog, {

		 /**
		  * Defines helper methods associated with rendered views
		  * @type {object}
		  * @memberOf awf.__.Cog
		  * @inner
		  */
		render_methods: {

			/**
			 * Helper methods associated with rendered mini views in a cog
			 * @memberOf awf.__.Cog~render_methods
			 * @param  {object} params Parameters for the methods
			 * @return {object}        An object containing the helper methods available to mini views
			 */
			mini: function (params) {

				return {
					/**
					 * Sets the title of the mini view using the configuration paramteres
					 * @memberOf awf.__.Cog~render_methods~mini
					 */
					setTitle: function () {
						params.card.setTitle.apply(params.card, arguments);
						return this;
					},
					/**
					 * Sets the icon in the mini view using the configuration parameters
					 * @memberOf awf.__.Cog~render_methods~mini
					 */
					setIcon: function () {
						params.card.setIcon.apply(params.card, arguments);
						return this;
					}
				};

			},

			/**
			 * Helper methods associated with rendered medium views in a cog
			 * @param  {object} params Parameters for the methods
			 * @return {object}        An object containing the helper methods available to medium views
			 */
			medium: function (params) {

				var cog = this;

				return {

					/**
					 * Closes the medium view card. (Only available for medium views associated with a 'tray' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					closeTray: function () {
						switch (params.context) {
							case 'page-tray':
								cog.component.hide();
								break;

							default:
								console.warn('closeTray does not work in context `' + params.context + '`.');
						}

						return this;
					},

					/**
					 * Returns a boolean for the medium view where true means that a large view exists for this cog and is available to the user. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					handleLargeViewAvailable: function (fn) {
						switch (params.context) {
							case 'grid':
								awf.app.experience.modal_available_flag.runAndWatch(function (is_flippable) {
									fn(is_flippable && cog.isViewAvailable('large'));
								});
								break;

							default:
								fn(false);
						}
					},

					/**
					 * Sets the title of the medium view using the configuration paramteres. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					setTitle: function (val) {
						switch (params.context) {
							case 'grid':
								params.card.setTitle(val);
								break;

							default:
								console.warn('setTitle does not work in context `' + params.context + '`.');
						}

						return this;
					},

					/**
					 * Sets the row span for a the medium view using the provided value. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					setRowSpan: function (val) {
						switch (params.context) {
							case 'grid':
								params.grid_item.setRowSpan(val);
								params.grid_item.collection.autoSetColumns();
								break;

							default:
								console.warn('setRowSpan does not work in context `' + params.context + '`.');
						}

						return this;
					},

					/**
					 * Sets the column span for a the medium view using the provided value. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					setColSpan: function (val) {
						switch (params.context) {
							case 'grid':
								params.grid_item.setColSpan(val);
								params.grid_item.collection.autoSetColumns();
								break;

							default:
								console.warn('setColSpan does not work in context `' + params.context + '`.');
						}

						return this;
					},

					/**
					 * Posts a message in the medium view using the provided parameters. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					postMessage: function (type, message, show_dismiss) {
						switch (params.context) {
							case 'grid':
								return params.card.postMessage(type, message, show_dismiss);

							default:
								console.warn('postMessage does not work in context `' + params.context + '`.');
								return null;
						}
					},

					/**
					 * Flips the medium view card to the cog's large view state. (Only available for medium views associated with a 'grid' context.)
					 * @memberOf awf.__.Cog~render_methods~medium
					 */
					flipCard: function () {
						switch (params.context) {
							case 'grid':
								params.card.trigger('request-open');
								break;

							default:
								console.warn('flipCard does not work in context `' + params.context + '`.');
						}

						return this;
					}

				};

			},

			/**
			 * Helper methods associated with rendered large views in a cog
			 * @memberOf awf.__.Cog~render_methods
			 * @param  {object} params Parameters for the methods
			 * @return {object}        An object containing the helper methods available to large views
			 */
			large: function (params) {

				return {

					/**
					 * Sets the title of the large view using the provided value.
					 * @memberOf awf.__.Cog~render_methods~large
					 */
					setTitle: function (val) {
						params.card.setTitle(val);
						return this;
					},

					/**
					 * Sets the width of the large view using the provided value.
					 * @memberOf awf.__.Cog~render_methods~large
					 */
					setWidth: function (val) {
						awf.modal.setWidth(val);
						return this;
					},

					/**
					 * Sets the height of the large view using the provided value.
					 * @memberOf awf.__.Cog~render_methods~large
					 */
					setHeight: function (val) {
						awf.modal.setHeight(val + 53);
						return this;
					},

					/**
					 * Posts a message in the large view using the provided parameters.
					 * @memberOf awf.__.Cog~render_methods~large
					 */
					postMessage: function (type, message, show_dismiss) {
						return params.card.postMessage(type, message, show_dismiss);
					},

					/**
					 * Flips the large view card, returning to it's previous state (medium, mini, etc.).
					 * @memberOf awf.__.Cog~render_methods~large
					 */
					flipCard: function () {
						params.card.trigger('request-close');
						return this;
					}
				};

			}

		}

	});









	/**
	 * CogView
	 * @private
	 * @param {awf.__.Cog} owner     The cog instance that generated this view
	 * @param {string} type          The type of view rendered
	 * @param {object} $container    The container used when this view was generated
	 */
	function CogView (owner, type, $container, api) {
		this.owner = owner;
		this.$container = $container;
		this.api = api || {};
		this.view = owner.views[type];
		this.type = type;
	}

	_.extend(CogView.prototype, {

		/**
		 * If a render function was defined by the view, it is called.
		 * @memberOf CogView
		 * @return {object} this (chainable)
		 */
		render: function () {
			if (this.view.render)
				this.view.render.call(this.owner.data, this.$container, this.api);
			return this;
		},


		/**
		 * If a destroy function was defined by the view, it is called.
		 * @memberOf CogView
		 * @return {object} this (chainable)
		 */
		destroy: function () {
			if (this.view.destroy)
				this.view.destroy.call(this.owner.data, this.$container);
			this.$container.empty();
			this.$container.off();
			return this;
		}
	});

	/**
	 * @typedef cogConfig
	 * @memberof awf.__.Cog
	 * @type Object
	 * @description The cogConfig object is used to describe the configurable elements of a Cog. The configuration is used to construct new Cogs as well as to define them through [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerCog]{@link awf.__.App.registerCog}
	 * @property {string} id the ID of this Cog (ignored by [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerCog]{@link awf.__.App.registerCog})
	 * @property {string} type the type of Cog (ignored by [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerCog]{@link awf.__.App.registerCog})
	 * @property {string} [flag] The flag used by the Feature Toggler to control visibility of the Cog
	 * @property {function} [setup] The code to run during the setup phase of the Cog lifecycle
	 * @property {function} [teardown] The code to run during the teardown phase of the Cog lifecycle
	 * @property {awf.ui.View.viewConfig} views The view configurations for this Cog
	 *
	 * @example
	 * {
	 *    "setup": function() {
	 *       this.cogLabel = "My Cog";
	 *    },
	 *    "views": {
	 *       "medium": {
	 *          "label": "My Cog",
	 *          "render": function ($container) {
	 *             $container.html('<h2 style="text-align:center;">' + this.cogLabel + '</h2>');
	 *          }
	 *       },
	 *       "large": {
	 *          "label": "My Cog",
	 *          "render": function ($container) {
	 *             $container.html('<h1 style="text-align:center;">' + this.cogLabel + '</h1>');
	 *          }
	 *       }
	 *    }
	 * }
	 */


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	module.exports = Experience;

	awf.util.use(awf.__.BaseModel).toCreate(Experience);

	/**
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseModel}
	 *
	 * @classdesc The Experience class provides a structure for the canvas upon which the Application Composition layer of the AWF combines one or more [Cogs]{@link awf.__.Cog} to create a User Experience on the page.
	 *
	 * @description An Experience. The Application Composition capabilities of the AWF will take care of construction and teardown of Experiences at the appropriate time in the lifecycle of the App. You should not need to use this constructor in your code.
	 * @param {awf.__.Experience.experienceConfig} [params] The configuration object used to construct an Experience
	 *
	 * @property {string}						label					The label
	 * @property {string}						icon					The icon background image URL
	 * @property {awf.ui.Layout}				layout					The layout instance
	 * @property {array}						cogs					An object with collections of cogs
	 * @property {object}						context					Stores the context values
	 * @property {awf.__.FeatureToggler.Flag}	modal_available_flag	A flag that can be inspected and/or watched for changes on the availability of a modal, based on window width and optional config.
	 */
	function Experience (params) {
		params = params || {};
		
		console.group(_.template('Constructing Experience `{{label}}` [{{id}}]')(_.defaults({}, params, {label:'?',id:'?'})));
		console.log('params: ', params);

		var self = this;

		self.id = params.id || self.id || null;
		self.cog_types = _.extend([], self.cogs, params.cogs);
		self.context = _.extend({}, self.context, params.context);
		self.cogs = {};


		/*	Layout
		------------------------------------------*/
			if ('layout' in params && ! (params.layout instanceof awf.ui.Layout)) {
				params.layout.render = false;
				params.layout.experience = self;
				params.layout.parent = function () {
					return awf.$('#layout', awf.page.$el);
				};
				self.layout = new awf.ui.Layout(params.layout);
			} else {
				self.layout = params.layout || self.layout || new awf.ui.Layout({
					render: false,
					experience: self,
					parent: function () {
						return awf.$('#layout', awf.page.$el);
					}
				});
			}


		/*	preference_service
		------------------------------------------*/
			self.key = 'experience : ' + self.id;

			var use_construct_service = !! awf.construct;

			if (use_construct_service) {

				self.preference_service = awf.construct.getOrCreate(self.key);

			} else {
				if (awf.user) {
					awf.user.authentication.done(function () {
						self.key = awf.user.info.cnum + ' : ' + self.key;
					});
				}

				self.preference_service = new awf.__.LocalStorageService({
					key: self.key
				});

				if (awf.user) {
					awf.user.authentication.done(function () {
						self.preference_service.key = self.key;
					});
				}
			}


		/*	Properties
		------------------------------------------*/
			awf.util.mixin.properties(self, params, {
				/**
				 * setLabel
				 * @name setLabel
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {string} new_val The new value of the label
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				label: {
					default: '',
					types: ['string']
				},


				/**
				 * setId
				 * @name setId
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {string} new_val The new value of the id
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				id: {
					default: '',
					types: ['string']
				},


				/**
				 * setId
				 * @name setId
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {string} new_val The new value of the type
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				type: {
					default: '',
					types: ['string']
				},


				/**
				 * setIcon
				 * @name setIcon
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {boolean|string} new_val The new value of the icon. Pass null to set as none.
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				icon: {
					default: null,
					types: ['null','string']
				},

				/**
				 * setActiveIcon
				 * @name setActiveIcon
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {boolean|string} new_val The new value of the active_icon. Pass null to set as none.
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				active_icon: {
					default: null,
					types: ['null','string']
				},


				preferences: {
					default: null,
					types: ['null','object']
				},


				/**
				 * If included, this will create a 'fixed-width' modal window for the experience.
				 * @name setModalWidth
				 * @function
				 * @memberOf awf.__.Experience
				 * @instance
				 * @param {null|number} new_val The new value of the modal_width. Pass null to set as repsonsive.
				 * @param {boolean} [_silent] Pass `true` to ONLY update the property, and avoid updating the DOM or fire events
				 * @return {object} this (chainable)
				 */
				modal_width: {
					default: params.modal_width || null,
					types: ['null','number']
				},


				transition: {
					default: params.transition || null,
					types: ['null','string']
				}
			});


		/*	modal_available_flag
		------------------------------------------*/
			self.modal_available_flag = new awf.__.FeatureToggler.Flag($(window).width() > self.modal_width + 20);

			$(window)
				.off('resize.modal_available_flag')
				.on('resize.modal_available_flag', function () {
					if (self.modal_available_flag) {
						self.modal_available_flag.setValue($(window).width() > self.modal_width + 20);
					}
				});


		// Call the parent constructor
		awf.__.BaseModel.apply(self, arguments);

		console.groupEnd();
	}

	_.extend(Experience.prototype, {

		/**
		 * Assigns awf.page.layout to this experience's layout, then tells it to render
		 * @memberOf awf.__.Experience
		 * @instance
		 * @return {object} this (chainable)
		 */
		setup: function () {
			var self = this;

			console.group('Rendering layout:', this.layout.type);
			awf.drag_handler = new awf.__.DragHandler(awf.page.$el);
			awf.page.layout = this.layout;
			awf.page.layout.render();
			console.groupEnd(); // for 'Initializing cogs for new experience'

			return this;
		},


		/**
		 * Destroys all cog instances that may have been created for this instance
		 * @memberOf awf.__.Experience
		 * @instance
		 * @return {object} this (chainable)
		 */
		teardown: function () {

			/*	Tearing down cogs
			------------------------------------------*/
				console.group('Destroying experience: ', this.id);

				console.log('Turning off drag_handler');
				awf.drag_handler.off();

				console.group('Tearing down cogs');
				_.forEach(this.cogs, function (cog, id) {
					console.group(id);
					cog.teardown();
					console.groupEnd();
				});
				this.cogs = {};
				console.groupEnd(); // for 'Tearing down cogs'
				console.groupEnd(); // for 'Destroying experience'


			/*	Destroying Layout
			------------------------------------------*/
				console.group('Destroying old layout');
				this.layout.destroy(); // destroy it
				delete awf.page.layout; // remove pointer in `awf.page` (keep your own)
				console.groupEnd();

			return this;
		},



		/**
		 * Return an existing cog instance, or create a new one and return it. Adds it to this.cogs
		 * @memberOf awf.__.Experience
		 * @instance
		 * @param  {string|object} cog_params If a string, it will used as an object where both id and type are pulled from the string value
		 * @param {string} cog_params.id The id of the cog instance. If this is in use, the function will return the existing instance
		 * @param {string} cog_params.type The type of the cog instance. Must be found among awf.app.registered_cogs AND this.cog_types.
		 * @return {awf.__.Cog}            Either the preexisting cog with the given ID, or a new one based on ID and type
		 */
		getOrCreateCog: function (cog_params) {

			if (typeof(cog_params) == "string") {
				cog_params = {
					id: cog_params, // + '-' + _.filter(this.cogs, 'type', cog_params).length,
					type: cog_params
				};
				console.log('Converting to ', cog_params);
			}

			// Do we have it already? Return it!
			if (this.cogs[cog_params.id]) {
				return this.cogs[cog_params.id];
			}

			// Is this cog type listed against this experience?
			if ( ! _.contains(this.cog_types, cog_params.type))
				throw new Error('Cannot create cog of type `' + cog_params.type + '` for experience type `' + this.type + '`. Update the experience\'s cogs array to include `' + cog_params.type + '`.');

			// (else) Make a new one!

			// Is it a registered type?
			if ( ! (cog_params.type in awf.app.registered_cogs)) {
				throw new Error('Cannot create cog of type `' + cog_params.type + '` -- It has not been registered!');
			}

			// Include the ID with the instantiation parameters
			cog_params = _.extend({}, awf.app.registered_cogs[cog_params.type], {
				id: cog_params.id,
				type: cog_params.type
			});

			// Intantiate it!
			this.cogs[cog_params.id] = new awf.__.Cog(cog_params);

			return this.cogs[cog_params.id];
		},



		fetchPreferences: function () {
			var self = this,
				dfr = $.Deferred();

			console.time('fetch preferences');

			awf.user.authentication
				.done(function (is_authenticated) {

					if (is_authenticated) {
						var local_prefs = awf.util.getStoredObject(self.key);

						if (local_prefs) {
							console.log('--- We have local preferences!');
							console.log(local_prefs);
							self.setPreferences(local_prefs);
							dfr.resolve(self.preferences);
						} else {
							console.log('--- We do *not* have local preferences');
							dfr.reject();
						}

						self.preference_service.fetch()
							.always(function () {
								console.timeEnd('fetch preferences');
							})
							.done(function (response) {
								if (typeof(response) == 'string') {
									response = JSON.parse(response);
								}

								console.group('Construct service has finally responded! (It took ' + (self.preference_service.service.last_fetch_duration / 1000) + ' seconds)');
								console.log('    remote prefs: ', response);
								console.log('     local prefs: ', self.preferences);

								var is_same = _.isEqual(response, self.preferences);

								if (is_same) {
									console.log("They are the same");
								} else {
									awf.util.setStoredObject(self.key, response);
									awf.app.experience.postMessage('info', awf.__.Experience.messages.preference_missmatch);
								}

								console.groupEnd();

							});

					} else {
						dfr.reject();
					}

				})
				.fail(function () {
					dfr.reject();
				});

			dfr.done(function () {
				self.on('change:preferences', function (ev, new_prefs) {
					console.log('new_prefs: ', new_prefs);
					awf.util.setStoredObject(self.key, new_prefs);
				});
			});

			return dfr.promise();
		},



		extendPreferences: function (obj) {
			return this.setPreferences(_.extend({}, this.preferences, obj));
		},



		savePreferences: function () {
			return this.preference_service
				.setValue(this.preferences)
				.save();
		},


		/**
		 * Creates an instance of awf.ui.Message, and displays the message in a dedicated DOM element: `#awf-experience-message`.<br>
		 * In order for an experience to use this method fully, its layout template must have a dedicated DOM element with the id `awf-experience-message`.
		 * @param {null|string} type The type of message. Must be null, "error", "warn", "info", or "success".
		 * @param {null|string} message The message to post.
		 * @param {boolean} [show_dismiss=true] If false, the message's dismiss button will be hidden, otherwise it will be shown.
		 * @memberOf awf.__.Experience
		 * @instance
		 * @see awf.ui.Message
		 *
		 * @return {awf.ui.Message} The awf.ui.Message instance
		 *
		 * @example
		 * // a warning that stays until a user dismisses it
		 * awf.app.experience.postMessage('warn', "Please dismiss me");
		 *
		 * // information that dismisses itself after 5 seconds unless a user dismisses it manually, sooner
		 * awf.app.experience.postMessage('info', "I will go away in 5 seconds, unless you dismiss me sooner than that.").andDismissIn(5);
		 *
		 * // a success message that doesn't have a dismiss button, but will dismiss itself after 3 seconds
		 * awf.app.experience.postMessage('success', "Hello World!", false).andDismissIn(3);
		 */
		postMessage: function (type, message, show_dismiss) {

			var $container = this.layout.$el.find('#awf-experience-message');

			if ($container.length > 0) {
				return awf.util.postMessage($container, type, message, show_dismiss);
			}

			console.warn('The experience `' + this.id + '` does not have a message container.');
			return null;
		}

	});




	_.extend(Experience, {

		messages: {
			preference_missmatch: 'Your remote preference data finally loaded, and it looks like your local setup is different. When you refresh, they will match your remote settings.'
		}

	});



	/**
	 * @typedef experienceConfig
	 * @memberof awf.__.Experience
	 * @type Object
	 * @description The experienceConfig object is used to describe the configurable elements of an Experience. The configuration is used to construct new Experiences as well as to define them through [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerExperience]{@link awf.__.App.registerExperience}
	 * @property {string} id the ID of this experience (ignored by [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerExperience]{@link awf.__.App.registerExperience})
	 * @property {string} type the type of experience (ignored by [awf.app.compose]{@link awf.__.App.compose} and [awf.app.registerExperience]{@link awf.__.App.registerExperience})
	 * @property {string} [label] The experience label -- Often used in experience switchers (e.g. Left Nav)
	 * @property {string} [icon] An icon ID from the AWF icon linrary
	 * @property {string} [active_icon] An icon ID from the AWF icon library to be used when the experience is active in an experience switcher
	 * @property {string[]} cogs An array of IDs of registered cogs that will be available to the experience
	 * @property {null|number} [modal_width] When set to a number, flipped (large) cards will have a fixed width set to that number. Otherwise, the flipped cards will be responsive
	 * @property {awf.ui.Layout.layoutConfig} layout A configuration object used to create the layout for the experience
	 *
	 * @example
	 * {
	 *    "label": "Enterprise",
	 *    "icon": "awficon-enterprise-outline",
	 *    "active_icon": "awficon-enterprise",
	 *    "cogs": ["headlines","media","stock"],
	 *    "modal_width": 820, //optional `null` or `number`
	 *    "layout": {
	 *       "type": "fluid-grid",
	 *       "default_order": {
	 *          "grid": ["media","stock"]
	 *       }
	 *    }
	 * }
	 */


/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = Map;


	function Map (cols) {
		var self = this,
			map = {};

		self.height = 0;
		self.width = 0;
		cols = cols || 1;


		
			function outsideOurColumns(x,y, w, h) {
				w = w || 1;
				h = h || 1;
				if (x+w > cols)
					return true;
				else
					return false;
			}

		self.outsideOurColumns =  outsideOurColumns;
		self.claimOrUnclaim = claimOrUnclaim;


			function claimOrUnclaim (x,y,claim_boolean,w,h) {
				w = w || 1;
				h = h || 1;

				if (w < 1)
					throw new Error("Widths cannot be less than 1");

				if (h < 1)
					throw new Error("Heights cannot be less than 1");

				if (x+w > cols)
					throw new Error("Cannot claim or unclaim area outside column domain x:" + x + ", w:" + w + ", cols:" + cols);

				/* for every column we want to mark */
				for (var wi=0; wi<w; wi++) {
					//make new column sub associative if need be.
					map[x+wi] = map[x+wi] || {};

					//for every row value we want to claim, set it to be our mark boolean value.
					for (var hi=0; hi<h; hi++)
						map[x+wi][y+hi] = claim_boolean;
				}

				//adjust our map's width and height in case we expanded it.
				self.width = Math.max(self.width, x+w);
				self.height = Math.max(self.height, y+h);
			}

		self.claim = claim;


			function claim(x,y,w,h) {
				if (_.isObject(x)) {
					y = x.row;
					w = x.col_span;
					h = x.row_span;
					x = x.col;
				}
				self.claimOrUnclaim(x,y,true,w,h);
			}

		self.unclaim = unclaim;


			function unclaim (x,y,w,h) {
				self.claimOrUnclaim(x,y,false,w,h);
			}


		self.getCols = function () { return cols; };

		self.setCols = setCols;

		function setCols (new_cols) {
			cols = new_cols;
		}

		self.claimed = claimed;

			function claimed (x,y,w,h) {
				w = w || 1;
				h = h || 1;

				if (x+w > cols)
					return true;

				for (var wi=0; wi<w; wi++) {
					map[x+wi] = map[x+wi] || {};
					for (var hi=0; hi<h; hi++) {
						if (map[x+wi][y+hi])
							return true;
					}
				}
				return false;
			}

			self.findSlot = findSlot;

			function findSlot (w,h) {
				if (w > cols)
					throw new Error("Cannot find slot for item wider than allowed cols");

				var x = -1,
					y = 0,
					found = false;

				while ( ! found) {
					if (x < cols-w)
						x++;
					else {
						y++;
						x = 0;
					}

					found = ! claimed(x,y,w,h);
				}

				return {
					x: x,
					y: y
				};
			}

			self.findAndClaimSlot = findAndClaimSlot;

			function findAndClaimSlot (w,h) {
				var slot = findSlot(w,h);
				claim(slot.x, slot.y, w, h);
				return slot;
			}

			self.reset = reset;
			function reset () {
				map = {};
				self.height = 0;
				self.width = 0;
			}

			self.toString = function () {
				var rows = [];
				for (var hi=0; hi<self.height; hi++) {
					rows.push('');
					for (var wi=0; wi<self.width; wi++)
						rows[hi] += claimed(wi,hi) ? 'X' : '-';
				}
				return rows.join('\n');
			};
	}


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	awf.__.FeatureToggler = __webpack_require__(81);
	__webpack_require__(83);


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = FeatureToggler;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);



	/*	Constructor
	------------------------------------------*/
		/**
		 * @class FeatureToggler
		 * @memberOf awf.__
		 * @requires jQuery
		 * @requires lodash
		 *
		 * @description This class provides run time feature toggling capabilities.
		 *
		 * @property {Object|null} data The JSON data loaded from init
		 *
		 * @example
		 *  // To understand how it works on its own, see the rest of the examples
		 *  // Creating a simple instance
		 *  var my_feature_toggles = new FeatureToggler();
		 *  my_feature_toggles.init("a_features_file.json");
		 *
		 * // The JSON content may look like this:
		 * {
		 *	"terran": true,
		 *	"zerg": false,
		 *	"protos": true,
		 *	"descriptions": true,
		 *	"description-fade-in": true
		 * }
		 *
		 * @example
		 * // Once initialized and loaded, a check may be done like this:
		 * if (my_feature_toggles.isActive("terran")) {
		 * 	// do something because the "terran" feature is enabled
		 * }
		 *
		 */
		function FeatureToggler () {
			this._feature_data = null;
			this._stylesheet = null;
			this.service = new awf.__.AjaxService({
				cache: false,
				dataType: 'json'
			});
		}








	/*	Prototype Methds
	------------------------------------------*/
		_.extend(FeatureToggler.prototype, {

			/**
			 * Pass in a filename to a JSON file of feature toggles
			 * @instance
			 * @memberOf awf.__.FeatureToggler
			 * @param  {String} filename A reference to the JSON file to load
			 * @return {$.Deferred} ajax promise
			 */
			init: function (filename) {
				var self = this;

				if (filename === undefined)
					throw new Error("Cannot initialize FeatureToggler with no filename.");

				this.service.ajax_params.url = filename;

				var dfr = $.Deferred();

				this.service.fetch()
					.done(function (response) {
						self._feature_data = response;
						try {
							self.apply();
							dfr.resolve();
						} catch (er) {
							dfr.reject(er);
							// console.warn(er);
							// dfr.resolve();
							throw er;
						}
					})
					.fail(dfr.reject);

				return dfr.promise();
			},



			getEndpoint: function (key) {
				// if there's no key defined, return false
				if (key === undefined)
					throw new Error("Cannot check if feature is active -- No key was given.");

				// we have a key, and we have data, so return a normalized value
				var endpoint = _.get(this._feature_data, key);

				if (_.isObject(endpoint) && '_' in endpoint) {
					endpoint = endpoint._;
				}

				return endpoint;
			},


			getEndpoints: function (val) {
				var self = this,
					endpoint_paths = [];

				// Convert individual pieces to `true` or `false`
				_.forEach(val.split(/\||\&|\(|\)|\!| /), function (item) {
					if (item.length > 0) {
						endpoint_paths.push(item);
					}
				});

				return _.map(_.unique(endpoint_paths), function (endpoint_path) {
					return self.getEndpoint(endpoint_path);
				});
			},


			/**
			 * Runs the callback with the current value immediately, and will call it again everytime it changes.
			 * @instance
			 * @memberOf awf.__.FeatureToggler
			 * @param  {String}   key      A path (or combination of flags) to the feature flag endpoint.
			 * @param  {Function} callback A function that is called immediately and every time the featre flag value changes.
			 * @return {Object}            this (chainable)
			 */
			runAndWatch: function (key, callback) {

				var self = this,
					flag = self.watch(key);

				callback.call(self, flag.value);

				flag.on('change:value', function (ev, new_val, old_val) {
					callback.call(self, new_val, old_val);
				});

				return this;

			},


			_checkKey: function (key, _silent) {

				var endpoint = this.getEndpoint(key);

				switch (typeof endpoint) {
					case "undefined":
						return false;

					case "boolean":
						return endpoint;

					case "object":
						var keys = _.keys(endpoint),
							len = keys.length;
						if (len === 0)
							return false;

						var i = -1,
							ret = true;
						while (++i<len && ret) {
							var k = keys[i],
								v = endpoint[k];

							if (k in FeatureToggler.handlers) {
								if ('check' in FeatureToggler.handlers[k]) {
									var val = false;
									try {
										val = FeatureToggler.handlers[k].check(v);
									} catch (er) {
										console.warn('FeatureToggler handler failed: `' + k + '`');
										throw er;
									}
									if ( ! val) {
										return false;
									}
								} else {
									throw new Error('FeatureToggler handler `' + k + '` has no `check` method defined.');
								}
							} else {
								if ( ! _silent)
									console.warn("The feature toggle check on '" + key + "' needs to be handled by '" + k + "', but that type has not been adapted.");
								return false;
							}
						}

						return true;

					default:
						return false;
				}
			},





			/**
			 * Returns the current state of the feature.
			 * Note -- if the user data has not yet loaded, then user-based features are subject to change values
			 * @instance
			 * @param  {String} key A path (or combination of flags) to the feature flag endpoint.
			 * @return {Boolean}
			 * @memberOf awf.__.FeatureToggler
			 */
			isActive: function (val, _silent) {

				var self = this,
					orig_val = val,
					awfEval = eval; // huehuehuehue...

				// Convert individual pieces to `true` or `false`
				_.forEach(val.split(/\||\&|\(|\)|\!| /), function (item) {
					if (item.length > 0) {
						val = val.replace(item, self._checkKey(item, _silent) ? 'true' : 'false');
					}
				});

				// Safety check
				var arr = _.unique(val.split(/\||\&|\(|\)|\!|true|false| /));
				if (arr.length != 1 || (arr.length == 1 && arr[0] !== '')) {
					throw new Error('Cannot parse flag; invalid string: `' + orig_val + '`');
				}

				//console.log(orig_val + ': ', val);

				// return the evaluated
				return awfEval(val) > 0;
			},






			/**
			 * Returns an object that keeps the value of the feature flag, as well as a `change:value` event.
			 * @instance
			 * @memberOf awf.__.FeatureToggler
			 * @param  {String}	key						A path (or combination of flags) to the feature flag endpoint.
			 * @return {awf.__.FeatureToggler.Flag} 	An object with `value` attribute and `on('chage:value', callback)` events.
			 */
			watch: function (key) {

				var self = this,

				// get current value
					bool = this.isActive(key),

				// create an instance of Flag with current value
					flag = new FeatureToggler.Flag(bool),

				// if provided, call/bind setupChangeHandler to flag
					ping = _.throttle(function () {

							//console.log('ping was called with ' + arguments.length + ' arguments');

							if (arguments.length === 0) {
								flag.setValue(self.isActive(key));
							} else {
								flag.setValue( !! arguments[0]);
							}
						},
						10,
						{
							leading: false
						}),

				// get the endpoint
					endpoints = this.getEndpoints(key);

				_.forEach(endpoints, function (endpoint) {

					// if the endpoint is an object, loop through the keys as handlers
					if (typeof(endpoint) == "object") {

						_.forEach(endpoint, function (v, k) {
							if (k in FeatureToggler.handlers) {
								if ('setupChangeHandler' in FeatureToggler.handlers[k]) {
									try {
										FeatureToggler.handlers[k].setupChangeHandler(ping, v);
									} catch (er) {
										console.warn('FeatureToggler handler `' + k + '` setupChangeHandler failed');
										throw er;
									}
								}
							} else {
								if ( ! _silent) {
									console.warn("The feature toggle watch on '" + key + "' needs to be handled by '" + k + "', but that type has not been adapted.");
								}
							}
						});

					}
				});

				return flag;

			},







			/**
			 * Applies the current data into a stylesheet and add it to the head.
			 * @instance
			 * @return {String} The content of the stylesheet -- only useful for debugging.
			 * @memberOf awf.__.FeatureToggler
			 */
			apply: function () {
				if ( ! this._stylesheet) {
					this._stylesheet = new awf.ui.Stylesheet();
				}

				var css = this.css();
				this._stylesheet.css(css);
				return css;
			},








			css: function () {

				var content = null,
					self = this;

				if (this._feature_data === null) {
					content = ''; //'[data-feature] { display: none; }';
				} else {
					var items = _.map(self._featureKeys(), function (key) {
						return '[data-feature="' + ( self._checkKey(key, true) ? '!' : '' ) + key + '"]';
					});

					content = items.join(',') + ' { display:none!important; }';
				}

				return content;
			},






			hasKey: function (key) {
				return _.get(this._feature_data, key) !== undefined;
			},







			_featureKeys: function (cwd) {
				var self = this,
					obj = this._feature_data;

				if (cwd) {
					obj = _.get(obj,cwd);
				} else {
					cwd = [];
				}

				var keys = _.keys(obj);

				_.forEach(keys, function (key) {
					var sub_obj = obj[key];
					if (_.isObject(sub_obj) && ! _.isArray(sub_obj)) {
						keys = keys.concat(self._featureKeys(cwd.concat(key)));
					}
				});

				return _.map(keys, function (key) {
					if (cwd.length === 0)
						return key;
					else
						return (cwd.concat([key])).join('.');
				});
			}



		});













	/*	Static Properties / Methods
	------------------------------------------*/
		_.extend(FeatureToggler, {

			Flag: __webpack_require__(82),




			/**
			 * Holds all handlers for non-boolean values
			 * @type {Object}
			 * @memberOf awf.__.FeatureToggler
			 *
			 * @example
			 * // This example shows how to add a handler for user email
			 *
			 * // If this is the config JSON object:
			 * {
			 * 	"feature-one": true,
			 * 	"feature-two": {
			 * 		email: "hansenlj@us.ibm.com"
			 * 	},
			 * 	"feature-three": {
			 * 		email: [
			 * 			"hansenlj@us.ibm.com",
			 * 			"sblack@us.ibm.com"
			 * 		]
			 * 	}
			 * }
			 *
			 * // The obj parameter is the value in the config file after 'email'
			 *
			 * awf.__.FeatureToggler.handlers.email = function (obj) {
			 * 	if ( ! (awf.user && awf.user.is_authenticated))
			 * 		return false;
			 *
			 * 	var email = _.get(awf.user, 'info.email');
			 *
			 * 	switch (typeof obj) {
			 * 		case "string":
			 * 			return obj === email;
			 *
			 * 		case "object":
			 * 			return _.contains(obj, email);
			 *
			 * 		default:
			 * 			return null;
			 * 	}
			 * };
			 *
			 *
			 * // Checking `feature-one` never calls this handler, because email is not involved
			 * awf.flags.isActive('feature-one');
			 *
			 * // Checking `feature-two` calls the handler, passing "hansenlj@us.ibm.com"
			 * // If awf.user.info.email is "hansenlj@us.ibm.com", this will return true. (otherwise, false)
			 * awf.flags.isActive('feature-two');
			 *
			 * // Checking `feature-three` calls the handler, passing ["hansenlj@us.ibm.com","sblack@us.ibm.com"]
			 * // If awf.user.info.email is either "hansenlj@us.ibm.com" or "sblack@us.ibm.com", this will return true. (otherwise, false)
			 * awf.flags.isActive('feature-three');
			 *
			 */
			handlers: {}

		});








/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = Flag;


	/*	Constructor
	------------------------------------------*/
		awf.util.use(awf.__.BaseModel).toCreate(Flag);
		
		/**
		 * @class Flag
		 * @description	An object with a boolean value and change events.
		 * @memberOf awf.__.FeatureToggler
		 * 
		 * @param {Boolean} value The initial value for the object. Default: false
		 * @fires change:value
		 * 
		 * @property {Boolean}	value		The current value of the object
		 */
		function Flag (value) {
			awf.__.BaseModel.call(this);

			var params = (arguments.length > 0) ? {value:value} : {};
			awf.util.mixin.properties(this, params, {
				/**
				 * @name setValue
				 * @memberof Flag
				 * @function
				 * @instance
				 * @param {Boolean} value Sets the new value for `value`
				 * @fires change:value
				 * @return {Object} self chainable
				 */
				value: {
					"default": false,
					"types": ["boolean"]
				}
			});
		}


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(Flag.prototype, {

			runAndWatch: function (fn) {

				fn.call(this, this.value);

				this.on('change:value', function (ev, val) {
					fn.call(this, val);
				});

			}

		});


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84);


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);

	_.extend(awf.__.FeatureToggler.handlers, {

		day: {
			check: function (obj) {

				var now = new Date(),
					day = now.getDay();

				switch (typeof obj) {
					case "number":
						return day === obj;

					case "object":
						return _.contains(obj, day);
				}

			},

			setupChangeHandler: function (ping) {

				var now = new Date(),
					target = new Date();
				target.setHours(0);
				target.setMinutes(0);
				target.setSeconds(0);
				target.setMilliseconds(0);
				target.setDate(target.getDate() + 1);

				var delta = target - now;
				setTimeout(function () {
					ping();

					// Every 24 hours, run the check again
					setInterval(ping, 1000 * 60 * 60 * 24);
				}, delta + 10);

			}
		},


		five_second_rule: {
			check: function (bool) {

				var now = new Date();
				return ((Math.floor(now.getSeconds() / 5) % 2) === 0) === bool;

			},
			setupChangeHandler: function (ping) {

				//console.log('Stepping into the five_second_rule setupChangeHandler');

				var now = new Date(),
					target = new Date();

				var seconds = ((Math.floor(target.getSeconds() / 5) + 1) * 5);

				target.setSeconds(seconds);
				target.setMilliseconds(0);

				var delta = target - now;
				setTimeout(function () {
					ping();

					// Every 5 seconds, run the check again
					setInterval(ping, 1000 * 5);
				}, delta);
			}
		},


		three_second_rule: {
			check: function (bool) {

				var now = new Date();
				return ((Math.floor(now.getSeconds() / 3) % 2) === 0) === bool;

			},
			setupChangeHandler: function (ping) {

				//console.log('Stepping into the three_second_rule setupChangeHandler');

				var now = new Date(),
					target = new Date();

				var seconds = ((Math.floor(target.getSeconds() / 3) + 1) * 3);

				target.setSeconds(seconds);
				target.setMilliseconds(0);

				var delta = target - now;
				setTimeout(function () {
					ping();

					// Every 3 seconds, run the check again
					setInterval(ping, 1000 * 3);
				}, delta);
			}
		},


		month: {
			check: function (obj) {
				var now = new Date(),
					month = now.getMonth();

				switch (typeof obj) {
					case "number":
						return month === obj;

					case "object":
						return _.contains(obj, month);
				}
			},

			setupChangeHandler: function (ping) {
				
				function setUpNextTimeout () {
					var now = new Date(),
						target = new Date();
					target.setHours(0);
					target.setMinutes(0);
					target.setSeconds(0);
					target.setMilliseconds(0);

					target.setDate(1);
					target.setMonth(target.getMonth() + 1);

					var delta = target - now;
					setTimeout(function () {
						ping();
						setUpNextTimeout(); // cause that's gonna happen.
					}, delta);
					
				}

				setUpNextTimeout();
			}
		},


		morning: {
			check: function (bool) {
				var now = new Date(),
					ret = now.getHours() < 12;
				return bool === ret;
			},

			setupChangeHandler: function (ping) {
				
				var now = new Date(),
					target = new Date();

				if (now.getHours() < 12) {
					target.setHours(12);
				} else {
					target.setHours(0);
					target.setDate(target.getDate() + 1);
				}
				target.setMinutes(0);
				target.setSeconds(0);
				target.setMilliseconds(0);

				var delta = target - now;
				setTimeout(function () {
					ping();
					// Every 12 hours, run the check again
					setInterval(ping, 1000 * 60 * 60 * 12);
				}, delta + 10);
			
			}
		},


		afternoon: {
			check: function (bool) {
				var now = new Date(),
					ret = now.getHours() > 11;
				return bool === ret;
			},

			setupChangeHandler: function (ping) {
				
				var now = new Date(),
					target = new Date();

				if (now.getHours() < 12) {
					target.setHours(12);
				} else {
					target.setHours(0);
					target.setDate(target.getDate() + 1);
				}
				target.setMinutes(0);
				target.setSeconds(0);
				target.setMilliseconds(0);

				var delta = target - now;
				setTimeout(function () {
					ping();
					// Every 12 hours, run the check again
					setInterval(ping, 1000 * 60 * 60 * 12);
				}, delta + 10);
			
			}
		},


		date: {
			check: function (obj) {
				var now = new Date(),
					after = new Date(obj.after),
					before = new Date(obj.before);

				// only have `after`
				if ('after' in obj && ! ('before' in obj)) {
					if (now > after) {
						return true;
					}

				// only have `before`
				} else if ('before' in obj && ! ('after' in obj)) {
					if (now < before) {
						return true;
					}


				// have `after` and `before`
				} else if ('after' in obj && 'before' in obj) {
					// inside the dates
					if (after < before) {
						if (after < now && now < before) {
							return true;
						} else {
							return false;
						}

					// outside the dates
					} else {
						if (now < before || after < now) {
							return true;
						} else {
							return false;
						}
					}
				}

				return false;
			},

			setupChangeHandler: function (ping, obj) {

				var now = new Date(),
					after = new Date(obj.after),
					before = new Date(obj.before);

				if (now < before) {
					setTimeout(ping, before - now);
				}

				if (now < after) {
					setTimeout(ping, after - now);
				}

			}
		}

	});


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	awf.__.Search                = __webpack_require__(86);

	awf.__.SearchChannel         = __webpack_require__(87);
	awf.__.LocalSearchChannel    = __webpack_require__(88);

	awf.__.ResultsCollectionItem = __webpack_require__(89);
	awf.__.ResultsCollection     = __webpack_require__(90);

	_.extend(awf, __webpack_require__(91));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Search;

	var $ = __webpack_require__(4),
		Parent = awf.__.BaseModel;

	awf.util.use(Parent).toCreate(Search);

	/*	Constructor
	------------------------------------------*/
		/**
		 * Search
		 * @class
		 * @memberOf awf.__
		 *
		 * @param {object} params
		 * @param {string} params.term The starting term. This is never expected to be used, but technically available.
		 */
		function Search (params) {
			params = params || {};

			this.channels = {};
			// this.buckets = new awf.__.Collection();

			this.results = new awf.__.ResultsCollection();

			awf.util.mixin.properties(this, params, {

				term: {
					default: null,
					types: ['null','string']
				}

			});

			Parent.apply(this, arguments);
		}


	/*	Prototype methods
	------------------------------------------*/
		_.extend(Search.prototype, {

			//addChannel -- defined in channel.js

			/**
			 * Removes a channel from search.
			 * @instance
			 * @memberOf awf.__.Search
			 *
			 * @param  {string} id The id of the channel to be removed
			 * @return {awf.__.SearchChannel} The channel that was removed
			 */
			removeChannel: function (id) {
				var channel = this.channels[id];

				// todo: remove any active results from this channel
				delete this.channels[id];

				return channel;
			},


			/**
			 * Queries all channels with the given term
			 * @instance
			 * @memberOf awf.__.Search
			 *
			 * @param  {string|null} term The term to search. Or null, if reseting
			 * @return {$.Deferred}      This promise resolves when all channels are resolved or rejected their queries.
			 */
			query: function (term) {

				var self = this,
					dfr = $.Deferred();

				this.setTerm(term);

				if (term === null || term === "") {

					this.results.removeAllItems();
					dfr.resolve('empty');

				} else if (term.indexOf('//') === 0) {

					this.results.removeAllItems();
					console.info('Oooo.. issueing fancy commands from search are we?? Nice.');
					dfr.resolve('custom');

				} else {

					var goal = _.keys(this.channels).length,
						complete = 0;

					if (goal === 0) {
						dfr.resolve('no channels');
					}

					_.forEach(this.channels, function (channel) {
						channel.query(term)
							.done(function (response) {
								if (response.term === self.term) {
									self.results.addItem(response.results);
								} else {
									console.warn('Query result term missmatch. current: `' + self.term + '` found: `' + response.term + '`');
								}
							})
							.fail(function (response) {
								if (response) {
									if ('msg' in response)
										console.warn(response.msg);

									if ('error' in response)
										console.error(response.error);
								}
							})
							.always(function () {
								complete++;
								if (complete == goal)
									dfr.resolve('results');
							});
					});

				}

				return dfr.promise();
			}

		});



/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = SearchChannel;

	var $ = __webpack_require__(4),
		Parent = awf.__.BaseModel;

	awf.util.use(Parent).toCreate(SearchChannel);

	/**
	 * The base class for a search channel
	 * @class
	 * @memberOf awf.__
	 * @extends {awf.__.BaseModel}
	 *
	 * @requires jQuery
	 *
	 * @param {object} params The parameters for the search channel
	 * @param {function|null} params.onQuery The function to run when this channel receives a term to query
	 * @param {string|null} [params.flag] The feature flag for this channel. Checked before each query.
	 * @param {string|null} [params.bucket] The default bucket id for results that come from this channel. Note: Any result may choose to override its own bucket.
	 * @param {string} [params.result_type] The default type for results that come from this channel. Note: Any result may choose to override its own type.
	 *
	 * @property {function|null} onQuery The function to run when this channel receives a term to query
	 * @property {string|null} flag The feature flag for this channel. Checked before each query.
	 * @property {string|null} bucket The default bucket id for results that come from this channel. Note: Any result may choose to override its own bucket.
	 * @property {string} result_type The default type for results that come from this channel. Note: Any result may choose to override its own type.
	 *
	 */
	function SearchChannel (params) {

		params = params || {};

		this.onQuery = params.onQuery || this.onQuery || null;
		this.flag = params.flag || this.flag || null;
		this.bucket = params.bucket || this.bucket || null;
		this.result_type = params.result_type || this.result_type || 'default';

		Parent.apply(this, arguments);
	}



	_.extend(SearchChannel.prototype, {

		/**
		 * This function is called by the search engine, which will do some pre-checking, then hand it off to the onQuery method.
		 * @instance
		 * @memberOf awf.__.SearchChannel
		 *
		 * @param  {string} term The term to be searched
		 *
		 * @return {$.Deferred} This will be resolved with an object with term and results, or it will be rejected on query failure or feature-toggle disablement.
		 */
		query: function (term) {

			var self = this,
				dfr = $.Deferred();

			if ( ! this.flag || (this.flag && awf.flags.isActive(this.flag))) {

				if (this.onQuery) {

					try {

						// console.log('Channel `' + this.id + '` is querying `' + term + '`');

						this.onQuery.call(this, term)
							.done(function (results) {

								//console.log('results from `' + self.id + '`: ', results);

								_.forEach(results, function (result) {
									result.bucket = result.bucket || self.bucket;
									result.type = result.type || self.result_type;
									result.channel = self.id;
									// result.term = term;
								});

								dfr.resolve({
									term: term,
									results: results
								});
							})
							.fail(dfr.reject);
					} catch (er) {
						dfr.reject({
							msg: 'Channel `' + self.id + '` failed during onQuery call',
							error: er
						});
					}

				} else {
					dfr.reject({
						error: new Error('No onQuery function defined')
					});
				}

			} else {
				dfr.reject({
					msg: 'Feature flagging has disabled this channel'
				});
			}

			return dfr.promise();
		}

	});




	_.extend(awf.__.Search.prototype, {

		/**
		 * Adds an awf.__.SearchChannel to an instance of awf.__.Search
		 * @instance
		 * @memberOf awf.__.Search
		 *
		 * @param {string} id A unique string to identify the search channel
		 * @param {awf.__.SearchChannel|object} channel If an instance of
		 * awf.__.SearchChannel, it will be added directly, otherwise it will
		 * be used as the parameters by which a new channel will be instantiated.
		 *
		 * @return {object} this (chainable)
		 */
		addChannel: function (id, channel) {
			if (id in this.channels) {
				throw new Error('Cannot register search channel. ID is taken: `' + id + '`');
			}

			if ( ! (channel instanceof awf.__.SearchChannel)) {
				channel = new awf.__.SearchChannel(channel);
			}

			channel.id = id;

			this.channels[id] = channel;

			return this;
		}

	});


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = LocalSearchChannel;

	var $ = __webpack_require__(4),
		Parent = awf.__.SearchChannel;

	awf.util.use(Parent).toCreate(LocalSearchChannel);


	/*	Constructor
	------------------------------------------*/
		/**
		 * Local Search Channel
		 * @class
		 * @memberOf awf.__
		 * @extends {awf.__.SearchChannel}
		 *
		 * @param {object} params The parameters of the LocalSearchChannel
		 * @param {string} params.src						The URL of the data (e.g.: data.json)
		 * @param {string|function} [params.map]			If a string, it will resolve to the function stored at LocalSearchChannel.mapping_methods[map]. If a function, it will use it.
		 * @param {string} [params.callback]				If undefined, it will make an ajax request. Otherwise it will do jsonp with the given callback.
		 * @param {string|function} [params.worker_type]	If a string, it will resolve to the Class stored at LocalSearchChannel.workers[worker_type].
		 * @param {number} [params.limit]					The maximum number of results that this channel will return
		 *
		 * @property {function} map				A function that lets the incoming JSON data to be mapped to the correct format.
		 * @property {string} callback			If defined, a CallBackService will drive the JSON lookup. Otherwise an AjaxService will be used.
		 * @property {null|Error} error			This will remain null unless the JSON lookup fails, at which time this will become the Error response.
		 * @property {string} worker_type		Default: 'default' - Will be used when looking up awf.__.LocalSearchChannel.workers[worker_type]
		 * @property {null|number} limit		When not null, the returned results will be limited to this amount, simply only accepting the first n items.
		 * @property {awf.__.CallbackService|awf.__.AjaxService}	service This will retrieve the data
		 * @property {awf.__.LocalSearchWorker} worker This object will be given data and will do all the heavy lifting in its web worker.
		 *
		 */
		function LocalSearchChannel (params) {
			params = params || {};

			var self = this;

			self.map = params.map || self.map || null;
			self.src = params.src || self.src || null;
			self.callback = params.callback || self.callback || null;
			self.error = null;
			self.worker_type = params.worker_type || self.worker_type || null;
			self.limit = params.limit || self.limit || null;

			self.service = new awf.__[ self.callback ? 'CallbackService' : 'AjaxService' ]({
				url: self.src,
				callback: self.callback,
				dataType: self.callback ? 'script' : 'json'
			});

			var type = self.worker_type || 'default';
			if ( ! LocalSearchChannel.workers[type]) {
				throw new Error('LocalSearchChannel does not have worker type `' + type + '`.');
			}

			self.worker = new LocalSearchChannel.workers[type]({
				data: self._maybeMapData(params.data) || self.data || null
			});

			Parent.call(self, params);

			self.load();
		}





	/*	Prototype Methods
	------------------------------------------*/
		_.extend(LocalSearchChannel.prototype, {

			/**
			 * Updates this.data and this.worker.data
			 * @instance
			 * @memberOf awf.__.LocalSearchChannel
			 *
			 * @param {object} data The data to set
			 *
			 * @return {object} this (chainable)
			 * @fires this#change:data passing new and old values
			 */
			setData: function (data) {
				var self = this,
					old_data = _.cloneDeep(self.data);

				data = data || null;

				self.data = data;

				self.worker.setData(self._maybeMapData(data))
					.done(function (dataset_response) {
						self.triggerHandler('change:data', [data, old_data]);
					})
					.fail(function (er) {
						console.warn('setData failed');
						console.error(er);
					});

				return self;
			},

			/**
			 * A helper method that will map raw data that is passed to it, using the mapping method
			 * stored in this.map
			 * @instance
			 * @memberOf awf.__.LocalSearchChannel
			 *
			 * @param {object} data The raw data to map
			 *
			 * @return {null|object} If no data passed, the method returns `null`.<br>
			 * If data is passed, but this.map is `null` or `undefined`, the method returns the passed data as it was given.<br>
			 * If data is passed, but this.map is not a valid mapping method or function, the method returns `null`.
			 * If data is passed, but the mapping function fails, the method returns `null`.
			 * If data is passed and the mapping function succeeds, the method returns the mapped data.
			 */
			_maybeMapData: function (data) {
				var map = this.map;

				if (data) {
					if (map) {
						if (typeof(map) == "string") {
							if (map in LocalSearchChannel.mapping_methods) {
								map = LocalSearchChannel.mapping_methods[map];
							} else {
								console.warn('mapping method `' + map + '` is not defined');
								return null;
							}
						}

						try {
							var mapped_data = _.map(data, map);
							return mapped_data;
						} catch (er) {
							console.warn('mapping function failed');
							return null;
						}
					} else {
						return data;
					}
				} else {
					return null;
				}
			},

			/**
			 * Loads the data as described during instantiation. Once loaded, this.data will match the response. If load fails, this.error will become the error.
			 * @instance
			 * @memberOf awf.__.LocalSearchChannel
			 *
			 * @return {$.Deferred} A promise that will resolve with the response, or reject with a meaningful failure message
			 */
			load: function () {
				var self = this,
					dfr = $.Deferred();

				if ( ! this.service.ajax_params.url) {
					dfr.reject('no url');
					return dfr.promise();
				}

				this.service.fetch()
					.done(function (response) {
						var map = self.map;

						if (map) {

							if (typeof(map) == "string") {
								if (map in LocalSearchChannel.mapping_methods) {
									map = LocalSearchChannel.mapping_methods[map];
								} else {
									dfr.reject({
										msg: 'mapping method `' + map + '` is not defined'
									});
								}
							}

							try {
								response = _.map(response, map);
							} catch (er) {
								dfr.reject({
									msg: 'mapping function failed',
									error: er
								});
							}
						}

						dfr.resolve(response);
					})
					.fail(function (error) {
						self.error = error;
						dfr.reject({
							msg: 'service failed to load',
							error: error
						});
					});

				return dfr
					.done(function (response) {
						//console.log('setting worker data to this response: ', response);
						self.worker.setData(response)
							.done(function (dataset_response) {
								//console.log('setdata_response for `' + self.service.ajax_params.url + '`: ', dataset_response);
							})
							.fail(function (er) {
								console.warn('setData failed');
								console.error(er);
							});
					})
					.promise();
			},

			/**
			 * Uses the given (or referenced) query_method to look through the results
			 * @instance
			 * @memberOf awf.__.LocalSearchChannel
			 *
			 * @param  {string} term The term to query the data with.
			 *
			 * @return {$.Deferred} Resolves/rejects with the given query_method, or may be rejected sooner if other issues arise.
			 */
			onQuery: function (term) {
				var self = this,
					dfr = $.Deferred();

				if (this.data === null) {
					dfr.reject({
						msg: 'no data'
					});
				} else if (this.error) {
					dfr.reject({
						msg: 'load error',
						er: self.error
					});
				} else {

					try {

						self.worker.query(term)
							.done(function (results) {

								if (self.limit) {
									results = results.slice(0, self.limit);
								}

								dfr.resolve(results);
							})
							.fail(function (er) {
								dfr.reject({
									msg: 'worker query failed',
									er: er
								});
							});

					} catch (er) {
						dfr.reject({
							msg: 'onQuery failed',
							error: er
						});
					}
				}

				return dfr.promise();
			}

		});



	/*	Static Methods
	------------------------------------------*/
		_.extend(LocalSearchChannel, {

			/**
			 * The extension point for more worker types. Once stored here, they can be referenced by any LocalSearchChannel instance via string.
			 * @memberOf awf.__.LocalSearchChannel
			 * @type {Object}
			 */
			workers: {
				default: awf.__.LocalSearchWorker
			},


			/**
			 * The extension point for saving more mapping_methods. Once stored here, they can be referenced by any LocalSearchChannel instance via string.
			 * @memberOf awf.__.LocalSearchChannel
			 * @type {Object}
			 */
			mapping_methods: {

				default: function (result) {
					return {
						data: result
					};
				}

			}


		});







	_.extend(awf.__.Search.prototype, {

		/**
		 * Adds an instance of LocalSeachChannel to this
		 * @instance
		 * @memberOf awf.__.Search
		 *
		 * @param {string} id A unique id for the instance of the channel
		 * @param {object|awf.__.SearchChannel} channel Either an instance of Channel, or the parameters needed to initiate a new one.
		 *
		 * @return {object} this (chainable)
		 */
		addLocalChannel: function (id, channel) {
			if (id in this.channels) {
				throw new Error('Cannot register local search channel. ID is taken: `' + id + '`');
			}

			if ( ! (channel instanceof awf.__.SearchChannel)) {
				channel = new awf.__.LocalSearchChannel(channel);
			}

			channel.id = id;

			this.channels[id] = channel;

			return this;
		}

	});





/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = ResultsCollectionItem;

	var Parent = awf.__.CollectionItem;

	awf.util.use(Parent).toCreate(ResultsCollectionItem);

	/*	Constructor
	------------------------------------------*/
		
		/**
		 * A single result. Holds the id, type, channel, bucket, and data for the result
		 *
		 * @class
		 * @memberOf awf.__
		 * @extends {awf.__.CollectionItem}
		 *
		 * @param {object} params
		 * @param {null|string} [params.type] The type of result. This will eventually result in showing different kinds of results in the UI
		 * @param {null|string} [params.channel] The channel that the result came from
		 * @param {null|string} [params.bucket] The bucket that the result should be shown in
		 * @param {null|object} [params.data] The data for the result, e.g.: title, description, url, etc.
		 *
		 * @property {string}		id			A unique ID to the result
		 * @property {null|string}	type		The type of result. This will eventually result in showing different kinds of results in the UI
		 * @property {null|string}	channel		The channel that the result came from
		 * @property {null|string}	bucket		The bucket that the result should be shown in
		 * @property {null|object}	data		The data for the result, e.g.: title, description, url, etc.
		 *
		 */
		function ResultsCollectionItem (params) {
			params = params || {};

			awf.util.mixin.properties(this, params, {

				/**
				 * @memberof awf.ui.ResultsCollectionItem
				 * @name setId
				 * @function
				 * @param  {String} val The new id
				 * @return {Object} this (chainable)
				 */
				id: {
					default: function () {
						return awf.util.randomID();
					},
					types: ['string']
				},

				/**
				 * @memberof awf.ui.ResultsCollectionItem
				 * @name setType
				 * @function
				 * @param  {String} val The new type
				 * @return {Object} this (chainable)
				 */
				type: {
					default: null,
					types: ['null','string']
				},

				/**
				 * @memberof awf.ui.ResultsCollectionItem
				 * @name setChannel
				 * @function
				 * @param  {String} val The new channel
				 * @return {Object} this (chainable)
				 */
				channel: {
					default: null,
					types: ['null','string']
				},

				/**
				 * @memberof awf.ui.ResultsCollectionItem
				 * @name setBucket
				 * @function
				 * @param  {String} val The new bucket
				 * @return {Object} this (chainable)
				 */
				bucket: {
					default: null,
					types: ['null','string']
				},

				/**
				 * @memberof awf.ui.ResultsCollectionItem
				 * @name setData
				 * @function
				 * @param  {String} val The new data
				 * @return {Object} this (chainable)
				 */
				data: {
					default: null,
					types: ['null','object']
				}

			});

			Parent.apply(this, arguments);
		}


/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = ResultsCollection;

	var Parent = awf.__.DB;

	awf.util.use(Parent).toCreate(ResultsCollection);

	/*	Constructor
	------------------------------------------*/
		/**
		 * A Results Collection
		 * @extends {awf.__.DB}
		 * @class
		 * @memberOf awf.__
		 * @param {object} params
		 */
		function ResultsCollection (params) {
			params = params || {};

			var self = this;

			this.keys = ['bucket','channel','type'];
			Parent.apply(this, arguments);
		}



	/*	Prototype Extentions
	------------------------------------------*/
		_.extend(ResultsCollection.prototype, {

			/**
			 * The item class when creating new items
			 * @instance
			 * @memberOf awf.__.ResultsCollection
			 * @type {awf.__.ResultsCollectionItem}
			 */
			Item: awf.__.ResultsCollectionItem
		});


/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = {
		registerSearchChannel: registerSearchChannel,
		registerLocalSearchChannel: registerLocalSearchChannel
	};

	/**
	 * List of registered search channels for the app
	 * @type {Object}
	 * @memberOf awf
	 *
	 * @property {object} standard List of standard channels
	 * @property {object} local List of local channels
	 * @property {awf.__.LocalSearchChannel} local.xxx A LocalSearchChannel instance
	 */
	awf.search_registry = {
		standard: {},
		local: {}
	};

	/**
	 * Adds a standard search channel to awf.search_registry.standard
	 * @function
	 * @memberOf awf
	 *
	 * @param  {string} id     the channel id
	 * @param  {object} params the channel parameters
	 * @return {object}        this
	 */
	function registerSearchChannel (id, params) {
		awf.search_registry.standard[id] = params;
		return this;
	}


	/**
	 * Adds a local search channel to awf.search_registry.local
	 * @function
	 * @memberOf awf
	 *
	 * @param  {string} id     the channel id
	 * @param  {object} params the channel parameters
	 * @return {object}        this
	 */
	function registerLocalSearchChannel (id, params) {
		awf.search_registry.local[id] = params;
		return this;
	}


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ui namespace
	 * @type {Object}
	 * @memberOf awf
	 * @name awf.ui
	 * @namespace awf.ui
	 */

	awf.ui = {};
	awf.ui.Base                         = __webpack_require__(93);

	awf.ui.Spinner                      = __webpack_require__(95);
	awf.ui.Page                         = __webpack_require__(96);
	awf.ui.Badge                        = __webpack_require__(99);
	awf.ui.FixedHeaderFooter            = __webpack_require__(101);
	awf.ui.Card                         = __webpack_require__(103);
	awf.ui.CollectionItem               = __webpack_require__(105);
	awf.ui.Collection                   = __webpack_require__(106);
	awf.ui.Dropdown                     = __webpack_require__(107);

	awf.ui.GridItem                     = __webpack_require__(109);
	awf.ui.Grid                         = __webpack_require__(111);

	awf.ui.ArrangeableGrid              = __webpack_require__(113);

	awf.ui.IconCard                     = __webpack_require__(114);
	awf.ui.ImageCircle                  = __webpack_require__(116);

	awf.ui.Layout                       = __webpack_require__(118);
	__webpack_require__(119);

	awf.ui.Masthead                     = __webpack_require__(132);
	awf.ui.MastheadUser                 = __webpack_require__(134);
	awf.ui.CustomName                   = __webpack_require__(136);
	awf.ui.FooterItem                   = __webpack_require__(138);
	awf.ui.Footer                       = __webpack_require__(140);
	awf.ui.Button                       = __webpack_require__(142);

	awf.ui.MastheadTrayCollection       = __webpack_require__(144);

	awf.ui.Message                      = __webpack_require__(147);
	awf.ui.Modal                        = __webpack_require__(149);
	awf.ui.Search                       = __webpack_require__(151);
	awf.ui.BucketItem                   = __webpack_require__(153);
	awf.ui.Bucket                       = __webpack_require__(155);
	awf.ui.Results                      = __webpack_require__(157);
	awf.ui.Settings                     = __webpack_require__(159);
	awf.ui.Sitelinks                    = __webpack_require__(161);
	awf.ui.Stylesheet                   = __webpack_require__(163);
	awf.ui.TitledCard                   = __webpack_require__(164);
	awf.ui.LargeCard                    = __webpack_require__(166);
	awf.ui.Notifications                = __webpack_require__(167);
	awf.ui.Themes                       = __webpack_require__(169);
	awf.ui.ThemeSwitcher                = __webpack_require__(171);

	awf.ui.Tray                         = __webpack_require__(175);

	awf.ui.VerticalNavItem              = __webpack_require__(177);
	awf.ui.VerticalNav                  = __webpack_require__(179);

	__webpack_require__(181);


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = BaseUI;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		loader_template = __webpack_require__(94),
		BaseObject = awf.__.BaseObject;

	use(BaseObject).toCreate(BaseUI);


	/*	Constructor
	------------------------------------------*/
		/**
		 * Base UI Component
		 * Creates a base Javascript UI pattern that can be extended.
		 * immediately calls render *unless* params.render === false
		 * @name Base
		 * @memberOf awf.ui
		 * @class
		 *
		 * @requires jQuery
		 * @requires lodash
		 *
		 * @extends {awf.__.BaseObject}
		 *
		 * @property {Object}	$el			the jQuery object for the template
		 * @property {String}	template	the HTML template
		 */
		function BaseUI (params) {
			BaseObject.apply(this, arguments);

			params = params || {};

			this.$el = null;
			this.loader_template = params.loader_template || this.loader_template || loader_template;
			this.template = params.template || this.template || null;
			this._default_parent = params.parent || this._default_parent || null;
			this.children = params.children || this.children || {};
			this.loading = params.loading || this.loading || false;
			this.feature_key = params.feature_key || this.feature_key || null;

			this.renderHandler = params.renderHandler || null;

			awf.util.mixin.properties(this, params, {

				id: {
					default: null,
					types: ['null','string'],
					renderHandler: function (val) {
						this.$el.attr('id', val);
					}
				}

			});


			if (params.render !== false) {
				this.render();

				if (params.cn) {
					this.$el.addClass(params.cn);
				}
			}
		}



	/*	Prototype Methods
	------------------------------------------*/
		_.extend(BaseUI.prototype, {

			/**
			 * @description renders the element.
			 * If the element has already been rendered, `destroy` is first called.
			 * It will create a jQuery DOM element using this.template, or if this.loading is true, then it will use this.loader_template.
			 * If the element had already been in the DOM, the new one will be placed there.
			 * Note: this function is called immediately on instantiation UNLESS params.render === false.
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			render: function () {

				var self = this;


				this._rendered_as_loading = !! this.loading;

				// There can only be one!
				// If there's already one out there, remove it
				var needs_to_be_replaced = false,
					$active_parent = null,
					child_index = null;

				if (this.$el && this.$el.closest('body').length === 1) {
					needs_to_be_replaced = true;
					$active_parent = this.$el.parent();
					child_index = this.$el.index();
				}


				if (this.$el)
					this.destroy();

				var template = this.loading ? this.loader_template : this.template;

				// If the value of template is invalid, throw an error
				switch (typeof template) {
					case undefined:
					case "object": // this covers null
						template = '<div></div>';
						break;

					case "string":
						if (template.length > 0 && _.trim(template).charAt(0) != '<')
							throw new Error('Cannot render UI Object. `template` must start with "<"');
						break;

					default:
						// throw new Error("Cannot render UI Object. `template` must be a string, null, or a function");
						throw new Error("Cannot render UI Object. `template` must be a string, null, or undefined. Found: " + (typeof template));
				}

				// Create and assign $el from template
				this.$el = $(template);


				this.$el.data('component', this);


				// Dynamically set `data-feature` attribute if `feature_key` property is assigned.
				if (this.feature_key)
					this.setFeatureKey(this.feature_key);


				if (needs_to_be_replaced) {

					if (child_index === 0) {
						$active_parent.prepend(this.$el);
					} else {
						$active_parent.children().eq(child_index - 1).after(this.$el);
					}

				} else if (this._default_parent) {

					var parent = this._default_parent;

					if (typeof(parent) == "function")
						parent = parent.call(self);


					if (parent) {
						if (parent.length == 1) {
							this.$el.appendTo(parent);
						} else {
							throw new Error('Cannot automatically append to parent when the parent count is not 1. ' + parent.length + ' were found.');
						}
					}
				}

				if (this.renderHandler && ( typeof this.renderHandler == 'function' )) {
					this.renderHandler.call(this);
				}

				if ( ! this.loading) {
					_.forEach(this.children, function (child) {
						child.render();
					});
				}

				this.triggerHandler(this.loading ? 'render-loader' : 'render');


				// Make it chainable!
				return this;
			},

			/**
			 * @description If this.$el exists (or it has been rendered as loading), render is called. Otherwise, nothing happens
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			renderOnce: function () {
				if (this.$el === null || this._rendered_as_loading)
					this.render.apply(this, arguments);
				else
					console.log('renderOnce opted out for: ', this.constructor.name);
				return this;
			},

			/**
			 * @description Destroys the $el object, but will first recursively call `destroy` on all this.children objects. Assigns this.$el to `null`
			 * @fires destroy
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			destroy: function () {
				var self = this;

				_.forEach(this.children, function (child) {
					if (child) {
						child.destroy();
					}
				});

				// remove $el
				if (this.$el)
					this.$el.remove();

				_.forEach(_.keys(this), function (key) {
					if (key.indexOf('_actual_') === 0)
						delete self[key];
				});

				// if/when we introduce pub-sub, cleanup will happen here.

				// assign $el to null, to help catch bad coding if/when attempts to access it are made at this point
				// i.e. - Don't try to modify/access $el until the render occurs again
				this.$el = null;

				this.triggerHandler('destroy');

				// Make it chainable!
				return this;
			},

			/**
			 * @description Returns the outer HTML of the element
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {string} The outer HTML of this.$el
			 */
			outerHTML: function () {
				var $wrapper = $('<div></div>');
				$wrapper.append(this.$el);
				return $wrapper.html();
			},

			/**
			 * @description Assigns the value of this.loading to match the given value, then calls this.render()
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			setLoading: function (new_val) {
				this.loading = new_val;
				return this.render();
			},


			/**
			 * @description Assigns the $el attribute 'data-feature' to the given value. If `null` is passed, the attribute is removed.
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			setFeatureKey: function (key) {
				this.feature_key = key;
				this.$el.attr('data-feature', this.feature_key);
				return this;
			},

			/**
			 * @description Assigns the default parent attribute to the given element
			 * @memberOf awf.ui.Base
			 * @instance
			 * @return {object} this (chainable)
			 */
			assignDefaultParent: function ($elem) {
				this._default_parent = $elem;
				return this;
			}

		});








	/*	Static Methods
	------------------------------------------*/
		_.extend(BaseUI, {

			/**
			 * Utility to generate pointers to elements within an element
			 * @memberOf awf.ui.Base
			 * @param  {object} Target       The target to modify
			 * @param  {object} shortcut_map The map of elements to create shortcuts
			 * @example
			 * // Adds SomeElement's prototype so that instances of SomeElement have `_$title` and `_$description` attributes
			 * BaseUI.generateDomProperties(SomeElement, {
			 *  title       : '.js-label',
			 * 	description : '.js-description'
			 * });
			 *
			 * var my_elem = new SomeElement();
			 * my_elem._$title; // pointer to the first DOM element within (and including) my_elem that has class `js-label`
			 * my_elem._$description; // pointer to the first DOM element within (and including) my_elem that has class `js-description`
			 *
			 * // This allows for things like:
			 * my_elem._$title.html('Lorem Ipsum');
			 */
			generateDomProperties: function (Target, shortcut_map) {
				_.forEach(shortcut_map, function (val, key) {
					Object.defineProperty(Target.prototype, '_$'+key, {
						get: function () {
							if ( ! this.$el)
								return null;

							if (this.$el.is(val)) {
								return this.$el;
							} else {
								return $(val, this.$el).eq(0);
							}
						}
					});
				});
			}
		});



/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-loader\">\n\t<span class=\"awf-loader__icon awficon-circle-sixth-o awficon-spin-fast\">\n\t\t<span class=\"awf-access\">Loading...</span>\n\t</span>\n</div>\n";

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Spinner;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Base;

	use(Parent).toCreate(Spinner);

	Spinner.template = __webpack_require__(94);

	// todo: Add unit test -- entire Class
	function Spinner (params) {
		params = params || {};

		var self = this;

		this.template = params.template || this.template || Spinner.template;

		Parent.apply(this, arguments);
	}


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Page;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Base;

	use(Parent).toCreate(Page);

	/**
	 * @typedef pageConfig
	 * @memberof awf.ui.Page
	 * @type Object
	 *
	 * @description
	 * The pageConfig object is a sub-element of the AWF config ([awfConfig]{@link awf.awfConfig}) and Application Copmposition config ([appCompConfig]{@Link awf.__.App.appCompConfig}) initialization objects. It is used to describe the configurable elements of a page ui component. The configuration is used to build the page through {@link awf.init} or through [awf.app.compose]{@link awf.__.App.compose}.
	 *
	 * @property {string|null} name             - The name of the page, used in various page elements like the title in the masthead
	 * @property {Object} [favicon]             - Contributes a favicon
	 * @property {string} favicon.active        - A url to the favicon to display when the browser tab is active
	 * @property {string} [favicon.inactive]    - A url to the favicon to display when the browser tab is not active
	 * @property {Object.<...string, awf.ui.Themes.themeConfig>} [themes] - An object containing a set of theme id and theme config object pairs
	 * @property {boolean|awf.ui.Masthead.mastheadConfig} [masthead] - True adds an empty masthead - a masthead config object to be used to configure the masthead
	 * @property {awf.ui.Notifications.notifyConfig} [notifications] - Config object to initialize the notifications banner
	 * @property {boolean|awf.ui.VerticalNav.leftnavConfig} [leftnav] - True adds an empty vertical navigator on the left side of the screen - a left nav config object to be used to configure the left nav
	 * @property {boolean|awf.ui.Footer.footerConfig} [footer] - True adds an empty footer - a footer config object to be used to configure the footer
	 * @property {string} [feature_key] - If included, the page wrapper will have a data-feature attribute set to its value. The value should match an existing flag in the features .JSON file.
	 * @property {awf.ui.Spinner} leftnav_spinner The spinner for the left nav, as it loads. Call this.leftnav_spinner.destroy() when the leftnav items are added.
	 *
	 *
	 * @example
	 * // This will create and initialize {@link awf.page} with a feature_key attribute
	 * awf.init({
	 *   page: {
	 *     name: "My App",
	 *     feature_key: "home-page"
	 *   }
	 * });
	 */

	/**
	 * @class Page
	 * @memberOf awf.ui
	 * @type {object}
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 *
	 * @description
	 * This class provides the foundation for UI Composition in the AWF. It is the base for most UI components as well as for the Application Composition layer.
	 *
	 * @param {awf.ui.Page.pageConfig} params - used to build the page through {@link awf.init}
	 *
	 * @property {string|null} name The page's name (H1)
	 * @property {object} trays Stored app-level cogs
	 * @property {boolean} masthead_active_state=false The masthead's active state.
	 * @property {object} _$content A jQuery reference to the page's main content container
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var my_page = new awf.ui.Page({
	 *        name: "My Page"
	 *      });
	 *
	 */
	function Page (params) {

		var self = this;

		params = params || {};

		console.group('Constructing Page');

		console.time('page - render');

		this.template = params.template || this.template || Page.template;
		params.parent = params.parent || $('body');

		// todo: make trays rearrangeable both in this object AND the DOM
		self.trays = {};

		Parent.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Pass in a name for the page
			 * @memberOf awf.ui.Page
			 * @title setName
			 * @function
			 * @instance
			 *
			 * @param  {String} value the name for the page
			 *
			 * @return {Object} this chainable
			 *
			 * @fires this#change:name
			 */
			name: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					this._$title.html(val);
				}
			},


			/**
			 * The active state of the masthead. When active, the classname '-has-masthead' is added to this.$el.
			 * @memberOf awf.ui.Page
			 * @name setMastheadActiveState
			 * @function
			 * @instance
			 *
			 * @param {boolean} val the masthead's active state to set
			 *
			 * @return {Object} this chainable
			 *
			 * @fires this#change:masthead_active_state
			 */
			masthead_active_state: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {
					this.$el[val ? "addClass" : "removeClass"]('-has-masthead');
				}
			},


			background: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					var value = null;

					if (val) {
						color = new awf.__.Color(val);
						if (color.isValid()) {
							value = color.toString();
							this.$el.css({
								'background-image' : 'none',
								'background-color' : value
							});
						} else {
							value = 'url("' + val + '")';
							this.$el.css({
								'background-image' : value,
								'background-color' : 'transparent'
							});
						}
					} else {
						this.$el.css({
							'background-image' : '',
							'background-color' : ''
						});
					}
				}
			},


			background_position: {
				default: '50% 50%',
				types: ['null','string'],
				renderHandler: function (val) {
					if (val === null)
						val = '50% 50%';

					this.$el.css({ 'background-position' : val });
				}
			},


			selectable_state: {
				default: true,
				types: ['boolean'],
				renderHandler: function (val) {
					this.$el[val ? "removeClass" : "addClass"]('-non-selectable');
				}
			}

		});




		/*	Themes
		------------------------------------------*/
			// todo: Add unit test -- themes default instance
			if ('themes' in params && params.themes !== false) {

				console.group('Themes');

				if (params.themes === true)
					params.themes = {};

				console.time('themes - render');

				/**
				 * The default instance, created if included in awf.init()
				 * @type {Themes}
				 * @memberOf awf.page
				 * @name awf.page.themes
				 * @instance
				 *
				 * @example
				 * // themes
				 *
				 * // This will create and initialize awf.page.themes with
				 * // a single, additional theme "contrast"
				 *
				 * awf.init({
				 *   page: {
				 *     themes: {
				 *       "contrast": {
				 *         "classname": "contrast",
				 *         "label": "contrast",
				 *         "font": "arial, sans-serif",
				 *         "background_base": "#ffffff",
				 *         "background_content": "#e0e0e0",
				 *         "color_base": "#000000",
				 *         "border_color_base": "#CCCCCC",
				 *         "color_alt": "#000000",
				 *         "background_alt": "#e0e0e0",
				 *         "border_color_alt": "#73737d",
				 *         "color_notifications": "#000000",
				 *         "background_notifications": "#ffffff",
				 *         "background_notifications_dismiss_hover": "#0024b1",
				 *         "border_color_notifications": "#0061ff",
				 *         "color_link": "#0024b1",
				 *         "color_link_hover": "#0061ff",
				 *         "color_selection": "#000000",
				 *         "background_selection": "#73737d",
				 *         "color_input": "#000000",
				 *         "background_input": "#ffffff",
				 *         "border_input": "1px solid #73737d",
				 *         "box_shadow_base": "0px 0px 5px 0px rgba(0,0,0,0.5)",
				 *         "box_shadow_focus": "0px 0px 6px 0px #0061ff",
				 *         "background_leftnav": "#ffffff",
				 *         "background_leftnav_hover": "#ffffff",
				 *         "background_leftnav_active": "#F4F4F4",
				 *         "color_leftnav_active": "#000000",
				 *         "background_search_results_hover": "#F4F4F4",
				 *         "foreground_message_success": "#6CBB1F",
				 *         "background_message_success": "#E9F7DB",
				 *         "foreground_message_info": "#074F95",
				 *         "background_message_info": "#EAF4FA",
				 *         "foreground_message_error": "#BD2121",
				 *         "background_message_error": "#FDE9E8",
				 *         "foreground_message_warn": "#F8C41C",
				 *         "background_message_warn": "#FEF2CD",
				 *         "foreground_button": "#ffffff",
				 *         "background_button": "#0024b1",
				 *         "foreground_button_hover": "#ffffff",
				 *         "background_button_hover": "#0061ff",
				 *         "foreground_tray_button": "#ffffff",
				 *         "background_tray_button": "#0024b1",
				 *         "border_color_tray_content": "#0024b1"
				 *       }
				 *     }
				 *   }
				 * });
				 *
				 */
				self.themes = new awf.ui.Themes({
					themes: params.themes
				});

				console.timeEnd('themes - render');

				console.groupEnd();

			} else {
				console.log('not configured: `themes`');
			}





		/*	Masthead
		------------------------------------------*/
			// todo: Add unit test -- masthead default instance
			if ('masthead' in params) {
				params.masthead.name = params.masthead.name || self.name || null;

				console.time('masthead - render');

				/**
				 * The default instance, created if [mastheadConfig]{@link awf.ui.Masthead.mastheadConfig} is included in the configuration for {@link awf.init} or [awf.app.compose]{@link awf.__.App.compose}
				 * @type {Masthead}
				 * @memberOf awf.page
				 * @name  awf.page.children.masthead
				 * @instance
				 */
				self.children.masthead = new awf.ui.Masthead(params.masthead);

				$('.js-placeholder-masthead', self.$el).replaceWith(self.children.masthead.$el);
				self.setMastheadActiveState(true);

				if ("themes" in self.children) {
					if (self.themes.current_theme != "default")
						self.children.masthead.children.stylesheet.destroy();

					self.themes.on('apply', function (ev, id) {
						if (id == "default")
							self.children.masthead.children.stylesheet.render();
						else
							self.children.masthead.children.stylesheet.destroy();
					});
				}

				console.timeEnd('masthead - render');
				console.timeStamp('masthead has rendered');

			} else {
				console.log('not configured: `masthead`');
			}





		/*	Notifications
		------------------------------------------*/
			// todo: Add unit test -- notifications default instance
			if ('notifications' in params) {

				console.group('Notifications');

				console.time('notifications - render');

				/**
				 * The default instance, created if included in awf.init()
				 * @type {Notifications}
				 * @memberOf awf.page
				 * @name awf.page.children.notifications
				 * @instance
				 *
				 * @example
				 * // notifications
				 *
				 * // data can be passed to the notifications instance after instantiation
				 * // by setting the instance's 'json' parameter to the data
				 * // and rerendering the instance.
				 *
				 * awf.init({
				 *   page: {
				 *     name: String, //(required) app/company
				 *     notifications: {}
				 *   }
				 * });
				 *
				 * //later on...
				 *
				 * awf.page.notifications.json = [
				 *   {
				 *     "id" : 0, //required, unique identifier
				 *     "start" : "Sun Jun 14 2015 00:00:00 (EDT)", //required, a valid date
				 *     "end" : "Fri Aug 14 2015 00:00:00 (EDT)", //required, a valid date
				 *     "title": "First Notification Title", //optional, string of text or html
				 *     "description": "Lorem ipsuom dolor &lt;a href='http://www.google.com'&gt;sit amet.&lt;/a&gt;", //optional, string of text or html
				 *     "theme" : "theme-error", //optional
				 *     "icon" : "awficon-discover", //optional
				 *     "hide_icon" : true, //optional
				 *     "hide_dismiss" : true //optional
				 *   },
				 *   {
				 *     "id" : 1,
				 *     "title": "Second Notification Title",
				 *     "description": "Lorem ipsuom dolor sit amet.",
				 *     "start" : "Aug 8 2015 00:00:00 (EDT)",
				 *     "end" : "Fri Aug 21 2015 00:00:00 (EDT)"
				 *   }
				 * ];
				 * awf.page.notifications.render();
				 *
				 */
				self.children.notifications = new awf.ui.Notifications(_.defaults(params.notifications, {
					parent: self._$notifications
				}));

				if ('data' in params.notifications) {

					console.log('Loading from `' + params.notifications.data + '`');

					$.ajax({
						url: params.notifications.data,
						dataType: 'json',
						cache: false
					})
					.done(function (response) {
						self.children.notifications.json = response;
						self.children.notifications.render();
					})
					.fail(function (response) {
						console.warn("Failed to load notifications banner data:", response.status, response.statusText);
					});
				}

				console.groupEnd();

				console.timeEnd('notifications - render');

			} else {
				console.log('not configured: `notifications`');
			}





		/*	Leftnav
		------------------------------------------*/
			// todo: Add unit test -- left nav default instance
			// kept vertical-nav/__tests__/leftnav-awf-initSpec.js, that
			// way we can likely use those existing tests and refactor them.
			if ('leftnav' in params) {
				console.time('leftnav - render');

				var leftnav_items = _.get(params, 'page.leftnav.data') || null;

				console.group('Constructing LeftNav');
				self.children.leftnav = new awf.ui.VerticalNav({
					items: leftnav_items,
					id: 'leftnav',
					cn: 'overflow-close'
				});
				console.groupEnd();

				this._$leftnav_placeholder.replaceWith(self.children.leftnav.$el);

				this.leftnav_spinner = new awf.ui.Spinner({
					parent: self.children.leftnav.$el
				});

				/*	Leftnav + Masthead
				------------------------------------------*/
					// couple the leftnav with a toggle button for mobile
					if (self.children.masthead) {

						console.group('Adding masthead + leftnav logic');

						console.log('...extending leftnav instance');
						_.extend(self.children.leftnav, {
							orig_scroll_pos: 0,

							toggle: new awf.ui.Button({
								classname: "js-nav-toggle nav-toggle -awf-link -text-decoration-none -awf-focus",
								text: "Open/Close Experience menu",
								icon: "awficon-hamburger1"
							}),

							showMobile: function () {
								var self = this;

								self.$el
									.removeClass('overflow-close');

								self.toggle.$el
									.attr('aria-expanded','true')
									.addClass('-color-link-hover');

								self.orig_scroll_pos = $(window).scrollTop();
								awf.$('html, body').animate({ scrollTop: 0 }, 0);

								setTimeout(function () {
									self.$el.find('.-is-active').focus();
								}, 200);

								//bind events
								awf.$('body')
									.on("keydown.leftnav.esc", function (ev) {
										switch (ev.keyCode) {
											case awf.util.keyCodes.esc:
												// if the drawer is open, it's a closed loop
												if (self.is_active) {
													self.setIsActive(false);
													ev.preventDefault();
												}
												break;
										}
									});

								// close leftnav when item is selected
								self.on('change:active_index.leftnav', function () {
									if (self.is_active) {
										setTimeout(function () {
											self.orig_scroll_pos = 0;
											self.setIsActive(false);
										}, 300);
									}
								});

								// create tab loop
								self.toggle.$el
									.on("keydown.leftnav.tab", function (ev) {
										switch (ev.keyCode) {
											case awf.util.keyCodes.tab:
												// if the nav is open, it's a closed loop
												if (self.is_active) {
													self.$el.find('.-is-active').focus();
													ev.preventDefault();
												}
												break;
										}
									});
								self.$el
									.on("keydown.leftnav.tab", function (ev) {
										switch (ev.keyCode) {
											case awf.util.keyCodes.tab:
												// if the nav is open, it's a closed loop
												if (self.is_active) {
													self.toggle.$el.focus();
													ev.preventDefault();
												}
												break;
										}
									});
							},

							hideMobile: function () {
								var self = this;

								awf.$('body').off("keydown.leftnav.esc");
								self.off('change:active_index.leftnav');
								self.toggle.$el.off("keydown.leftnav.tab");
								self.$el.off("keydown.leftnav.tab");

								self.toggle.$el
									.attr('aria-expanded','false')
									.removeClass('-color-link-hover');

								if (self.orig_scroll_pos)
									awf.$('html, body').animate({ scrollTop: self.orig_scroll_pos }, 0);

								self.toggle.$el.focus();

								setTimeout(function () {
									self.$el
										.addClass('overflow-close');
								}, 300);


							}

						});

						console.log('...adding aria controls to leftnav toggler');
						self.children.leftnav.toggle.$el
							.attr({
								'aria-controls':'leftnav',
								'aria-expanded':'false',
								'role':'button'
							});

						console.log('...adding the toggler');
						awf.$('.js-leftnav-toggle-placeholder', self.children.masthead.$el).replaceWith(self.children.leftnav.toggle.$el);

						//couple leftnav toggle to leftnav
						console.log('...coupling leftnav toggle to leftnav');
						self.children.leftnav.toggle
							.on('click:button', function () {
								self.children.leftnav
									.setIsActive(self.children.leftnav.is_active ? false : true);
							});

						// show or hide the leftnav
						console.log('...coupling leftnav change to show/hide mobile');
						self.children.leftnav
							.on('change:is_active', function (ev, val) {
								if (val)
									this.showMobile();
								else
									this.hideMobile();
							});

						console.groupEnd();
					} else {
						console.log('No masthead. Not adding special leftnav+masthead logic');
					}

				console.timeEnd('leftnav - render');
			}





		/*	Footer
		------------------------------------------*/
			// todo: Add unit test -- footer default instance
			if ('footer' in params && params.footer !== false) {
				console.time('footer - render');

				params.footer.name = params.footer.name || self.name || null;

				/**
				 * The default instance, created if included in awf.init()
				 * @type {awf.ui.Footer}
				 * @see {@link awf.ui.Footer} for more details
				 * @memberOf awf.page
				 * @name awf.page.children.footer
				 * @namespace  awf.page.children.footer
				 *
				 * @example
				 * // footer
				 *
				 * // This will create and initialize awf.page.children.footer with a logo and links
				 *
				 * awf.init({
				 * 	page: {
				 * 		name: String, //(required) app/company
				 * 		footer: {
				 * 			logo: String, //(optional) path to logo image
				 * 			links: String //(optional) path to links JSON file
				 * 		}
				 * 	}
				 * });
				 *
				 * @example
				 * // Or pass an array of link objects
				 *
				 * awf.init({
				 * 	page: {
				 * 		name: String,
				 * 		footer: {
				 * 			logo: String,
				 * 			links: [
				 * 				{
				 * 					label: "Google",
				 * 					href: "http://www.google.com",
				 * 					target: "_parent"
				 * 				},
				 * 				{
				 * 					label: "Yahoo",
				 * 					href: "http://www.yahoo.com"
				 * 				}
				 * 			]
				 * 		}
				 * 	}
				 * });
				 *
				 */
				console.group('Footer');
				self.children.footer = new awf.ui.Footer(params.footer);
				console.groupEnd();
				$('.js-placeholder-footer', self.$el).replaceWith(self.children.footer.$el);

				console.timeEnd('footer - render');
			} else {
				console.log('not configured: `footer`');
			}





		/*	Content
		------------------------------------------*/
			// todo: Add unit test -- content default instance
			if ('content' in params) {
				console.time('content - render');

				console.group('Content');
				// This is not how content is normally put together; this is an old-school direct method for adding content
				// to the page in the event that app composition is not building things.
				_.forEach(params.content, function (val, key) {

					switch (key) {

						case 'html':
							console.log('Adding HTML');
							self._$content.append(val);
							break;


						case 'grid':
							console.log('Adding Grid');

							self.grid = new awf.ui.Grid(_.defaults(val, {
								parent: self._$content
							}));

							self.grid.autoSetColumns();
							$(window).on('resize.grid', function () {
								self.grid.autoSetColumns();
							});

							self.grid.on('destroy', function () {
								$(window).off('resize.grid');
							});

							break;

					}

				});

				console.groupEnd();

				console.timeEnd('content - render');
			} else {
				console.log('not configured: `content`');
			}




		console.groupEnd();
		console.timeEnd('page - render');
	}





	/*	DOM shortcuts
	------------------------------------------*/
		Parent.generateDomProperties(Page, {
			content: '.js-layout-wrapper',
			title: '.js-awf-page-heading',
			notifications: '.js-notifications-banner-container',
			darkener: '.js-darkener',
			leftnav_placeholder: '.js-leftnav-placeholder',
			trays: '.js-page-trays'
		});





	/*	Prototype Methods
	------------------------------------------*/
		_.extend(Page.prototype, {

			// todo: Add unit test -- spotlight Method
			spotlight: function ($targets, _dont_kill_darkener) {

				var self = this;

				function resetTargets () {
					if (this._spotlight_targets) {
						_.forEach(this._spotlight_targets, function ($item) {
							if ($item) {
								$item
									.removeClass('-is-spotlighted')
									.removeClass('-spotlight-relative-helper');
							}
						});
					}

					this._spotlight_targets = null;
				}

				if ($targets === null) {

					var $darkener = this._$darkener;

					if ( ! _dont_kill_darkener) {
						clearTimeout(this._spotlight_timer);
						$darkener.removeClass('-is-dark');
						this._spotlight_timer = setTimeout(function () {
							$darkener.removeClass('-is-available');

							resetTargets.call(self);
						}, 500);
					} else {
						resetTargets.call(self);
					}

				} else {

					// reset, but don't kill the darkener
					this.spotlight(null, true);

					clearTimeout(this._spotlight_timer);
					this._$darkener
						.addClass('-is-available')
						.addClass('-is-dark');

					this._spotlight_targets = null;
					if (_.isArray($targets)) {
						this._spotlight_targets = $targets;
					} else {
						this._spotlight_targets = [$targets];
					}

					_.forEach(this._spotlight_targets, function (item) {
						var $target = $(item);
						$target.addClass('-is-spotlighted');

						if ($target.css('position') == "static")
							$target.addClass('-spotlight-relative-helper');
					});
				}

			},


			// Note: We're not including this property in documentation, at this time (maybe never!!)
			_kitchen_sink: __webpack_require__(97),


			// Note: We're not including this property in documentation, at this time (maybe never!!)
			addKitchenSink: function () {
				$('.js-layout-wrapper', this.$el).append(this._kitchen_sink);
				return this;
			},


			/**
			 * Adds a cog for the app-level trays
			 * @memberof awf.ui.Page
			 *
			 * @param {awf.__.Cog} cog The cog to add
			 *
			 * @return {Object} this (chainable)
			 */
			addTray: function (cog) {
				var self = this;

				console.group("Adding cog to Page");

				console.log('cog: ', cog);

				if ( ! cog.isViewAvailable('medium')) {
					throw new Error('Cannot add cog to Page - cog has no `medium` view defined.');
				}

				self.trays[cog.id] = cog;
				cog.component = new awf.ui.Tray({
					label: cog.views.medium.label,
					width: cog.views.medium.width,
					min_height: cog.views.medium.min_height,
					class_name: cog.views.medium.class_name,
					toggle_align: cog.views.medium.toggle_align,
					position: cog.views.medium.position,
					show_text: cog.views.medium.show_text,
					hide_text: cog.views.medium.hide_text,
					parent: self._$trays,
					tooltip: true
				});

				// Calculate `bottom` value for each component
				self._updateTrayPosition();


				// Bind events
				cog.component
					.on("tray:show", function () {

						// Render the cog view
						cog.view_instance = cog.renderView('medium', cog.component._$content, {
							context: 'page-tray'
						});

					})
					.on("tray:hide", function () {

						// Destroy the cog view, if it exists
						if (cog.view_instance) {
							cog.view_instance.destroy();
							cog.view_instance = null;
						}

					});



				console.groupEnd();

				return this;
			},


			/**
			 * Removes a cog from the app-level trays
			 * @memberof awf.ui.Page
			 *
			 * @param {string} id The ID for the cog to remove
			 *
			 * @return {object} this (chainable)
			 */
			removeTray: function (id) {
				var cog = this.trays[id].cog;

				if (this.trays[id]) {
					if (this.trays[id].view_instance) {
						this.trays[id].view_instance.destroy();
						this.trays[id].view_instance = null;
					}
					if (this.trays[id].component) {
						this.trays[id].component.destroy();
						this.trays[id].component = null;
					}
					delete this.trays[id];

					this._updateTrayPosition();
				}

				return this;
			},


			/**
			 * Updates the CSS `bottom` properties value for the tray components
			 * @memberof awf.ui.Page
			 *
			 * @param {number} distance=60 The desired distance between the
			 * bottom of one tray to the bottom of the next.
			 *
			 * @return {object} this (chainable)
			 */
			_updateTrayPosition: function (distance) {
				distance = distance || 60;
				var y = distance * Object.keys(this.trays).length;
				_.forEach(this.trays, function (tray) {
					tray.component.setBottom(y);
					y = y - distance;
				});

				return this;
			}

		});





	/*	Static Attributes / Methods
	------------------------------------------*/
		_.extend(Page, {

			template: __webpack_require__(98)

		});


/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kitchen-sink\">\n  <h1>Heading 1</h1>\n  <h2>Heading 2</h2>\n  <h3>Heading 3</h3>\n  <h4>Heading 4</h4>\n  <h5>Heading 5</h5>\n  <h6>Heading 6</h6>\n\n  <h2>Text-level semantics</h2>\n  <p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m.</p>\n  <p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et m.</p>\n  <hr>\n  <p>\n    The <a href=\"#\">a element</a> example<br>\n    The <abbr>abbr element</abbr> and <abbr title=\"Title text\">abbr element with title</abbr> examples<br>\n    The <strong>b element</strong> example<br>\n    The <cite>cite element</cite> example<br>\n    The <code>code element</code> example<br>\n    The <del>del element</del> example<br>\n    The <dfn>dfn element</dfn> and <dfn title=\"Title text\">dfn element with title</dfn> examples<br>\n    The <em>em element</em> example<br>\n    The <em>i element</em> example<br>\n    The img element <img alt=\"\" src=\"http://placehold.it/30\"> example<br>\n    The linked img element <a href=\"http://placehold.it\"><img alt=\"\" src=\"http://placehold.it/30\"></a> example<br>\n    The <ins>ins element</ins> example<br>\n    The <kbd>kbd element</kbd> example<br>\n    The <mark>mark element</mark> example<br>\n    The <q>q element <q>inside</q> a q element</q> example<br>\n    The <s>s element</s> example<br>\n    The <samp>samp element</samp> example<br>\n    The <small>small element</small> example<br>\n    The <span>span element</span> example<br>\n    The <strong>strong element</strong> example<br>\n    The <sub>sub element</sub> example<br>\n    The <sup>sup element</sup> example<br>\n    The <span style=\"text-decoration: underline;\">u element</span> example<br>\n    The <var>var element</var> example\n  </p>\n\n  <h2>Grouping content</h2>\n  <h3>pre</h3>\n  <pre>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et me.</pre>\n  <pre><code>&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"main\"&gt; &lt;div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n  <h3>blockquote</h3>\n  <blockquote>\n    <p>Some sort of famous witty quote marked up with a &lt;blockquote&gt; and a child &lt;p&gt; element.</p>\n  </blockquote>\n  <blockquote>Even better philosophical quote marked up with just a &lt;blockquote&gt; element.</blockquote>\n\n  <h3>ordered list</h3>\n  <ol>\n      <li>list item 1</li>\n      <li>list item 1\n      <ol>\n          <li>list item 2</li>\n          <li>list item 2\n          <ol>\n              <li>list item 3</li>\n              <li>list item 3</li>\n          </ol>\n          </li>\n          <li>list item 2</li>\n          <li>list item 2</li>\n      </ol>\n      </li>\n      <li>list item 1</li>\n      <li>list item 1</li>\n  </ol>\n\n  <h3>unordered list</h3>\n  <ul>\n      <li>list item 1</li>\n      <li>list item 1\n      <ul>\n          <li>list item 2</li>\n          <li>list item 2\n          <ul>\n              <li>list item 3</li>\n              <li>list item 3</li>\n          </ul>\n          </li>\n          <li>list item 2</li>\n          <li>list item 2</li>\n      </ul>\n      </li>\n      <li>list item 1</li>\n      <li>list item 1</li>\n  </ul>\n\n  <h3>description list</h3>\n  <dl>\n      <dt>Description name</dt>\n      <dd>Description value</dd>\n      <dt>Description name</dt>\n      <dd>Description value</dd>\n      <dd>Description value</dd>\n      <dt>Description name</dt>\n      <dt>Description name</dt>\n      <dd>Description value</dd>\n  </dl>\n\n  <h2>Tabular data</h2>\n  <h3>auto width</h3>\n  <table>\n      <caption>Jimi Hendrix - albums</caption>\n      <thead>\n          <tr>\n              <th>Album</th>\n              <th>Year</th>\n              <th>Price</th>\n          </tr>\n      </thead>\n      <tfoot>\n      <tr>\n          <th>Album</th>\n          <th>Year</th>\n          <th>Price</th>\n      </tr>\n      </tfoot>\n      <tbody>\n          <tr>\n              <td>Are You Experienced</td>\n              <td>1967</td>\n              <td>$10.00</td>\n          </tr>\n          <tr>\n              <td>Axis: Bold as Love</td>\n              <td>1967</td>\n              <td>$12.00</td>\n          </tr>\n          <tr>\n              <td>Electric Ladyland</td>\n              <td>1968</td>\n              <td>$10.00</td>\n          </tr>\n          <tr>\n              <td>Band of Gypsys</td>\n              <td>1970</td>\n              <td>$12.00</td>\n          </tr>\n      </tbody>\n  </table>\n\n  <h3>100% width</h3>\n  <table style=\"width: 100%;\">\n      <caption>Jimi Hendrix - albums</caption>\n      <thead>\n          <tr>\n              <th>Album</th>\n              <th>Year</th>\n              <th>Price</th>\n          </tr>\n      </thead>\n      <tfoot>\n      <tr>\n          <th>Album</th>\n          <th>Year</th>\n          <th>Price</th>\n      </tr>\n      </tfoot>\n      <tbody>\n          <tr>\n              <td>Are You Experienced</td>\n              <td>1967</td>\n              <td>$10.00</td>\n          </tr>\n          <tr>\n              <td>Axis: Bold as Love</td>\n              <td>1967</td>\n              <td>$12.00</td>\n          </tr>\n          <tr>\n              <td>Electric Ladyland</td>\n              <td>1968</td>\n              <td>$10.00</td>\n          </tr>\n          <tr>\n              <td>Band of Gypsys</td>\n              <td>1970</td>\n              <td>$12.00</td>\n          </tr>\n      </tbody>\n  </table>\n\n  <h2>Form Elements</h2>\n  <fieldset>\n    <legend>Inputs as descendents of labels (form legend). This doubles up as a long legend that can test word wrapping.</legend>\n    <p><label>Text input <input type=\"text\" value=\"default value that goes on and on without stopping or punctuation\"></label></p>\n    <p><label>Email input <input type=\"email\"></label></p>\n    <p><label>Search input <input type=\"search\"></label></p>\n    <p><label>Tel input <input type=\"tel\"></label></p>\n    <p><label>URL input <input type=\"url\" placeholder=\"http://\"></label></p>\n    <p><label>Password input <input type=\"password\" value=\"password\"></label></p>\n    <p><label>File input <input type=\"file\"></label></p>\n    <p><label>Radio input <input type=\"radio\" name=\"rad\"></label></p>\n    <p><label>Checkbox input <input type=\"checkbox\"></label></p>\n    <p><label><input type=\"radio\" name=\"rad\"> Radio input</label></p>\n    <p><label><input type=\"checkbox\"> Checkbox input</label></p>\n    <p>\n      <label>Select field\n        <select>\n          <option>Option 01</option>\n          <option>Option 02</option>\n        </select>\n      </label>\n    </p>\n    <p><label>Textarea <textarea cols=\"30\" rows=\"5\">Textarea text</textarea></label></p>\n  </fieldset>\n  <fieldset>\n    <legend>Inputs as siblings of labels</legend>\n    <p><label for=\"ic\">Color input</label> <input type=\"color\" id=\"ic\" value=\"#000000\"></p>\n    <p><label for=\"in\">Number input</label> <input type=\"number\" id=\"in\" min=\"0\" max=\"10\" value=\"5\"></p>\n    <p><label for=\"ir\">Range input</label> <input type=\"range\" id=\"ir\" value=\"10\"></p>\n    <p><label for=\"idd\">Date input</label> <input type=\"date\" id=\"idd\" value=\"1970-01-01\"></p>\n    <p><label for=\"idm\">Month input</label> <input type=\"month\" id=\"idm\" value=\"1970-01\"></p>\n    <p><label for=\"idw\">Week input</label> <input type=\"week\" id=\"idw\" value=\"1970-W01\"></p>\n    <p><label for=\"idt\">Datetime input</label> <input type=\"datetime\" id=\"idt\" value=\"1970-01-01T00:00:00Z\"></p>\n    <p><label for=\"idtl\">Datetime-local input</label> <input type=\"datetime-local\" id=\"idtl\" value=\"1970-01-01T00:00\"></p>\n    <p><label for=\"irb\">Radio input</label> <input type=\"radio\" id=\"irb\" name=\"rad\"></p>\n    <p><label for=\"icb\">Checkbox input</label> <input type=\"checkbox\" id=\"icb\"></p>\n    <p><input type=\"radio\" id=\"irb2\" name=\"rad\"> <label for=\"irb2\">Radio input</label></p>\n    <p><input type=\"checkbox\" id=\"icb2\"> <label for=\"icb2\">Checkbox input</label></p>\n    <p>\n      <label for=\"s\">Select field</label>\n      <select id=\"s\">\n        <option>Option 01</option>\n        <option>Option 02</option>\n      </select>\n    </p>\n    <p><label for=\"t\">Textarea</label> <textarea id=\"t\" cols=\"30\" rows=\"5\">Textarea text</textarea></p>\n  </fieldset>\n  <fieldset>\n    <legend>Clickable inputs and buttons</legend>\n    <p><input type=\"reset\" value=\"Reset (input)\"></p>\n    <p><input type=\"button\" value=\"Button (input)\"></p>\n    <p><input type=\"submit\" value=\"Submit (input)\"></p>\n    <p><input type=\"submit\" value=\"Disabled (input)\" disabled=\"disabled\"></p>\n    <p><button type=\"reset\">Reset (button)</button></p>\n    <p><button type=\"button\">Button (button)</button></p>\n    <p><button type=\"submit\">Submit (button)</button></p>\n    <p><button type=\"submit\" disabled=\"disabled\">Disabled (button)</button></p>\n  </fieldset>\n  <fieldset id=\"boxsize\">\n    <legend>box-sizing tests</legend>\n    <div><input type=\"text\" value=\"text\"></div>\n    <div><input type=\"email\" value=\"email\"></div>\n    <div><input type=\"search\" value=\"search\"></div>\n    <div><input type=\"url\" value=\"http://example.com\"></div>\n    <div><input type=\"password\" value=\"password\"></div>\n    <div><input type=\"color\" value=\"#000000\"></div>\n    <div><input type=\"number\" value=\"5\"></div>\n    <div><input type=\"range\" value=\"10\"></div>\n    <div><input type=\"date\" value=\"1970-01-01\"></div>\n    <div><input type=\"month\" value=\"1970-01\"></div>\n    <div><input type=\"week\" value=\"1970-W01\"></div>\n    <div><input type=\"datetime\" value=\"1970-01-01T00:00:00Z\"></div>\n    <div><input type=\"datetime-local\" value=\"1970-01-01T00:00\"></div>\n    <div><input type=\"radio\"></div>\n    <div><input type=\"checkbox\"></div>\n    <div>\n      <select>\n        <option>Option 01</option>\n        <option>Option 02</option>\n      </select>\n    </div>\n    <div><textarea cols=\"30\" rows=\"5\">Textarea text</textarea></div>\n    <div><input type=\"reset\" value=\"Reset (input)\"></div>\n    <div><input type=\"button\" value=\"Button (input)\"></div>\n    <div><input type=\"submit\" value=\"Submit (input)\"></div>\n    <div><button type=\"reset\">Reset (button)</button></div>\n    <div><button type=\"button\">Button (button)</button></div>\n    <div><button type=\"submit\">Submit (button)</button></div>\n  </fieldset>\n</div>\n";

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-page js-page\" role=\"region\" aria-labelledby=\"page-title\">\n\t<div class=\"js-placeholder-masthead\"></div>\n\t<div id=\"notifications-banner\" class=\"js-notifications-banner-container notifications-banner-container\" data-feature=\"page.notifications-banner\" aria-label=\"Notifications Banner\"></div>\n\t<div id=\"awf-app-message\" class=\"js-app-message awf-app-message\" role=\"alert\" data-feature=\"page.app-message\" aria-label=\"Application Message\"></div>\n\t<div id=\"content\" class=\"awf-experience\" role=\"main\" data-feature=\"page.experience\" aria-label=\"All content\">\n\t\t<div class=\"darkener js-darkener\"></div>\n\t\t<h1 id=\"page-title\" class=\"js-awf-page-heading awf-access\" aria-label=\"Page Title\" data-feature=\"page.title\"></h1>\n\t\t<div class=\"awf-experience__inner\">\n\t\t\t<div class=\"js-leftnav-placeholder\"></div>\n\t\t\t<div id=\"layout\" class=\"js-layout-wrapper\"></div>\n\t\t</div>\n\t</div>\n\t<div class=\"js-page-trays awf-page-trays\"></div>\n\t<div class=\"js-placeholder-footer\"></div>\n</div>\n";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Badge;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		template = __webpack_require__(100);

	awf.util.use(awf.ui.Base).toCreate(Badge);

	/*	Constructor
	------------------------------------------*/
		/**
		 * @memberOf awf.ui
		 * @class
	 	 * @augments {awf.ui.Base}
	 	 * 
		 * @param {Object} [params]
		 * @param {null|number} [params.number] The number to show on the badge
		 * @param {boolean} [params.active_state] The starting active state (default: follows the number)
		 *
		 * @property {null|number} number The number of the badge
		 * @property {boolean} active_state The active state of the badge
		 */
		function Badge (params) {

			params = params || {};

			awf.util.mixin.properties(this, params, {

				/**
				 * @name setNumber
				 * @memberof awf.ui.Badge
				 * @function
				 * @instance
				 * @param  {null|number} val The new number to show. If null or 0, it will hide the badge, otherwise (even if hidden) it will show it.
				 * @fires change:number
				 * @return {object} self chainable
				 */
				number: {
					default: null,
					types: ['null','number'],
					renderHandler: function (val) {
						if (val === null || val < 1)
							val = '';

						this.setActiveState( !! val);
						this.$el.html(val);
					}
				},

				/**
				 * @name setTootlip
				 * @memberof awf.ui.Badge
				 * @function
				 * @instance
				 * @param  {null|string} val The tooltip for the badge
				 * @fires change:tooltip
				 * @return {object} self chainable
				 */
				tooltip: {
					default: null,
					types: ['null','string'],
					renderHandler: function (val) {
						if (val === '')
							val = null;

						this.$el.attr('title', val);
					}
				},

				/**
				 * @name setActiveState
				 * @memberof awf.ui.Badge
				 * @function
				 * @instance
				 * @param  {boolean} val The new active state
				 * @fires change:active_state
				 * @return {object} self chainable
				 */
				active_state: {
					default: false,
					types: ['boolean'],
					renderHandler: function (val) {
						this.$el[val ? 'addClass' : 'removeClass']('-is-active');
					}
				}
			});

			this.template = params.template || this.template || template;

			awf.ui.Base.apply(this, arguments);
		}



/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-badge -box-shadow-base\"></div>\n";

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = FixedHeaderFooter;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		Parent = awf.ui.Base;

	awf.util.use(Parent).toCreate(FixedHeaderFooter);

	// todo: Add unit test -- entire Class

	/**
	 * @class FixedHeaderFooter
	 * @memberOf awf.ui
	 * @type {object}
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @description This class provides a set of containers that will fill the parent space.
	 *
	 * @param {Object}	params
	 * @param {String}	[params.template]	Only use this if you must override. The HTML template for this component
	 *
	 * @property {Object}	_$header	jQuery element pointing at the header container
	 * @property {Object}	_$middle	jQuery element pointing at the middle container
	 * @property {Object}	_$footer	jQuery element pointing at the footer container
	 *
	 * @example
	 * // Creating a simple instance within a cog's view render
	 *
	 * render: function ($container) {
	 *     var fhf = new awf.ui.FixedHeaderFooter({
	 *         parent: $container
	 *     });
	 *
	 *     fhf._$header.html('<h2>The Header</h2>');
	 *     fhf._$middle.html('<p>lorem ipsum dolor sit amet</p>');
	 * }
	 * 
	 *
	 */
	function FixedHeaderFooter (params) {
		params = params || {};
		var self = this;

		this.template = params.template || this.template || FixedHeaderFooter.template;

		Parent.apply(this, arguments);
	}


	/*	DOM shortcuts
	------------------------------------------*/
		awf.ui.Base.generateDomProperties(FixedHeaderFooter, {
			header: '.js-header',
			middle: '.js-middle',
			footer: '.js-footer'
		});


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(FixedHeaderFooter.prototype, {
			//
		});


	/*	Static Attributes / Methods
	------------------------------------------*/
		_.extend(FixedHeaderFooter, {

			template: __webpack_require__(102)

		});


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "<div class=\"fixed-header-footer\">\n\t<div class=\"fixed-header-footer__header\">\n\t\t<div class=\"fixed-header-footer__header__content js-header group\"></div>\n\t</div>\n\t<div class=\"fixed-header-footer__middle\">\n\t\t<div class=\"fixed-header-footer__middle__content js-middle\"></div>\n\t</div>\n\t<div class=\"fixed-header-footer__footer\">\n\t\t<div class=\"fixed-header-footer__footer__content js-footer group\"></div>\n\t</div>\n</div>\n";

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Card;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base;

	use(BaseUI).toCreate(Card);

	/**
	 * Card UI Component Super Class. Creates a container with basic styles
	 * that can be used to extend to a TitledCard, or IconCard.
	 * @class
	 * @memberOf awf.ui
	 *
	 * @extends {awf.ui.Base}
	 * @requires jQuery
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var card = new awf.ui.Card();
	 *
	 */
	function Card (params) {
		params = params || {};
		params.template = params.template || this.template || Card.template;

		var self = this;

		this.drag_data = {};
		this.aria_id = awf.util.randomID();

		BaseUI.call(this, params);

		this.children = {
			badge: new awf.ui.Badge({
				number: params.badge,
				parent: self._$badge
			})
		};
	}

	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Card, {
			card: '.js-card',
			drag_handle: '.js-drag-handle',
			badge: '.js-badge-placer'
		});

	Card.template = __webpack_require__(104);

	_.extend(Card.prototype, {
		//
	});


/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-card-wrap\">\n\t<div class=\"js-card awf-card -background-base -awf-focus\" tabindex=\"0\"></div>\n\t<div class=\"awf-badge-placer js-badge-placer\"></div>\n</div>\n";

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = UICollectionItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base;

	use(BaseUI).toCreate(UICollectionItem);



	/**
	 * UICollectionItem Component. Auto-assigns default parent to its collection.$el
	 * @class
	 * @memberOf awf.ui
	 * @extends {awf.ui.Base}
	 */
	function UICollectionItem (params) {
		params = params || {};

		awf.util.mixin.collectionItem(this, params);

		this._default_parent = params.parent || this._default_parent || function () {
			if (this.collection)
				return this.collection.$el;
			else
				return null;
		};

		BaseUI.apply(this, arguments);
	}


	_.extend(UICollectionItem.prototype, {
		//
	});


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = UICollection;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base;

	use(BaseUI).toCreate(UICollection);



	/**
	 * UICollection UI Component
	 * @class
	 * @memberOf awf.ui
	 * @extends {awf.ui.Base}
	 */
	function UICollection (params) {
		params = params || {};

		awf.util.mixin.collection(this, params, {
			addItem: function (item) {
				if (this.$el && ! item.$el) {
					item.render();
				}
			},
			removeItem: function (item) {
				item.destroy();
			},
			setOrder: function (order) {
				if (order.length === 0)
					return false;

				var self = this,
					$parent = self.items[0].$el.parent();

				_.forEach(this.items, function (item) {
					$parent.append(item.$el);
				});
			}
		});

		BaseUI.apply(this, arguments);
	}





	_.extend(UICollection.prototype, {

		//todo: Check to see if this is needed
		Item: awf.ui.CollectionItem,

		/**
		 * Renders itself, then all items
		 * @memberOf awf.ui.Collection
		 * @return {object} this (chainable)
		 */
		render: function () {
			BaseUI.prototype.render.call(this);

			_.forEach(this.items, function (item) {
				item.render();
			});

			return this;
		},


		/**
		 * Destroys all items, then itself
		 * @memberOf awf.ui.Collection
		 * @return {object} this (chainable)
		 */
		destroy: function () {
			_.forEachRight(this.items, function (item) {
				item.destroy();
			});

			BaseUI.prototype.destroy.apply(this, arguments);

			return this;
		}
	});


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Dropdown;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(108);


	use(BaseUI).toCreate(Dropdown);

	/**
	 * Dropdown UI Component
	 * @class
	 * @memberOf awf.ui
	 * @augments {awf.ui.Base}
	 *
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param  {Object} parameters
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var dropdown = new awf.ui.Dropdown();
	 *
	 */
	function Dropdown (params) {
		params = params || {};
		params.template = template;

		this.button = params.button;
		this.label = params.label;
		this.content = params.content;
		this.content_width = params.content_width;

		this._button_id = awf.util.randomID();
		this._content_id = awf.util.randomID();
		this._label_id = awf.util.randomID();

		this.offset = _.extend({
			x: 0,
			y: 0
		}, params.offset || {});

		awf.util.mixin.properties(this, params, {

			direction: {
				default: 'left',
				types: ['string'],
				validator: function (val) {
					var valid = ['left','right'],
						is_valid = _.contains(valid, val);
					if ( ! is_valid) {
						console.warn('`direction` can only be set to ' + awf.util.list(valid, 'or', '`'));
					}
					return is_valid;
				},
				renderHandler: function (val) {
					switch (val) {
						case "left":
							this._$content_wrapper.removeClass("awf-dropdown__wrapper--right");
							break;

						case "right":
							this._$content_wrapper.addClass("awf-dropdown__wrapper--right");
							break;

						default:
							throw new Error('Cannot setDirection() of dropdown to \'' + val + '\'. Please use \'left\' or \'right\'.');
					}
				}
			}

		});

		BaseUI.call(this, params);
	}

	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Dropdown, {
			label: '.js-dropdown-label',
			button: '.js-dropdown-button',
			content_wrapper: '.js-dropdown-wrapper',
			content: '.js-dropdown-content',
			tip_wrapper: '.tip-wrapper',
			tip: '.tip-wrapper .tip',
			loop_last: '.js-loop-to-last',
			loop_first: '.js-loop-to-first'
		});


	_.extend(Dropdown.prototype, {

		render: function () {
			BaseUI.prototype.render.apply(this, arguments);

			var self = this;

			if (this.direction) {
				this.setDirection(this.direction);
			}

			if (this.button)
				this.setButton(this.button);

			if (this.content)
				this.setContent(this.content);

			if (this.content_width)
				this.setContentWidth(this.content_width);

			this._applyOffset();

			//Add attributes for Accessibility
				this._$label
					.attr('id',this._label_id)
					.html(this.label);

				this._$button
					.attr('id',this._button_id);
					//.attr('aria-controls',this._content_id);

				this._$content_wrapper
					.attr('id',this._content_id)
					.attr('aria-labelledby', this._label_id);

			this._$button
				.on("click", function () {
					if (self.isVisible())
						self.hide();
					else
						self.show();
				});

			return this;
		},

		/**
		 * Gives the button (the acticator of the dropdown) content
		 * @memberof awf.ui.Dropdown
		 * @param {string|element} val	Whatever is passed here will replace the content of the button
		 */
		setButton: function (val) {
			if (val === undefined)
				throw new Error('setButton requires a parameter');

			this.button = val;
			if (this._$button) {
				this._$button
					.empty()
					.append('<span class="awf-access"><span class="js-dropdown-action">Show</span> ' + this.label + '</span>')
					.append(val);
			}

			return this;
		},

		/**
		 * Sets the button width. When assigned, the position of the tip on the dropdown will move to be as close to the center as possible
		 * @memberof awf.ui.Dropdown
		 * @param {number} number 0 to infinity
		 * @emits change.button_width
		 */
		setButtonWidth: function (number) {
			if (this._actual_button_width === number)
				return this;

			this.button_width = number;
			this.$el.css({
				width: number+'px'
			});
			this._actual_button_width = number;

			this.triggerHandler('change.button_width');

			return this;
		},

		/**
		 * Sets the button height.
		 * @memberof awf.ui.Dropdown
		 * @param {number} number 0 to infinity
		 * @emits change.button_height
		 */
		setButtonHeight: function (number) {
			if (this._actual_button_height === number)
				return this;

			this.button_height = number;
			this.$el.css({
				height: number+'px'
			});
			this._actual_button_height = number;

			this.triggerHandler('change.button_height');

			return this;
		},

		/**
		 * Sets the content of the dropdown
		 * @memberof awf.ui.Dropdown
		 * @param {string|element} val Whatever is passed here will replace the content of the dropdown
		 */
		setContent: function (val) {
			this.content = val;
			if (this._$content) {
				this._$content
					.empty()
					.append(val);
			}

			return this;
		},

		/**
		 * Sets the content width. When assigned, the position of the tip on the dropdown will move to be as close to the center as possible
		 * @memberof awf.ui.Dropdown
		 * @param {number} number 0 to infinity
		 * @emits change.content_width
		 */
		setContentWidth: function (number) {
			if (this._actual_content_width == number)
				return this;

			this.content_width = number;
			if (this._$content_wrapper) {
				this._$content_wrapper.css({
					width: number+'px'
				});
				this._actual_content_width = number;
			}

			this.triggerHandler('change.content_width');

			return this;
		},


		/**
		 * Shows the dropdown content
		 * @memberof awf.ui.Dropdown
		 * @emits show
		 */
		show: function () {
			// todo: Add unit tests
			console.log("Showing a dropdown!");
			var self = this;

			this.$el.addClass('awf-dropdown--active');
			this._$button
				.attr('aria-expanded','true')
				.focus()
				.find('.js-dropdown-action').eq(0).html("Hide");


			/*	Bind events
			------------------------------------------*/
				$('body')
					.on('click.dropdown_' + this._content_id, function(e) {
						if ( !self.$el.is(e.target) && self.$el.has(e.target).length === 0) {
							self.hide(true);
						}
					})
					.on('keyup.dropdown_' + this._content_id, function (e) {
						if (e.keyCode == awf.util.keyCodes.esc) {
							self.hide();
						}
					});

			/*	Tabloop
			------------------------------------------*/
				self._$loop_last
					.show()
					.on('focus', function () {
						self._$button.add(self._$content.find(':tabbable')).last().focus();
					});

				self._$loop_first
					.show()
					.on('focus', function () {
						self._$button.add(self._$content.find(':tabbable')).first().focus();
					});

			this.triggerHandler('show');

			return this;
		},

		/**
		 * Hides the dropdown content
		 * @memberof awf.ui.Dropdown
		 * @emits hide
		 */
		hide: function (do_not_focus) {
			// todo: Add unit tests -- unbinding events
			this.$el.removeClass('awf-dropdown--active');
			this._$button
				.attr('aria-expanded','false')
				.find('.js-dropdown-action').eq(0).html("Show");

			if ( ! do_not_focus) {
				this._$button.focus();
			}

			/*	Unbind events
			------------------------------------------*/
				$('body').off('click.dropdown_' + this._content_id + ' keyup.dropdown_' + this._content_id);
				this._$loop_last.hide().off('focus');
				this._$loop_first.hide().off('focus');

			this.triggerHandler('hide');

			return this;
		},


		/**
		 * Unbind `body` events
		 * @memberof awf.ui.Dropdown
		 *
		 * @return {object} self chainable
		 */
		destroy: function () {
			// todo: Add unit tests -- destroy
			var self = this;
			BaseUI.prototype.destroy.apply(this, arguments);

			$('body').off('click.dropdown_' + this._content_id + ' keyup.dropdown_' + this._content_id);

			return self;
		},


		/**
		 * Returns true when the dropdown is open/active/shown
		 * @return {Boolean}
		 * @memberof awf.ui.Dropdown
		 */
		isVisible: function () {
			return this._$content_wrapper.is(":visible");
		},





		/**
		 * Moves the dropdown by x/y pixels, and the tip y pixels (the tip remains centered on the icon)
		 * @param {object} coords Pass in x, y, or both. Use type `number`. Positive numbers move right/down, negative numbers move left/up.
		 * @memberof awf.ui.Dropdown
		 * @emits change.offset
		 */
		setOffset: function (coords) {
			if ( ! params || ! ('x' in params || 'y' in params))
				throw new Error("Dropdown setOffset requires a `coords` parameter that supplies x and/or y as numbers.");

			var changed = false;

			if ('x' in params) {
				if (params.x !== this.offset.x)
					changed = true;
				else
					this.setOffsetX(coords.x, true);
			}

			if ('y' in params) {
				if (params.y !== this.offset.y)
					changed = true;
				else
					this.setOffsetY(coords.y, true);
			}

			if (changed)
				this.triggerHandler('change.offset');

			return this;
		},

		/**
		 * Changes the x coordinate of the offset - moves the dropdown content, but *not* the tip.
		 * @param {Number} x              The horizontal offset. Positive numbers move right; negative numebrs move left.
		 * @param {Boolean} _silent_change OPTIONAL -- (meant for internal use). When true, the change event is *not* triggered.
		 * @memberof awf.ui.Dropdown
		 * @emits change.offset
		 */
		setOffsetX: function (x, _silent_change) {
			if (typeof(x) !== "number")
				throw new Error("Dropdown setOffsetX() only accepts a number. Was given " + typeof(x));

			this._actual_offset = this._actual_offset || {};
			if (this._actual_offset.x === x)
				return this;

			this.offset.x = x;
			this._applyOffset();

			if ( ! _silent_change)
				this.triggerHandler('change.offset');

			return this;
		},

		/**
		 * Changes the y coordinate of the offset - moves the dropdown content *and* the tip.
		 * @param {Number} y              The vertical offset. Positive numbers move right; negative numebrs move left.
		 * @param {Boolean} _silent_change OPTIONAL -- (meant for internal use). When true, the change event is *not* triggered.
		 * @memberof awf.ui.Dropdown
		 * @emits change.offset
		 */
		setOffsetY: function (y, _silent_change) {
			if (typeof(y) !== "number")
				throw new Error("Dropdown setOffsetY() only accepts a number. Was given " + typeof(y));

			this._actual_offset = this._actual_offset || {};
			if (this._actual_offset.y === y)
				return this;

			this.offset.y = y;
			this._applyOffset();

			if ( ! _silent_change)
				this.triggerHandler('change.offset');

			return this;
		},

		/**
		 * Returns the current offset coordinates
		 * @return {Object} Includes keys `x` and `y` -- e.g.: {x:0,y:0}
		 * @memberof awf.ui.Dropdown
		 */
		getOffset: function () {
			return this.offset;
		},


		/**
		 * Meant for internal use only. Applies this.offset values to the DOM
		 * Calling `setOffset`, `setOffsetX`, or `setOffsetY` will call this function.
		 * @private
		 * @memberof awf.ui.Dropdown
		 */
		_applyOffset: function () {
			var self = this;
			this._$content.css({
				'transform': 'translate(' + self.offset.x + 'px,' + self.offset.y + 'px)'
			});

			this._$tip_wrapper.css({
				'transform': 'translate(0,' + self.offset.y + 'px)'
			});
			this._actual_offset = this.offset;
		}

	});


/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-dropdown\">\n\t<button class=\"awf-access js-loop-to-last awf-dropdown__loop-last\" aria-hidden=\"true\">Loop to last</button>\n\t<label class=\"js-dropdown-label awf-access\"></label>\n\t<button class=\"js-dropdown-button awf-dropdown__button\" aria-expanded=\"false\" role=\"button\"></button>\n\t<div class=\"js-dropdown-wrapper awf-dropdown__wrapper\" role=\"region\">\n\t\t<div class=\"js-dropdown-content awf-dropdown__wrapper__content -background-base\"></div>\n\t</div>\n\t<div class=\"tip-wrapper\"><div class=\"tip -background-base\"></div></div>\n\t<button class=\"awf-access js-loop-to-first awf-dropdown__loop-first\" aria-hidden=\"true\">Loop to first</button>\n</div>\n";

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = GridItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base;

	use(BaseUI).toCreate(GridItem);

	/**
	 * GridItem UI Component
	 * @type {GridItem}
	 * @implements {GridItem}
	 * @memberOf awf.ui
	 * @constructor
	 * @augments {BaseUI}
	 * @requires jQuery
	 * @requires lodash
	 * @param  {object} params
	 * @param {number} params.col The column assignment of the grid item
	 * @param {number} params.row The row assignment of the grid item
	 * @param {number} params.col_span The colspan of the grid item
	 * @param {number} params.row_span The rowspan of the grid item
	 *
	 * @property {number} col_span The colspan assignment
	 * @property {number} row_span The rowspan assignment
	 * @property {number} col The column assignment
	 * @property {number} row The row assignment
	 * @property {awf.ui.Grid} grid The parent grid instance
	 *
	 * @example
	 *  // Creating a simple instance
	 *  var grid_item = new awf.ui.GridItem();
	 */
	function GridItem (params) {

		params = params || {};

		var self = this;

		this.collection = params.collection || this.collection || null;

		this._default_parent = function () {
			if (this.collection) {
				return $('.grid__inner-wrapper', self.collection.$el);
			}
			return null;
		};

		awf.util.mixin.collectionItem(this, params);

		this.template = __webpack_require__(110);
		BaseUI.apply(this, arguments);

		awf.util.mixin.properties(this, params, {

			/**
			 * @name setRow
			 * Sets the row assignment of the grid item
			 * @memberOf awf.ui.GridItem
			 * @type {function}
			 * @param {number} num               The new row assignment
			 * @return {object}                   this (chainable)
			 */
			row: {
				default: 0,
				handler: function () {
					this._applyOwnPosition();
				}
			},

			/**
			 * @name setCol
			 * Sets the column assignment of the grid item
			 * @memberOf awf.ui.GridItem
			 * @type {function}
			 * @param {number} num               The new column assignment
			 * @return {object}                   this (chainable)
			 */
			col: {
				default: 0,
				handler: function () {
					this._applyOwnPosition();
				}
			},

			/**
			 * @name setRowSpan
			 * Sets the rowspan of the grid item
			 * @memberOf awf.ui.GridItem
			 * @type {function}
			 * @param {number} num               The new rowspan
			 * @param {boolean} _silent (for internal use only) Updates the grid
			 * @return {object}                   this (chainable)
			 */
			row_span: {
				default: 1,
				handler: function () {
					this._applyPosition();
				}
			},
			
			/**
			 * @name setColSpan
			 * Sets the colspan of the grid item
			 * @memberOf awf.ui.GridItem
			 * @type {function}
			 * @param {number} num               The new colspan
			 * @param {boolean} _silent (for internal use only) Does not update the parent grid
			 * @return {object}                   this (chainable)
			 */
			col_span: {
				default: 1,
				handler: function () {
					this._applyPosition();
				}
			}

		});
	}



	_.extend(GridItem.prototype, {

		render: function () {
			BaseUI.prototype.render.call(this);
			this._applyPosition();
		},

		/**
		 * If part of a collection, the method is handed off to the collection. Otherwise calls _applyOwnPosition
		 * @memberOf awf.ui.GridItem
		 * @private
		 * @type {function}
		 * @return {object}                   this (chainable)
		 */
		_applyPosition: function () {
			if (this.collection)
				this.collection.applyPositions();
			this._applyOwnPosition();

			return this;
		},

		/**
		 * Applies the correct classnames, based on its own properties
		 * @memberOf awf.ui.GridItem
		 * @private
		 * @type {function}
		 * @param  {boolean} _silent (for internal use only) Does not update parent CSS
		 * @return {object}                   this (chainable)
		 */
		_applyOwnPosition: function (_silent) {
			if ( ! this.$el)
				return this;

			var classes = (this.$el.attr('class') || "").split(' ');

			_.remove(classes, function (cls) {
				return cls.search(/grid__item--[x|y|r|c]-/) === 0;
			});

			classes.push('grid__item--x-' + this.col);
			classes.push('grid__item--y-' + this.row);
			classes.push('grid__item--r-' + this.row_span);

			if (this.collection)
				classes.push('grid__item--c-' + Math.min(this.collection.columns, this.col_span));
			else
				classes.push('grid__item--c-' + this.col_span);

			this.$el.attr("class", classes.join(' '));

			if (this.collection && ! _silent)
				this.collection._updateCss();

			return this;
		},

		getCenter: function () {
			var self = this;
			return {
				x: (self.$el.width() / self.col_span) / 2,
				y: (self.$el.height() / self.row_span) / 2
			};
		}

	});




/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "<div class=\"grid__item\"></div>\n";

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Grid;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Base;

	use(Parent).toCreate(Grid);


	var grid_instance_id = 0;




	/**
	 * @typedef GridLocation
	 * @type Object
	 * @property {number} col The grid column
	 * @property {number} row The grid row
	 */


	/**
	 * @typedef GridLocationAndSpanning
	 * @type Object
	 * @property {number} col The grid column
	 * @property {number} row The grid row
	 * @property {number} col_span The grid column span
	 * @property {number} row_span The grid row span
	 */





	/**
	 * Grid UI Component
	 * @type {Grid}
	 * @class
	 * @implements {Grid}
	 * @memberOf awf.ui
	 * @constructor
	 * @augments {BaseUI}
	 * @requires jQuery
	 * @requires lodash
	 * Supports row and column spanning. A double-column tile's width = (base width * 2) + margin.
	 *
	 * @memberOf awf.ui
	 *
	 * @param  {Object} params
	 * @param {number} params.columns The number of columns. Accepts 1 to (how much memory does your computer have?)
	 * @param {number} params.max_columns (default 0) This is the upper limit to column count. Ignored when set to `0`.
	 * @param {boolean} params.animated When true, card position and sizing transitions of the grid are animated across 200ms.
	 * @param {boolean} params.debug When true, There is an added CSS spsuedo element to visibly indicate where grid items are positioned.
	 * @param {object} params.tile The base measurements of the grid tiles.
	 * @param {number} params.tile.width The width (min-width) of a 1x1 card
	 * @param {number} params.tile.max_width The max-width of a 1x1 card
	 * @param {number} params.tile.height The height of a 1x1 card
	 * @param {number} params.tile.margin The margin between any two cards
	 * @param {array} params.items An array of objects, each with row_span and col_span defined as the rowspan and colspan for that item.
	 *
	 *
	 * @property {string} id (autogenerated on instantiation) A unique ID string for this grid. Used as the ID attribute for the root DOM element.
	 * @property {string} template The template of the grid - NOT including GridItem
	 * @property {boolean} is_fluid (default false) True when the grid items act in a fluid width. False when a fixed width.
	 * @property {boolean} is_animated (default false) True when the grid will animate grid and grid item transitions
	 * @property {boolean} is_debug (default false) True will add a CSS psuedo element to each grid item that has background.
	 * @property {array} items (default []) An array of the grid items (tiles) - All of type GridItem
	 * @property {object} children The objects within here are recursively destroyed and rendered with the Grid
	 * @property {awf.ui.Stylesheet} children.stylesheet This holds all the styles for this grid and grid items.
	 * @property {number} columns The number of columns the grid currently has
	 * @property {number} max_columns (default 0) This is the upper limit to column count. Ignored when set to `0`.
	 *
	 *
	 * @example
	 * // Creating a simple instance
	 * var grid = new awf.ui.Grid();
	 *
	 * @example
	 * var grid = new awf.ui.Grid({
	 * 	columns: 3,
	 * 	max_columns: 10,
	 * 	tile: {
	 * 		width: 300,
	 * 		max_width: 400,
	 * 		height: 250,
	 * 		margin: 20
	 * 	},
	 * 	debug: true,
	 * 	animated: true,
	 * 	items: [
	 * 		{ row_span:1 , col_span:1 },
	 * 		{ row_span:1 , col_span:2 },
	 * 		{ row_span:1 , col_span:2 },
	 * 		{ row_span:1 , col_span:1 },
	 * 		{ row_span:1 , col_span:1 },
	 * 		{ row_span:1 , col_span:1 },
	 * 		{ row_span:1 , col_span:1 }
	 * 	]
	 * });
	 *
	 * @example
	 * // Want the grid to auto-audjust columns?
	 * var grid = new awf.ui.Grid(params);
	 * $(window).on('resize', grid.autoSetColumns);
	 *
	 */
	function Grid (params) {
		params = params || {};

		var self = this;

		_.defaults(params, {
			id: 'grid-' + awf.util.randomID()
		});

		this.template = __webpack_require__(112);

		this.is_fluid = params.fluid || false;
		this.is_animated = params.animated || false;
		this.is_debug = params.debug || false;

		this.view = params.view || this.view || null;

		params.tile = params.tile || {};
		this.tile = {
			width: params.tile.width || 0,
			height: params.tile.height || 0,
			margin: params.tile.margin || 0,
			max_width: params.tile.max_width || null
		};


		// Claim the stylesheet as a child
		// this way, when the grid is removed, so are its styles.
		this.children = {
			stylesheet: new awf.ui.Stylesheet()
		};

		this._map = new awf.__.Map(1);
		this.max_columns = params.max_columns || 0;
		this.setColumns(params.columns || 1);

		Parent.apply(this, [params]);

		awf.util.mixin.collection(this, params, {
			addItem: function (item) {
				var self = this,
					loc = this._map.findAndClaimSlot(Math.min(this.columns, item.col_span), item.row_span);
				item.setCol(loc.x, true);
				item.setRow(loc.y, true);
				item._applyOwnPosition();
			},
			removeItem: function (item) {
				item.destroy();
				this.applyPositions();
			},
			removeAllItems: function (item) {
				this.applyPositions();
			},
			setOrder: function (order) {
				if (order.length === 0)
					return false;

				var self = this,
					$parent = self.items[0].$el.parent();

				_.forEach(this.items, function (item) {
					$parent.append(item.$el);
				});

				// Updating visual position
				this.applyPositions();
			}
		});

		this.applyPositions();
	}



	Parent.generateDomProperties(Grid, {
		wrapper: '.js-wrapper'
	});



	_.extend(Grid.prototype, {

		Item: awf.ui.GridItem,

		render: function () {

			this._updateCss();

			Parent.prototype.render.call(this);

			this.applyPositions();

			this.setDebug(this.is_debug);

			this.setAnimated(this.is_animated);

			_.forEach(this.items, function (item) {
				item.render();
			});

			return this;
		},


		destroy: function () {
			_.forEach(this.items, function (item) {
				item.destroy();
			});

			Parent.prototype.destroy.apply(this, arguments);
		},


		_updateCss: function () {
			var i,
				self = this,
				css = {},
				css_string = '';

			var max_cols = Math.min(self.columns, _.max(this.items, function (item) { return item.col_span; }).col_span),
				max_rows = _.max(this.items, function (item) { return item.row_span; }).row_span,
				max_y = 1 + (_.max(this.items, function (item) { return item.row; }).row || 0);

			if (self.is_fluid) {
				css['#' + self.id] = {
					'min-width': self.tile.width + 'px'
				};

				if (self.tile.max_width) {
					var max_width = (self.columns * self.tile.max_width) + ((self.columns - 1) * self.tile.margin);
					css['#' + self.id]['max-width'] = max_width + 'px';
				}
			} else {
				css['#' + self.id] = {
					'width': ((self.columns * (self.tile.width + self.tile.margin)) - self.tile.margin) + 'px'
				};
			}


			css['#' + self.id + ' > .grid__inner-wrapper'] = {
				//height: ((Math.ceil(self.items.length / self.columns) * (self.tile.height + self.tile.margin)) - 0) + 'px',
				'margin': '0 -' + (self.tile.margin / 2) + 'px'
			};

			css['#' + self.id + ' > .grid__inner-wrapper > .grid__item'] = {
				'border': 'solid ' + (self.tile.margin / 2) + 'px transparent'
			};

			for (i=0; i<max_rows+2; i++) {
				css['#' + self.id + ' > .grid__inner-wrapper > .grid__item--r-' + (i+1)] = {
					'height': ((i+1) * (self.tile.height + self.tile.margin))+'px'
				};
			}

			for (i=0; i<max_y+2; i++) {
				css['#' + self.id + ' > .grid__inner-wrapper > .grid__item--y-' + i] = {
					'top': (i * (self.tile.height + self.tile.margin)) + 'px'
				};
			}

			css.comment = 'column ' + self.columns + ' specifics';
			for (i=0; i<max_cols+2; i++) {
				css['#' + self.id + ' > .grid__inner-wrapper > .grid__item--c-' + (i+1)] = {
					'width': ((100 / self.columns) * (i+1)) + '%'
				};
			}

			for (i=0; i<self.columns; i++) {
				css['#' + self.id + ' > .grid__inner-wrapper > .grid__item--x-' + i] = {
					'left': ((100 / self.columns) * i) + '%'
				};
			}


			_.forEach(css, function (pair, query) {
				if (query == "comment") {
					css_string += '\n/* ' + pair + ' */\n';
				} else {
					var props = [];
					_.forEach(pair, function (val, prop) {
						props.push(prop + ': ' + val);
					});
					css_string += query + ' { ' + props.join('; ') + '; }\n';
				}
			});

			this.children.stylesheet.css(css_string);
		},


		/**
		 * automatically set the number of columns, given the parent width tile width and margin.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @return {object} this (chainable)
		 */
		autoSetColumns: function () {
			if (this.tile.width === 0) {
				console.warn('Cannot calculate how many columns can fit when tile width is 0.');
				return this;
			}

			var style = this.$el.attr('style');
			this.$el.css({
				'width':'auto',
				'min-width':'auto',
				'max-width':'auto'
			});

			var measured = Math.floor((this.$el.parent().width() + this.tile.margin) / (this.tile.width + this.tile.margin)),
				columns_taken = 0;
			_.forEach(this.items, function (item) { columns_taken += item.col_span; });

			this.$el.attr('style', style);

			return this.setColumns(Math.min(columns_taken, measured));
		},


		/**
		 * Set the number of columns, and updates the DOM accordingly
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} num The number of columns
		 */
		setColumns: function (num) {
			if (arguments.length === 0)
				throw new Error("setColumns requires a number as the first (and only) parameter.");

			num = Math.max(1, num);

			if (this.max_columns !== 0)
				num = Math.min(this.max_columns, num);

			if (num === this.columns)
				return this;

			this.columns = num;
			this.applyPositions();
			return this;
		},


		setMaxColumns: function (num) {
			if (arguments.length === 0)
				throw new Error("setColumns requires a number as the first (and only) parameter.");

			if (num === null) {
				num = 0;
			}

			this.max_columns = num;

			if (this.max_columns < this.columns) {
				this.setColumns(this.max_columns);
			}

			return this;
		},


		/**
		 * Sets the tile width (pixels).
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} num The new pixel width
		 * @param {boolean} _silent (internal use only) Prevents the DOM from applying the change
		 */
		setTileWidth: function (num, _silent) {
			this.tile.width = num;
			if ( ! _silent)
				this.applyPositions();
			return this;
		},


		/**
		 * Sets the tile max-width (pixels). Only applied if this.is_fluid is set to true.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} num The new pixel max-width
		 * @param {boolean} _silent (internal use only) Prevents the DOM from applying the change
		 * @return {this} chainable
		 */
		setTileMaxWidth: function (num, _silent) {
			this.tile.max_width = num;
			if ( ! _silent)
				this.applyPositions();
			return this;
		},


		/**
		 * Sets the tile height (pixels)
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} num     The new pixel height
		 * @param {boolean} _silent (internal use only) Prevents the DOM from applying the change
		 */
		setTileHeight: function (num, _silent) {
			this.tile.height = num;
			if ( ! _silent)
				this.applyPositions();
			return this;
		},


		/**
		 * Sets the tile margin (pixels)
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} num     The new pixel margin
		 * @param {boolean} _silent (internal use only) Prevents the DOM from applying the change
		 */
		setTileMargin: function (num, _silent) {
			this.tile.margin = num;
			if ( ! _silent)
				this.applyPositions();
			return this;
		},


		/**
		 * A shortcut method to combine setTileWidth, setTileHeight, and setTileMargin
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} w The new tile width
		 * @param {number} h The new tile height
		 * @param {number} m The new tile margin
		 */
		setTile: function (w, h, m) {
			this.setTileWidth(w, true);
			this.setTileHeight(h, true);
			this.setTileMargin(m, true);
			this.applyPositions();
			return this;
		},


		/**
		 * Sets the fluid state of the grid. Updates the DOM accordingly
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {boolean} bool The new is_fluid value
		 */
		setFluid: function (bool) {
			this.is_fluid = bool;
			this._updateCss();
			return this;
		},


		/**
		 * Sets the animated state of the grid. Changes will be seen on the next transition.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {boolean} bool The new is_animated value
		 */
		setAnimated: function (bool) {
			this.is_animated = bool;
			this.$el[bool ? "addClass" : "removeClass"]('grid--animated');
			return this;
		},

		/**
		 * Sets the debug state of the grid. Updates the DOM accordingly.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {boolean} bool The new is_debug value
		 */
		setDebug: function (bool) {
			this.is_debug = bool;
			this.$el[bool ? "addClass" : "removeClass"]('grid--debug');
			return this;
		},


		/**
		 * Applies the correct classname for the number of columns, and removes any others.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @private
		 * @return {object} this (chainable)
		 */
		_applyColumnClassname: function () {
			if ( ! this.$el)
				return this;

			var self = this,
				classes = (this.$el.attr('class') || "").split(' ');

			_.remove(classes, function (cls) {
				return cls.search(/-is-\d+-col/) === 0;
			});

			classes.push('-is-' + self.columns + '-col');

			this.$el.attr("class", classes.join(' '));

			return this;
		},


		/**
		 * Updates the CSS for the Grid and its items, assigns item positions, and updates the grid height.
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @return {object} this (chainable)
		 */
		applyPositions: function () {
			var self = this;

			var map = this._map;
			map.setCols(this.columns);
			map.reset();

			var max = 0;

			_.forEach(this.items, function (item, i) {
				var col_span = Math.min(self.columns, item.col_span),
					row_span = item.row_span,
					loc = map.findAndClaimSlot(col_span,row_span);

				max = Math.max(max, loc.y + row_span);

				item.setRow(loc.y);
				item.setCol(loc.x);
				item._applyOwnPosition();
			});

			self._updateCss();
			this.setHeight(max);
			this._applyColumnClassname();

			return this;
		},

		/**
		 * Sets the height of the Grid based on the given row count
		 * @memberOf awf.ui.Grid
		 * @type {function}
		 * @param {number} rows The number of rows
		 */
		setHeight: function (rows) {
			if ( ! this.$el)
				return this;

			var self = this;

			if (arguments.length === 0) {
				var max = 0;

				_.forEach(this.items, function (item, i) {
					max = Math.max(max, item.row + item.row_span);
				});

				self.setHeight(max);
			} else {
				this.$el.css({
					height: rows * (self.tile.height + self.tile.margin) - (self.tile.margin / 2)
				});
			}
		},








		// Move to CogGrid
		addCog: function (cog) {
			if ( ! (cog instanceof awf.__.Cog)) {
				cog = awf.app.experience.cogs[cog];
			}

			if ( ! cog.isAvailable())
				throw new Error("Cannot add cog `" + cog.type + "` to grid. The entire cog is disabled from the feature flag: `" + cog.flag + "`");

			if ( ! this.view)
				throw new Error("Cannot add cog `" + cog.type + "` to grid. A view type not been defined for this grid.");

			if (cog.isViewAvailable(this.view) === null)
				throw new Error("Cannot add cog `" + cog.type + "` to grid. View type `" + this.view + "` has not been defined for cog `" + cog.type + "`.");

			if (cog.isViewAvailable(this.view) === false)
				throw new Error("Cannot add cog `" + cog.type + "` to grid. The `" + this.view + "` view is disabled from the feature flag: `" + cog.views[this.view].flag + "`");

			var handler = Grid.cog_view_handlers[this.view];
			if ( ! handler)
				throw new Error("Cannot add cog `" + cog.type + "` to grid. No handler has been defined for view `" + this.view + "`.");

			return handler.call(this, cog);
		},


		removeCog: function (cog) {
			var id = null;
			if (cog instanceof awf.__.Cog)
				id = cog.id;
			else
				id = cog;

			var index = -1;
			_.forEach(this.items, function (item, i) {
				if (item.cog_id == id)
					index = i;
			});

			if (index === -1)
				return null;
			else
				return this.removeItem(index);
		}

	});





	Grid.cog_view_handlers = {

		medium: function (cog) {

			cog._maybeSetupCog();
			cog._maybeInitializeView('medium');

			/*	Grid Item
			------------------------------------------*/
				var self = this,

					can_have_large_card = cog.isViewAvailable('large'),

					grid_item = self.addItem({
						row_span: cog.views.medium.rowspan || 1,
						col_span: cog.views.medium.colspan || 1
					}),
					medium_card = new awf.ui.TitledCard({
						title: cog.views.medium.label || null,
						parent : function () { return grid_item.$el; }
					}),
					large_card = null;

				if (can_have_large_card) {
					large_card = new awf.ui.LargeCard({
						title: cog.views.large.label || null
					});
				}
				grid_item.children.medium_card = medium_card;
				grid_item.children.large_card = large_card;

				grid_item.cog_id = cog.id;


				/*	Badges
				------------------------------------------*/
					function applyBadgeNumber () {
						var cog_badges = _.get(awf, 'badge_db.dimensions.cog.groups.' + cog.id + '.items') || [],
							medium_badges = [];
						_.forEach(cog_badges, function (badge) {
							if (badge.experience === null || badge.experience == awf.app.experience.id) {
								if (badge.view === null || badge.view == 'medium') {
									medium_badges.push(badge.content);
								}
							}
						});
						medium_card.children.badge
							.setNumber(medium_badges.length)
							.setTooltip(medium_badges.join('\n'));

						// console.log('medium_badges: ', medium_badges);
					}
					applyBadgeNumber();
					awf.badge_db.on('change change:item.'+cog.id+'.medium-badge', applyBadgeNumber);
					medium_card.on('destroy', function () {
						awf.badge_db.on('change:item.'+cog.id+'.medium-badge');
					});


			if (can_have_large_card) {
				medium_card._$card
					.attr({
						"role": "region",
						"aria-label": cog.views.medium.label + " Card"
					});
				medium_card._$title
					.attr({
						"role": "heading",
						"aria-label": "Click to Show Large Card"
					});

				/*	Flip Handler
				------------------------------------------*/
					medium_card.on('flip-half-complete', function () {
						try {
							large_card._$card
								.attr({
									"role": "region",
									"aria-label": cog.views.large.label + " Card"
								});

							if (awf.modal) {
								awf.modal.setLabel(cog.views.large.label + " Dialog Window");
							}

							large_card.view_instance = cog.renderView('large', large_card._$content, {
								card: large_card
							});
						} catch (er) {
							large_card.setContent('Failed to render `' + cog.id + '` large view.');
							throw er;
						}
					});

					large_card.on('flip-complete', function () {
						if (large_card.view_instance)
							large_card.view_instance.destroy();
					});

					awf.util[awf.app.experience.transition || 'bindFlipper'](medium_card,large_card);
			}

			/*	Rendering
			------------------------------------------*/
				try {
					cog.renderView('medium', medium_card._$content, {
						context: 'grid',
						card: medium_card,
						grid_item: grid_item
					});
				} catch (er) {
					medium_card.setContent('Failed to render `' + cog.id + '` medium view.');
					throw er;
				}

			return grid_item;
		},

		mini: function (cog) {
			cog._maybeSetupCog();
			cog._maybeInitializeView('mini');


			/*	Grid Item
			------------------------------------------*/
				var view = cog.views.mini,

					can_have_large_card = cog.isViewAvailable('large'),

					grid_item = this.addItem(),
					card = new awf.ui.IconCard({
						title: view.label || null,
						icon: view.icon || null,
						parent : function () { return grid_item.$el; }
					});

				grid_item.children.card = card;
				grid_item.cog_id = cog.id;



				/*	Badges
				------------------------------------------*/
					function applyBadgeNumber () {
						var cog_badges = _.get(awf, 'badge_db.dimensions.cog.groups.' + cog.id + '.items') || [],
							mini_badges = [];
						_.forEach(cog_badges, function (badge) {
							if (badge.experience === null || badge.experience == awf.app.experience.id) {
								if (badge.view === null || badge.view == 'mini') {
									mini_badges.push(badge.content);
								}
							}
						});
						card.children.badge
							.setNumber(mini_badges.length)
							.setTooltip(mini_badges.join('\n'));

						//console.log('mini_badges: ', mini_badges);
					}
					applyBadgeNumber();
					awf.badge_db.on('change change:item.'+cog.id+'.mini-badge', applyBadgeNumber);
					card.on('destroy', function () {
						awf.badge_db.on('change:item.'+cog.id+'.mini-badge');
					});



				/*	large card
				------------------------------------------*/
					var large_card = null;
					if (can_have_large_card) {
						large_card = new awf.ui.LargeCard({
							title: cog.views.large.label || null
						});
					}
					grid_item.children.large_card = large_card;



			if (can_have_large_card) {
				/*	Flip Handler
				------------------------------------------*/
					card.on('flip-half-complete', function () {
						try {
							large_card._$card
								.attr({
									"role": "region",
									"aria-label": cog.views.large.label + " Card"
								});

							if (awf.modal) {
								awf.modal.setLabel(cog.views.large.label + " Dialog Window");
							}

							large_card.view_instance = cog.renderView('large', large_card._$content, {
								card: large_card
							});
						} catch (er) {
							large_card.setContent('Failed to render `' + cog.id + '` large view.');
							throw er;
						}
					});

					large_card.on('flip-complete', function () {
						if (large_card.view_instance)
							large_card.view_instance.destroy();
					});

					awf.util[awf.app.experience.transition || 'bindFlipper'](card,large_card);
			}

			/*	Rendering
			------------------------------------------*/
				if (view.render) {
					try {
						card.view_instance = cog.renderView('mini', card._$card, {
							card: card
						});
					} catch (er) {
						card._$title.append(' [ failed ]');
						card._$card.attr('title','Failed to render `' + cog.type + '` mini view.');
						throw er;
					}
				}

			return grid_item;
		}

	};






/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "<div class=\"grid\">\n\t<div class=\"grid__inner-wrapper js-wrapper\"></div>\n</div>\n";

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ArrangeableGrid;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Grid;

	use(Parent).toCreate(ArrangeableGrid);


	/**
	 * A grid that can be arranged (drag-n-drop, or merely changing the order through setOrder/promote/demote methods)
	 * @param {object} params Standard params for any UI object
	 *
	 * @class
	 * @memberOf awf.ui
	 *
	 * @property {null|awf.__.GridItem} _grabbed Null when nothing is currently being dragged. The GridItem that is being dragged.
	 * @property {boolean} _grabbed.skip_when_mapping True when something is being dragged. This tells the applyPositions to ignore it when assigning positions.
	 * @property {null|awf.__.GridItem} ghost Null when there is no Ghost. A GridItem instance that operates as the "ghost" or "placeholder" for where a dragging element will land if released.
	 * @property {boolean} ghost.is_in_domain True when the assigned position of the ghost is within the left, right, and top limits of the grid.
	 */
	function ArrangeableGrid (params) {
		Parent.apply(this, arguments);

		this._grabbed = null;
		this.ghost = null;
		this._is_dragging_within_domain = null;
	}

	_.extend(ArrangeableGrid.prototype, {

		/**
		 * Returns the grid col/row based on the x/y offset from the top/left corner of the grid
		 * @memberOf awf.ui.ArrangeableGrid
		 * @param  {object} loc The offset to the top/left corner of the grid
		 * @param  {number} loc.x The distance in px from the left edge of the grid
		 * @param  {number} loc.y The distance in px from the top edge of the grid
		 * @return {GridLocation}
		 */
		getLocation: function (loc) {
			return {
				col: Math.floor(loc.x / (this._$wrapper.width() / this.columns)),
				row: Math.floor(loc.y / (this.tile.height + this.tile.margin))
			};
		},


		/**
		 * Takes a GridLocation and puts the ghost there. Then when applyPositions is called, it will show up and push things around it.
		 * @memberOf awf.ui.ArrangeableGrid
		 * @param {GridLocationAndSpanning|GridLocation} loc The location to show the ghost. Important: must supply GridLocationAndSpanning the first time.
		 * @return {object} this (chainable)
		 */
		setGhost: function (loc) {
			var self = this;

			if ( ! loc) {
				if (this.ghost) {
					this.ghost.destroy();
				}
				this.ghost = null;
			} else {

				if ('x' in loc && 'y' in loc) {
					var pos = this.getLocation(loc);
					loc.col = pos.col;
					loc.row = pos.row;
					delete loc.x;
					delete loc.y;
				}

				var newly_rendered = false;

				if ( ! this.ghost) {
					newly_rendered = true;
					this.ghost = new this.Item({
						col: loc.col,
						row: loc.row,
						col_span: loc.col_span,
						row_span: loc.row_span,
						collection: self
					});
					this.ghost.$el.addClass('-ghost');
				} else {
					_.extend(this.ghost, loc);
				}

				this.ghost.is_in_domain = self.isLocInDomain(this.ghost);

				if (this.ghost.is_in_domain && ! newly_rendered) {
					this.ghost._applyOwnPosition();
				}

				this.ghost.$el[this.ghost.is_in_domain ? 'removeClass' : 'addClass']('-hidden');
			}

			return this;
		},



		isLocInDomain: function (loc) {
			return loc.col > -1 && loc.row > -1 && loc.col + loc.col_span < this.columns + 1;
		},


		isPointInDomain: function (point) {
			var loc = this.getLocation(point);
			return loc.col > -1 && loc.row > -1 && loc.col < this.columns;
		},


		/**
		 * Sets a GridItem to be ignored (skipped) during the mappig process
		 * @memberOf awf.ui.ArrangeableGrid
		 * @param {awf.ui.GridItem} item The item to be ignored
		 * @return {object} this (chainable)
		 */
		setGrabbedItem: function (item) {
			var self = this;

			if (item === null) {
				if (self._grabbed) {
					self._grabbed.skip_when_mapping = false;
				}
				self._grabbed = null;
			} else {
				self._grabbed = item;
				self._grabbed.skip_when_mapping = true;
			}

			return this;
		},

		/**
		 * Applies the positions of the grid items. If an item has `skip_when_mapping`, it is entirely ignored. If there is a ghost, that item is placed first (and last), allowing other items to "wrap around" it.
		 * @memberOf awf.ui.ArrangeableGrid
		 * @return {object} this (chainable)
		 */
		applyPositions: function () {
			var self = this;

			if ( ! this.ghost) {
				return Parent.prototype.applyPositions.apply(this,arguments);
			}

			var map1 = new awf.__.Map(),
				map2 = new awf.__.Map();
			map1.setCols(this.columns);
			map2.setCols(this.columns);

			if (this.ghost.is_in_domain) {
				map1.claim(this.ghost);
			}

			_.forEach(this.items, function (item, i) {
				if ( ! item.skip_when_mapping) {
					var col_span = Math.min(self.columns, item.col_span),
						row_span = item.row_span,
						loc = map1.findAndClaimSlot(col_span,row_span);
					map2.claim(loc.x,loc.y,col_span,row_span);
				}
			});

			map1.reset();

			if (this.ghost.is_in_domain) {
				var col_span = this.ghost.col_span,
					row_span = this.ghost.row_span,
					ghost_loc = map2.findAndClaimSlot(col_span,row_span),
					col = ghost_loc.x,
					row = ghost_loc.y;

				map1.claim(col,row,col_span,row_span);
				this.ghost.setCol(col);
				this.ghost.setRow(row);
			}


			_.forEach(this.items, function (item, i) {
				if (item.skip_when_mapping) {
					item.visible_index = -1;
					self.ghost.visible_index = i;
				} else {
					var w = Math.min(self.columns, item.col_span),
						h = item.row_span,
						loc = map1.findAndClaimSlot(w,h);

					item.visible_index = i;

					item.setCol(loc.x);
					item.setRow(loc.y);
				}
			});

			return this;
		},


		/**
		 * Returns the new order (via visual reference) of the items.
		 * @memberOf awf.ui.ArrangeableGrid
		 * @return {array} an array of index positions. If the order was left alone, it should return an array like [0,1,2,3] (for a grid of 4 items) Spanning is irrelevant; a no-gap order is returned.
		 */
		getNewOrder: function () {

			var self = this,
				col_count = this.columns,
				positions = [];

			_.forEach(this.items, function (item) {
				var position_holder = item.skip_when_mapping ? self.ghost : item;
				if (position_holder) {
					var order_val = position_holder.col + (position_holder.row * col_count);
					positions.push({
						index: item.index(),
						order: order_val
					});
				}
			});

			var new_order = _.sortBy(positions, 'order');
			return _.map(new_order, 'index');
		},




		_getIndexes: function () {
			var self = this,
				col_count = this.columns,
				positions = [];

			_.forEach(this.items, function (item, i) {
				if ( ! item.skip_when_mapping) {
					var order_val = item.col + (item.row * col_count);
					positions.push({
						index: i,
						order: order_val
					});
				}
			});

			if (this.ghost) {
				var order_val = this.ghost.col + (this.ghost.row * col_count);
				positions.push({
					index: -1,
					order: order_val
				});
			}

			var new_order = _.sortBy(positions, 'order'),
				indexes = _.map(new_order, 'index');

			return indexes;
		},



		getVisibleIndexes: function () {
			var self = this,
				indexes = this._getIndexes();

			var visible_indexes = [],
				seen_a_ghost = false;
			_.forEach(indexes, function (index) {
				if (index === -1) {
					seen_a_ghost = true;
				} else {
					visible_indexes.push(index + (seen_a_ghost ? 1 : 0));
				}
			});

			return visible_indexes;
		},


		getGhostIndex: function () {
			var self = this,
				indexes = this._getIndexes();

			var ghost_index = -1;
			_.forEach(indexes, function (index, i) {
				if (index === -1) {
					ghost_index = i;
				}
			});

			return ghost_index;
		}

	});


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = IconCard;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		Card = awf.ui.Card,
		BaseUI = awf.ui.Base,
		template = __webpack_require__(115);

	use(Card).toCreate(IconCard);

	/**
	 * IconCard UI Component
	 * @type {IconCard}
	 * @class
	 * @implements {IconCard}
	 * @memberOf awf.ui
	 *
	 * @param {object}	params
	 * @param {string}	params.title	The IconCard's title.
	 * @param {string}	params.icon		The IconCard's icon
	 *
	 * @property {string}	title		The IconCard's title. Initial value set to null unless passed a value on instantiaion.
	 * @property {string}	icon		The IconCard's icon. Initial value set to null unless passed a value on instantiation.
	 * @property {string}	aria_id		A random id used for aria labelling.
	 * @property {object}	_$icon 		A jQuery reference to the icon wrapper
	 * @property {object}	_$title 	A jQuery reference to the title container
	 *
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 *
	 * @example
	 * // Creating a simple instance
	 * // render() is called on instantiation
	 * var icon_card = new awf.ui.IconCard();
	 *
	 * @example
	 * // Pass some parameters to start
	 *
	 * var icon_card = new awf.ui.IconCard({
	 *   title: "Hello World",
	 *   icon: "awficon-like"
	 * });
	 *
	 */
	function IconCard (params) {
		
		params = params || {};
		
		//Extend Superclass template
		var self = this,
			$card = $(awf.ui.Card.template),
			$div = $('<div></div>');

		$card
			.addClass('-icon-card')
			.addClass('js-drag-handle');
		$card.find('.js-card')
			.attr({
				'role':'button',
				'aria-expanded':'false'
			})
			.append($(template));

		$div.append($card);

		this.template = $div.html();

		Card.apply(this, arguments);

		awf.util.mixin.properties(this, params, {

			/**
			 * @memberof awf.ui.IconCard
			 * @name setTitle
			 * @function
			 * @param  {null|string} val The title to set
			 * @return {object} self chainable
			 */
			title: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					if (val === null)
						val = '';

					this._$title
						.html(val);
				}
			},

			/**
			 * If passed a string, it will be added as a classname
			 * for an icon-font. If passed a jQuery object, it will
			 * append it to this._$icon.
			 * @memberof awf.ui.IconCard
			 * @name setIcon
			 * @function
			 * @param {null|string} val The icon-font classname to set.
			 * @return {object} self chainable
			 */
			icon: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					if (val === null) {
						this._$icon.empty();
					} else {
						this._$icon
							.html('<em class="' + val + '"></em>');
					}
				}
			}

		});

	}


	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(IconCard, {
			icon: '.js-card-icon-icon',
			title: '.js-card-icon-text'
		});


	_.extend(IconCard.prototype, {

		/**
		 * Renders the IconCard. This includes automatically calling
		 * setTitle and/or setContent if they were defined during
		 * instantiation, and setting up appropriate event handlers.
		 * @memberof awf.ui.IconCard
		 *
		 * @return {Object} self chainable
		 */
		render: function () {
			var self = this;

			Card.prototype.render.apply(self, arguments);

			//Events
			/**
			 * @type {Object}
			 * @name _$title.on
			 * @function
			 * @memberof awf.ui.IconCard
			 * @listens this._$card#click
			 * @fires this#request-open
			 */
			self._$card.on('click', function () {
				self.triggerHandler('request-open');
			});

			/**
			 * @type {Object}
			 * @name $el.on
			 * @function
			 * @memberof awf.ui.IconCard
			 * @listens this._$card#keyup
			 * @fires this#request-open
			 */
			self._$card.on("keyup", function (e) {
				var $target = $(e.target);

				//not the container? don't do anything
				if( $target[0] != self._$card[0])
					return;

				//IF ENTER, act like someone clicked on the title.
				if(e.keyCode === awf.util.keyCodes.enter){
					self.triggerHandler("request-open");
				}
			});

			return self;
		}

	});


/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-card__icon\">\n\t<div class=\"js-card-icon-icon awf-card__icon__icon -color-link\"></div>\n\t<span class=\"js-card-icon-text awf-card__icon__text -color-link\"></span>\n</div>\n";

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ImageCircle;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = _.template(__webpack_require__(117));

	use(BaseUI).toCreate(ImageCircle);

	/**
	 * Image Circle UI Component
	 * @type {ImageCircle}
	 * @implements {ImageCircle}
	 * @memberOf awf.ui
	 * @class
	 *
	 * @augments {BaseUI}
	 * @private
	 * @requires jQuery
	 * @requires lodash
	 * @param  {Object} params
	 * @param {string} [element_type="div"] The type of element this should be (e.g. "a", "div", "button", etc)
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var image_circle = new awf.ui.ImageCircle();
	 *
	 */
	function ImageCircle (params) {
		params = params || {};

		this.size = params.size || 0;
		this.url = params.url || null;
		this.element_type = params.element_type || "div";
		params.template = template({element_type: this.element_type});

		//console.log("Creating an ImageCircle with size: ", params.size);

		BaseUI.call(this, params);
	}



	_.extend(ImageCircle.prototype, {

		render: function () {
			//console.log("Rendering ImageCircle");
			BaseUI.prototype.render.apply(this, arguments);


			if (this.size !== null && this.size !== undefined)
			{
				//console.log("Setting size to ", this.size);
				this.setSize(this.size);
			} else {
				//console.log("NOT setting size...");
			}

			if (this.url !== null && this.url !== undefined)
				this.setUrl(this.url);
		},

		/**
		 * @memberOf ImageCircle
		 * @param {string} url The URL to the image to show within the circle
		 * @emits change.url
		 */
		setUrl: function (url) {
			this.url = url;

			if ( ! this.$el)
				return this;

			if (this._actual_url === url)
				return this;

			this.$el.css({
				"background-image": 'url(' + url + ')'
			});
			this._actual_url = url;

			this.trigger('change.url', url);

			return this;
		},

		/**
		 * @memberOf ImageCircle
		 * @param {string|number} The width/height of the circle, including the border. When a string, the sizes are applied directly. When a number, `px` is appended.
		 * @emits change.size
		 */
		setSize: function (number) {
			if (this._actual_size === number)
				return this;

			if (typeof number !== "number") {
				throw new Error("ImageCircle setSize only accepts type `number`");
			}

			this.size = number;

			this.$el.css({
				"width": number,
				"height": number
			});
			this._actual_size = number;

			this.trigger('change.size', number);

			//console.log("Size has been set to ", this.size);

			return this;
		}

	});


/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = "<{{element_type}} class=\"image-circle -background-alt\"></{{element_type}}>\n";

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Layout;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);

	awf.util.use(awf.ui.Base).toCreate(Layout);

	/**
	 * A Layout
	 * @class
	 * @tutorial app-comp-layouts
	 *
	 * @param {Object}	params
	 * @param {String}	params.type						Declares the type of layout.
	 * @param {Object}	[params.default_order]			If using grid, this has the default order for the cogs
	 * @param {Object}	[params.grid_header]			Parameters for the empty header (an area over the main grid that appears when no cards are present)
	 * @param {String}	params.grid_header.snippet		A reference to a registered awf snippet
	 * @param {String}	[params.transition]				Overrides the default type of card transition
	 *
	 * @memberOf awf.ui
	 * @property {object}				children		Object containing UI elements that will be rendered/destroyed with this one
	 * @property {awf.ui.Stylesheet}	stylesheet		A stylesheet that will hold the styles for the rendered layout.
	 * @property {object}				default_order	An object containing the various groups of cogs
	 *
	 */
	function Layout (params) {
		params = params || {};

		console.group(_.template('Constructing Layout `{{type}}`')(_.defaults({}, params, {type:'?'})));
		console.log('params: ', params);

		/*	Properties Mixin
		------------------------------------------*/
			awf.util.mixin.properties(this, params, {
				/**
				 * setType
				 * @name setType
				 * @function
				 * @instance
				 * @memberOf awf.ui.Layout
				 * @param {string} new_val The new value of the type
				 * @param {boolean} _silent Set true to ONLY update the property, and avoid firing of events
				 * @return {obect} this (chainable)
				 */
				type: {
					default: 'content',
					types: ['string']
				}
			}, 'layout'); // 'layout' is needed for unit testing


		/*	Basic Properties
		------------------------------------------*/
			this._last_rendered_preset = null;
			this.children = _.extend({}, this.children, params.children);
			this.experience = params.experience || this.experience || null;
			this.grid_header = params.grid_header || null;
			this.force_mini = params.force_mini || this.force_mini || false;


		/*	Stylesheet
		------------------------------------------*/
			if ( ! this.children.stylesheet) {
				this.children.stylesheet = new awf.ui.Stylesheet({
					render: false // if the layout's render is disabled, don't render this.. If it's left alone, calling Base constructer below will take care of it
				});
			}


		/*	Cogs
		------------------------------------------*/
			this.default_order = params.default_order || this.default_order || {};
			this.cog = params.cog || this.cog || null;

		// Call the parent constructor
		awf.ui.Base.apply(this, arguments);

		console.groupEnd();
	}

	_.extend(Layout.prototype, {

		/**
		 * Renders the layout, based on this.type
		 * If the preset[type] is undefined, it will throw an error.
		 * @memberOf awf.ui.Layout
		 * @instance
		 *
		 * @return {object} this (chainable)
		 */
		render: function () {

			var self = this,
				preset = Layout.presets[this.type];

			if ( ! preset) {
				throw new Error('Layout preset not defined: ' + this.type);
			}

			this._last_rendered_preset = preset;

			this.template = preset.template || null;
			this.children.stylesheet.content = preset.css || null;

			awf.ui.Base.prototype.render.apply(this, arguments);

			this.children.stylesheet.$el.attr('data-purpose', 'layout : ' + this.type);

			this.build();

			return this;
		},


		/**
		 * Runs through the build process of the given type.
		 * @description Any of the following may be defined.
		 * They will always go in this order.
		 * If any are undefined, they will be skipped.
		 * Each step must return a promise.
		 * The response to the promises resolution will be used as the arguments for the next step.
		 * The last step's resolution will be used as the overal response.
		 * @memberOf awf.ui.Layout
		 * @instance
		 * @return {$.Deferred} When the process completes, the promise will resolve. If any step fails, this will too.
		 */
		build: function () {

			console.log('Kicking off layout build sequence for `' + this.type + '`...');


			var self = this,
				dfr = $.Deferred(),
				preset = Layout.presets[this.type];

			console.time('layout build');

			var potential_step_names = [
					'setup',
					'preferenceParser',
					'addCogs',
					'setupComplete'
				],
				kinetic_step_names = [],
				kinetic_callbacks = [];


			_.forEach(potential_step_names, function (name) {
				if (name in preset) {
					kinetic_callbacks.push(preset[name]);
					kinetic_step_names.push(name);
				}
			});

			this.sequence_start = new Date();

			var sequence = awf.util.runPromiseSequence.call(this, kinetic_callbacks)
					.always(function () {

						console.timeEnd('layout build');

						self.sequence_end = new Date();
						self.sequence_duration = self.sequence_end - self.sequence_start;

						// Now that we're through, stop worrying about aborting the sequence
						awf.app.off('change:experience.layout');
					})
					.done(function () {
						console.log('Build sequence for `' + self.type + '` complete!');
						console.log('Layout build took ' + (self.sequence_duration / 1000) + ' seconds.');
						dfr.resolve();
					})
					.fail(function (er) {
						if (preset.fail)
							preset.fail.call(self, er);
						console.warn('Layout build sequence for `' + self.type + '` failed.');
						console.error(er);
						dfr.reject(er);
					});

			// If the experience changes, abort the sequence
			awf.app.one('change:experience.layout', function () {
				console.warn('Experience has changed. Aborting layout build sequence.');
				sequence.cancel();
			});

			return dfr.promise();
		},


		/**
		 * Destroys the layout, and calls the preset's teardown method (if defined)
		 * @memberOf awf.ui.Layout
		 * @instance
		 */
		destroy: function () {

			var preset = this._last_rendered_preset;

			if (preset && preset.teardown) {
				preset.teardown.call(this);
			}

			awf.ui.Base.prototype.destroy.apply(this, arguments);
		}

	});



	// * The presets for Layout
	// * @static
	// * @type {Object}
	// *
	// * When a layout is rendered, this object will be inspected for coresponding type.
	// * Extend this object to add layouts.
	// *
	// * @example
	// * _.extend(Layout.presets, {
	// *
	// * 	some_fancy_layout: {
	// * 		template: '<div><h2></h2><p></p></div>'
	// * 		css: '#layout h2 { color : "#090"; margin: 0 0 20px; text-align: center; }'
	// * 	}
	// *
	// * });
	// *

	Layout.presets = {};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(128);
	__webpack_require__(129);


/***/ },
/* 120 */
/***/ function(module, exports) {

	_.extend(awf.ui.Layout.presets, {

		'content': {}

	});


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @extends awf.ui.Layout.layoutConfig
	 *
	 * @property {object} test_extension Testing
	 *
	 */

	var $ = __webpack_require__(4);

	_.extend(awf.ui.Layout.presets, {

		'grid': {
			css: __webpack_require__(122),
			template: __webpack_require__(123),


			setup: function () {

				var self = this,
					grid_default_dfr = $.Deferred(),
					$parent = awf.$('#grid', this.$el);

				// Creating a spinner for the grid
				this.spinners = this.spinners || {};
				this.spinners.grid = new awf.ui.Spinner({
					parent: $parent
				});

				// todo: check to see if `then` == `always`
				awf.user.authentication.always(function () {

					if ( ! awf.page) {
						grid_default_dfr.reject('awf.page is not defined');
						return false;
					}

					/*	Grid -- awf.page.grid
					------------------------------------------*/
						awf.page.grid = new awf.ui[awf.user.is_authenticated ? 'ArrangeableGrid' : 'Grid']({
							parent: $parent,
							columns: 3,
							tile: {
								width: 300,
								max_width: 400,
								height: 360,
								margin: 20
							},
							view: 'medium'
						});

						awf.drag_handler.registerParticipant('grid', awf.page.grid);


					/*	Starting up the cogs
					------------------------------------------*/
						var default_cogs = [];

						awf._.forEach(self.default_order.grid, function(cog_params, i) {

							var default_cog;

							console.group('Setting up ', cog_params);

							try {
								var cog = awf.app.experience.getOrCreateCog(cog_params);
								cog.default_grid = 'grid';
								default_cogs.push(cog);
							} catch (er) {
								console.warn("Cannot get cog: ", cog_params);
								console.error(er);
							}

							console.groupEnd();
						});

						console.log('grid default cogs: ', _.map(default_cogs, 'id'));

						// now that we have the default cogs, if custom fails, automatically resolve to default
						grid_default_dfr.resolve(default_cogs);

				});

				console.groupEnd();

				return grid_default_dfr.promise();
			},


			preferenceParser: function (default_cogs) {

				console.time('preference parser');

				var preference_order_dfr = $.Deferred(),
					final_order_dfr = $.Deferred();

				final_order_dfr
					.always(function () {
						console.timeEnd('preference parser');
					});

				preference_order_dfr
					.always(function () {
						console.timeEnd('preference parser');
					})
					// If we have a preference_order, pass it along as the final_order
					.done(function (cogs) {
						console.info('Custom order for grid has been resolved: ' + _.map(cogs, 'id'));
						final_order_dfr.resolve(cogs);
					})
					// If custom fails, automatically resolve to default
					.fail(function (er) {
						// Yes, this is info, not warning. It could be intended.
						console.info('Custom order for grid has been rejected: ' + er);
						final_order_dfr.resolve(default_cogs);
					});


				/*	If authenticated, check for an updated order
				------------------------------------------*/
					if (awf.user.is_authenticated) {

						/*	Preference Loading
						------------------------------------------*/
							awf.app.experience.fetchPreferences(1000)
								.done(function (preferences) {

									if (preferences && preferences.grid) {
										var saved_order = preferences.grid;
										console.log('Saved order found for grid: ', saved_order);
										var new_order = [];
										_.forEach(saved_order, function (id) {
											var cog = awf.app.experience.cogs[id];
											if (cog) {
												new_order.push(cog);
											}
										});


										/*	Master List of given and saved cog ids
										------------------------------------------*/
											var saved_ids   = _.unique(preferences.grid),
												given_ids   = _.map(awf.app.experience.cogs, "id"),
												added_ids   = _.difference(given_ids, saved_ids);


										/*	add the new
										------------------------------------------*/
											_.forEach(added_ids, function (id) {
												var cog = awf.app.experience.cogs[id];
												if (cog.default_grid == "grid") {
													console.log("Saved order did not have `" + cog.id + "`. Adding it to the grid.");
													new_order.push(cog);
												}
											});


										preference_order_dfr.resolve(new_order);

									} else {
										// We loaded preferences ok, but there was no data assigned to `grid`
										preference_order_dfr.reject('no preferences');
									}

								})
								.fail(preference_order_dfr.reject);


						/*	Preference Saving
						------------------------------------------*/
							var saveOrders = function () {
								var orders = _.mapValues(awf.drag_handler.participants, function (participant) {
										return _.map(participant.items, 'cog_id');
									}),
									enough_time_on_saving = $.Deferred();

								setTimeout(function () { enough_time_on_saving.resolve(); }, 1500);
								awf.app.experience.postMessage('info','Saving your card layout &hellip;');

								return awf.app.experience
									.setPreferences(orders)
									.savePreferences()
										.done(function () {

											enough_time_on_saving.done(function () {
												awf.app.experience
													.postMessage('success','Card layout saved!',false)
													.andDismissIn(3);
											});
											console.info("The dual-grid order has been saved!");

										})
										.fail(function (er) {

											enough_time_on_saving.done(function () {
												awf.app.experience
													.postMessage('error','Great Scott! The grid saving is too heavy!', false)
													.andDismissIn(2);
											});
											console.warn("The dual-grid order could not be saved. :(");
											throw er;

										});
							};

							var debouncedSaveOrders = _.debounce(saveOrders, 500);

							awf.page.grid.on('change:order', debouncedSaveOrders);


					} else {
						// we're not doing custom order
						// reject this promise, so the default can take over
						preference_order_dfr.reject('not authenticated');
					}

				return final_order_dfr.promise();
			},


			addCogs: function (cogs) {

				console.log('Adding cogs to main grid: ', _.map(cogs, 'id'));

				var dfr = $.Deferred();

				// remove the spinner
				this.spinners.grid.destroy();

				/*	Add grid items
				------------------------------------------*/
					// todo: Add Unit Tests - for grid header w/other cogs
					if (this.grid_header) {
						var $exp_head = $('#awf-experience-header', this.$el);
						if ($exp_head.length == 1) {
							var exp_header = new awf.ui.Card({
									parent: $exp_head
								});

							exp_header._$card.html(awf.snippets[this.grid_header.snippet]);
						} else {
							console.log('No cogs were found. An `grid_header` was defined, but the layout template did not provide a content dropzone.');
						}
					} else {
						console.log('No cogs were found. If you want have content show when no cogs are present, add `grid_header` to your layout config.');
					}

					awf._.forEach(cogs, function(cog) {
						if ( ! cog.isAvailable()) {
							console.info('The `' + cog.type + '` cog is disabled from the `' + cog.flag + '` feature flag.');
						} else if (cog.isViewAvailable('medium') === null) {
							console.info('The `' + cog.type + '` cog\'s medium view does not exist.');
						} else if (cog.isViewAvailable('medium') === false) {
							console.info('The `' + cog.type + '` cog\'s medium view is disabled from the `' + cog.views.medium.flag + '` feature flag.');
						} else {
							try {
								awf.page.grid.addCog(cog);
							} catch (er) {
								console.warn('Could not add cog `' + cog.id + '` to the grid.');
								console.error(er);
							}
						}
					});

				// If you got this far, addCogs worked. :)
				dfr.resolve();


				return dfr.promise();
			},


			setupComplete: function () {
				var dfr = $.Deferred();

				awf.page.grid
					.applyPositions()
					.autoSetColumns()
					/*	Dynamically adding/removing cards?
					 *	Update the positial column count.
					-----------------------------------------------------*/
					.on('change:length', function () {
						awf.page.grid.autoSetColumns();
					});

				awf.$(window)
					.off('resize.grid')
					.on('resize.grid', function () {
						awf.page.grid.autoSetColumns();
					});

				console.log('window will attempt to adjust awf.page.grid on page resize');

				// If you got this far, setupComplete worked. :)
				dfr.resolve();

				return dfr.promise();
			},


			teardown: function () {
				var dfr_grid = $.Deferred();

				if (awf.page.grid) {
					awf.page.grid.destroy();
					delete awf.page.grid;
					console.log('Destroyed awf.page.grid');
				}

				awf.$(window)
					.off('resize.grid');

				console.log('window no longer attempts to adjust awf.page.grid on page resize');

				dfr_grid.resolve();

				return dfr_grid.promise();
			}
		}

	});


/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = "#awf-experience-message:empty {\n\tdisplay: none;\n}\n\n#awf-experience-header {\n\tpadding-top: 10px;\n\tmargin: 0 0 10px;\n}\n\n#awf-experience-header:empty {\n\tdisplay: none;\n}\n\n#grid {\n\tpadding: 20px 10px;\n\tposition: relative;\n\t-webkit-box-flex: 1;\n\t-webkit-flex: 1 1 auto;\n\t-moz-box-flex: 1;\n\t-moz-flex: 1 1 auto;\n\t-ms-flex: 1 1 auto;\n\tflex: 1 1 auto;\n}\n\n#grid > .awf-loader {\n\tposition: absolute;\n}\n\n\n@media (min-width: 420px) {\n\t#grid {\n\t\tpadding: 20px;\n\t}\n}\n\n@media (min-width: 420px) and (max-width: 1019px) {\n\t#leftnav {\n\t\t-webkit-box-flex: 0;\n\t\t-webkit-flex: 0 0 80px;\n\t\t-moz-box-flex: 0;\n\t\t-moz-flex: 0 0 80px;\n\t\t-ms-flex: 0 0 80px;\n\t\tflex: 0 0 80px;\n\t}\n\t.vertical-nav__item__label {\n\t\tdisplay: none;\n\t}\n\t.vertical-nav__item__icon {\n\t\tmargin-left: 18px;\n\t}\n}\n";

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = "<div>\n\t<div id=\"awf-experience-message\"></div>\n\t<div id=\"awf-experience-header\"></div>\n\t<div id=\"grid\"></div>\n</div>\n";

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	_.extend(awf.ui.Layout.presets, {

		'fluid-grid': {
			template: __webpack_require__(123),
			css: __webpack_require__(122),


			// setup
			setup: awf.ui.Layout.presets.grid.setup,


			// preferenceParser
			preferenceParser: awf.ui.Layout.presets.grid.preferenceParser,


			// addCogs
			addCogs: awf.ui.Layout.presets.grid.addCogs,


			// setupComplete
			setupComplete: function () {
				return awf.ui.Layout.presets.grid.setupComplete.apply(this, arguments)
					.done(function () {
						awf.page.grid
							.setFluid(true);
						setTimeout(function () {
							awf.page.grid.setAnimated(true);
						}, 0);
					});
			},


			teardown: function () {
				return awf.ui.Layout.presets.grid.teardown.call(this);
			}
		}

	});


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	_.extend(awf.ui.Layout.presets, {

		'dual-grid': {
			template: __webpack_require__(126),
			css: __webpack_require__(127),










			setup: function () {

				console.time('setup');

				var self = this,
					grid_default_dfr = $.Deferred(),
					mini_grid_default_dfr = $.Deferred(),
					dual_grid_default_dfr = $.Deferred(),
					$parent = awf.$('#mini-grid', this.$el);

				$.when(grid_default_dfr, mini_grid_default_dfr)
					.done(function (grid_default_cogs, mini_grid_default_cogs) {
						dual_grid_default_dfr.resolve({
							grid: grid_default_cogs,
							mini_grid: mini_grid_default_cogs
						});
					})
					.fail(dual_grid_default_dfr.reject);

				// Creating a spinner for the grid
				this.spinners = this.spinners || {};
				this.spinners.mini_grid = new awf.ui.Spinner({
					parent: $parent
				});

				// Bring in the Grid!
				awf.ui.Layout.presets.grid.setup.call(this)
					.done(grid_default_dfr.resolve)
					.fail(function (er) {
						mini_grid_default_dfr.reject({
							msg: '`grid` setup failed',
							er: er
						});
					});


				awf.user.authentication.always(function () {

					if ( ! awf.page) {
						dual_grid_default_dfr.reject('awf.page is not defined');
						return dual_grid_default_dfr;
					}

					/*	Mini Grid -- awf.page.mini_grid
					------------------------------------------*/
						awf.page.mini_grid = new awf.ui[awf.user.is_authenticated ? 'ArrangeableGrid' : 'Grid']({
							parent: $parent,
							columns: 1,
							max_columns: 2,
							tile: {
								width: 120,
								max_width: 150,
								height: 80,
								margin: 20
							},
							view: 'mini'
						});

					awf.drag_handler.registerParticipant('mini_grid', awf.page.mini_grid);


					/*	Starting up the cogs
					------------------------------------------*/
						var default_cogs = [];


						awf._.forEach(self.default_order.mini_grid, function(cog_params, i) {

							var cog;

							console.group('Setting up ', cog_params);

							try {
								cog = awf.app.experience.getOrCreateCog(cog_params);
								cog.default_grid = 'mini_grid';
								default_cogs.push(cog);
							} catch (er) {
								console.warn("Cannot get cog: ", cog_params);
								console.error(er);
							}

							console.groupEnd();
						});

						console.log('mini grid default cogs: ', _.map(default_cogs, 'id'));

						mini_grid_default_dfr.resolve(default_cogs);



					/*	If authenticated, check for an updated order
					------------------------------------------*/
						if (awf.user.is_authenticated) {

							/*	Enable cross-grid drag ability - within grid is still handled by ArrangeableGrid internally
							------------------------------------------------------------------*/
								awf.drag_handler
									.on('drag:start', function (ev, $target) {
										var item = $target.closest('.grid__item').data('component'),
											cog = awf.app.experience.cogs[item.cog_id],
											available_views = cog.availableViews(),
											spotlight_targets = [];

										// console.log(cog.id + ' available_views: ', available_views);

										_.forEach(this.participants, function (participant) {
											if (_.contains(available_views, participant.view)) {
												participant.is_participating = true;
												spotlight_targets.push(participant.$el);
											} else {
												participant.is_participating = false;
											}
										});
										awf.page.spotlight(spotlight_targets);
										// console.log('spotlight_targets: ', spotlight_targets);
									})
									.on('drag:move', function (ev, $target) {
										// awf.page.spotlight(this.active_participant.$el);
									})
									.on('drag:end', function (ev, $target) {
										awf.page.spotlight(null);

										_.forEach(this.participants, function (participant) {
											participant.is_participating = false;
											participant.applyPositions();
										});

										var item = $target.closest('.grid__item').data('component'),
											grid = item.collection;

										// safely execute
										// console.log('Drag has ended');
										// console.log('this.active_participant: ', this.active_participant);
										// console.log('grid: ', grid);
										if (this.active_participant && this.active_participant.ghost) {
											// if the target grid is not the original
											if (this.active_participant.id != grid.id) {
												var cog = awf.app.experience.cogs[item.cog_id],
													index = this.active_participant.getGhostIndex(),
													new_item = this.active_participant.addCog(cog),
													order = [];

												_.forEach(this.active_participant.items, function (item, i) { order.push(i); });
												var before = order.slice(0,index),
													after = order.slice(index),
													new_order = before.concat([after.pop()],after);

												// console.log('item.cog_id: ', item.cog_id);
												// console.log('cog: ', cog);
												// console.log('index: ', index);
												// console.log('new_item: ', new_item);
												// console.log('order: ', order);
												// console.log('before: ', before);
												// console.log('after: ', after);
												// console.log('new_order: ', new_order);

												this.active_participant
													.setGhost(null)
													.setOrder(new_order);

												grid.removeCog(cog);
											}
										}
									})
									/*
										.on('drag:move', function () {
											//console.log('drag-handler: move\t: drag');
										})
										.on('within-domain-drag:start', function (ev, id, grid, item, page_drop_point) {
											//console.info('drag-handler: start\t: within-domain-drag');
										})
										.on('within-domain-drag:move', function (ev, id, grid, item, page_drop_point) {
											//console.log('drag-handler: move\t: within-domain-drag');
										})
										.on('within-domain-drag:end', function () {
											//console.info('drag-handler: end\t: within-domain-drag');
										})
										.on('beyond-domain-drag:start', function (ev, id, grid, item, page_drop_point) {
											//console.info('drag-handler: start\t: beyond-domain-drag');
										})
										.on('beyond-domain-drag:move', function (ev, id, grid, item, page_drop_point) {
											//console.log('drag-handler: move\t: beyond-domain-drag');
										})
										.on('beyond-domain-drag:end', function () {
											//console.info('drag-handler: end\t: beyond-domain-drag');
										})
									*/
									.on('beyond-domain-drag:start beyond-domain-drag:move', function (ev, id, grid, item, page_drop_point) {
										var drag_handler = this;
										_.forEach(this.participants, function (participant, participant_id) {
											if (participant.is_participating) {
												if (participant_id !== id) {
													var instance_offset = participant.$el.offset(),
														point = {
															x: page_drop_point.x - instance_offset.left,
															y: page_drop_point.y - instance_offset.top
														},
														new_loc = participant.getLocation(point);

													var cog = awf.app.experience.cogs[item.cog_id];

													new_loc.col_span = cog.views[participant.view].colspan || 1;
													new_loc.row_span = cog.views[participant.view].rowspan || 1;

													var is_in_domain = participant.isLocInDomain(new_loc);
													//console.log(id + '\'s point [' + (is_in_domain ? 'x' : ' ') + ']: ', JSON.stringify(point));

													drag_handler.setActiveParticipant(participant);

													if (is_in_domain) {
														participant
															.setGhost(new_loc)
															.applyPositions();
													}
												}
											}
										});
									})
									.on('beyond-domain-drag:end', function (ev, id, grid, item) {
										this.setActiveParticipant(grid);
										_.forEach(this.participants, function (participant, participant_id) {
											if (participant_id !== id) {
												if (participant.ghost) {
													participant.setGhost(null);
												}
											}
										});
									});
						}


				});

				return dual_grid_default_dfr
					.promise()
					.always(function () {
						console.timeEnd('setup');
					});
			},













			preferenceParser: function (default_groups) {

				//console.log('default_groups: ', default_groups);

				console.time('preference parser');

				var preference_order_dfr = $.Deferred(),
					final_order_dfr = $.Deferred();

				if ( ! _.isObject(default_groups)) {
					final_order_dfr.reject('default_groups is not an array');
					return final_order_dfr.promise();
				}

				preference_order_dfr
					// If we have a preference_order, pass it along as the final_order
					.done(function (cogs) {
						console.info('Custom order for dual-grid has been resolved: ' + _.map(cogs, 'id'));
						final_order_dfr.resolve(cogs);
					})
					// If custom fails, automatically resolve to default
					.fail(function (er) {
						console.info('Custom order for dual-grid has been rejected: ' + er);
						final_order_dfr.resolve(default_groups);
					});



				/*	If authenticated, check for an updated order
				------------------------------------------*/
					if (awf.user.is_authenticated) {

						/*	Preference Loading
						------------------------------------------*/
							awf.app.experience.fetchPreferences(1000)
								.done(function (preferences) {

									if (preferences) {

										/*	Grid
										------------------------------------------*/
										var grid_cogs = [];

										if (preferences.grid) {
											var grid_preference_ids = preferences.grid;
											console.log('Saved order found for grid: ', grid_preference_ids);
											_.forEach(grid_preference_ids, function (id) {
												var cog = awf.app.experience.cogs[id];
												if (cog) {
													grid_cogs.push(cog);
												}
											});
										} else {
											grid_cogs = default_groups.grid;
										}

										var grid_ids = _.map(grid_cogs, 'id');



										/*	Mini Grid
										------------------------------------------*/
										var mini_grid_cogs = [];

										if (preferences.mini_grid) {
											var mini_grid_preference_ids = preferences.mini_grid;
											console.log('Saved order found for mini-grid: ', mini_grid_preference_ids);
											_.forEach(mini_grid_preference_ids, function (id) {
												var cog = awf.app.experience.cogs[id];
												if (cog) {
													mini_grid_cogs.push(cog);
												}
											});
										} else {
											//console.log('default_groups["mini-grid"]: ', default_groups["mini-grid"]);
											mini_grid_cogs = default_groups.mini_grid;
										}

										var mini_grid_ids = _.map(mini_grid_cogs, 'id');



										/*	Master List of given and saved cog ids
										------------------------------------------*/
											var all_preference_ids   = _.unique(grid_ids.concat(mini_grid_ids)),
												all_configured_ids   = _.map(awf.app.experience.cogs, "id"),
												added_ids   = _.difference(all_configured_ids, all_preference_ids);


										/*	add the new
										------------------------------------------*/
											_.forEach(added_ids, function (id) {
												var cog = awf.app.experience.cogs[id];
												switch (cog.default_grid) {
													case "grid":
														console.log("Saved order was missing `" + cog.id + "`, so it was added to grid.");
														grid_cogs.push(cog);
														break;

													case "mini_grid":
														console.log('mini_grid_cogs: ', mini_grid_cogs);
														console.log("Saved order was missing `" + cog.id + "`, so it was added to mini-grid.");
														mini_grid_cogs.push(cog);
														break;
												}
											});

										preference_order_dfr.resolve({
											grid: grid_cogs,
											mini_grid: mini_grid_cogs
										});

									} else {
										preference_order_dfr.reject('no preferences');
									}

								})
								.fail(preference_order_dfr.reject);


						/*	Preference Saving
						------------------------------------------*/
							var saveOrders = function () {
								var orders = _.mapValues(awf.drag_handler.participants, function (participant) {
										return _.map(participant.items, 'cog_id');
									}),
									enough_time_on_saving = $.Deferred();

								setTimeout(function () { enough_time_on_saving.resolve(); }, 1500);
								awf.app.experience.postMessage('info','Saving your card layout &hellip;');

								return awf.app.experience
									.setPreferences(orders)
									.savePreferences()
										.done(function () {

											enough_time_on_saving.done(function () {
												awf.app.experience
													.postMessage('success','Card layout saved!',false)
													.andDismissIn(3);
											});
											console.info("The dual-grid order has been saved!");

										})
										.fail(function (er) {

											enough_time_on_saving.done(function () {
												awf.app.experience
													.postMessage('error','Great Scott! The grid saving is too heavy!', false)
													.andDismissIn(2);
											});
											console.warn("The dual-grid order could not be saved. :(");
											throw er;

										});
							};

							var debouncedSaveOrders = _.debounce(saveOrders, 500);

							awf.page.grid.on('change:order', debouncedSaveOrders);
							awf.page.mini_grid.on('change:order', debouncedSaveOrders);

					} else {
						// we're not doing custom order
						// reject this promise, so the default can take over
						preference_order_dfr.reject('unauthenticated');
					}

				return final_order_dfr
					.promise()
					.always(function () {
						console.timeEnd('preference parser');
					});
			},












			addCogs: function (cog_groups) {

				console.time('adding cogs');
				console.log('addCogs() cog_groups: ', cog_groups);

				/*	Grid
				------------------------------------------*/
					var grid_dfr = awf.ui.Layout.presets.grid.addCogs.call(this, cog_groups.grid);


				/*	Mini Grid
				------------------------------------------*/

					console.log('Adding cogs to mini grid: ', _.map(cog_groups.mini_grid, 'id'));

					var mini_grid_dfr = $.Deferred();
					this.spinners.mini_grid.destroy();
					awf._.forEach(cog_groups.mini_grid, function(cog) {
						if ( ! cog.isAvailable()) {
							console.info('The `' + cog.type + '` cog is disabled from the `' + cog.flag + '` feature flag.');
						} else if (cog.isViewAvailable('mini') === null) {
							console.info('The `' + cog.type + '` cog\'s mini view does not exist.');
						} else if (cog.isViewAvailable('mini') === false) {
							console.info('The `' + cog.type + '` cog\'s mini view is disabled from the `' + cog.views.mini.flag + '` feature flag.');
						} else {
							try {
								awf.page.mini_grid.addCog(cog);
							} catch (er) {
								console.warn('Could not add cog `' + cog.id + '` to the mini-grid.');
								console.error(er);
							}
						}
					});

					mini_grid_dfr.resolve();


				return $.when(grid_dfr, mini_grid_dfr)
					.promise()
					.always(function () {
						console.timeEnd('adding cogs');
					});
			},












			setupComplete: function () {

				console.time('setup complete');

				var self = this,
					grid_dfr = awf.ui.Layout.presets.grid.setupComplete.call(this),
					mini_grid_dfr = $.Deferred();

				awf.page.mini_grid
					.applyPositions()
					.autoSetColumns()
					.on('change:length', function () {
						awf.page.mini_grid.autoSetColumns();
					});

				awf.$(window)
					.off('resize.mini-grid')
					.on('resize.mini-grid', function () {
						awf.page.mini_grid.autoSetColumns();
					});


				if ( ! self.force_mini) {
					awf.app.experience.modal_available_flag.runAndWatch(function (is_flippable) {
						if (is_flippable) {
							$('#mini-grid').show();
						} else {
							$('#mini-grid').hide();
						}
					});
				}

				console.log('window will attempt to adjust awf.page.mini_grid on page resize');

				// If you got this far, setupComplete worked. :)
				mini_grid_dfr.resolve();

				return $.when(grid_dfr, mini_grid_dfr)
					.promise()
					.always(function () {
						console.timeEnd('setup complete');
					});
			},











			teardown: function () {

				var dfr_mini_grid = $.Deferred(),
					dfr_grid = awf.ui.Layout.presets.grid.teardown.call(this);

				if (awf.page.mini_grid) {
					awf.page.mini_grid.destroy();
					delete awf.page.mini_grid;
					console.log('Destroyed awf.page.mini_grid');
				}

				awf.$(window)
					.off('resize.mini-grid');

				console.log('window no longer attempts to adjust awf.page.mini_grid on page resize');

				dfr_mini_grid.resolve();

				return $.when(dfr_grid, dfr_mini_grid);
			}
		}

	});


/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = "<div>\n\t<div id=\"awf-experience-message\"></div>\n\t<div class=\"columns\">\n\t\t<div id=\"grid\">\n\t\t\t<div id=\"awf-experience-header\"></div>\n\t\t</div>\n\t\t<div id=\"mini-grid\"></div>\n\t</div>\n</div>\n";

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "#layout .columns {\n\tpadding: 20px 10px;\n\tdisplay: -webkit-box;\n\tdisplay: -moz-box;\n\tdisplay: -ms-flexbox;\n\tdisplay: -webkit-flex;\n\tdisplay: flex;\n\t-webkit-box-direction: normal;\n\t-webkit-box-orient: vertical;\n\t-webkit-flex-direction: column;\n\t-moz-flex-direction: column;\n\t-ms-flex-direction: column;\n\tflex-direction: column;\n\t-webkit-box-flex: 1;\n\t-webkit-flex: 1 1 auto;\n\t-moz-box-flex: 1;\n\t-moz-flex: 1 1 auto;\n\t-ms-flex: 1 1 auto;\n\tflex: 1 1 auto;\n}\n\n#awf-experience-header {\n\tpadding-top: 10px;\n\tmargin: 0 0 10px;\n}\n\n#awf-experience-header:empty {\n\tdisplay: none;\n}\n\n\n#awf-experience-message:empty {\n\tdisplay: none;\n}\n\n#grid,\n#mini-grid {\n\tposition: relative;\n}\n\n#grid > .awf-loader,\n#mini-grid > .awf-loader {\n\tposition: absolute;\n}\n\n#grid {\n\t-webkit-box-flex: 1;\n\t-webkit-flex: 1 1 auto;\n\t-moz-box-flex: 1;\n\t-moz-flex: 1 1 auto;\n\t-ms-flex: 1 1 auto;\n\tflex: 1 1 auto;\n}\n\n#mini-grid {\n\tpadding-top: 10px;\n\t-webkit-box-flex: 1;\n\t-webkit-flex: 1 1 auto;\n\t-moz-box-flex: 1;\n\t-moz-flex: 1 1 auto;\n\t-ms-flex: 1 1 auto;\n\tflex: 1 1 auto;\n}\n\n\n\n\n\n@media (min-width: 420px) {\n\t#layout .columns {\n\t\tpadding: 20px;\n\t}\n}\n\n\n\n\n\n@media (min-width: 420px) and (max-width: 1019px) {\n\t#leftnav {\n\t\t-webkit-box-flex: 0;\n\t\t-webkit-flex: 0 0 80px;\n\t\t-moz-box-flex: 0;\n\t\t-moz-flex: 0 0 80px;\n\t\t-ms-flex: 0 0 80px;\n\t\tflex: 0 0 80px;\n\t}\n\t.vertical-nav__item__label {\n\t\tdisplay: none;\n\t}\n\t.vertical-nav__item__icon {\n\t\tmargin-left: 18px;\n\t}\n}\n\n\n\n\n\n@media (min-width: 580px) {\n\t#mini-grid {\n\t\tpadding-top: 0;\n\t\t-webkit-box-flex: 0;\n\t\t-webkit-flex: 0 0 120px;\n\t\t-moz-box-flex: 0;\n\t\t-moz-flex: 0 0 120px;\n\t\t-ms-flex: 0 0 120px;\n\t\tflex: 0 0 120px;\n\t\tmargin-left: 20px;\n\t}\n\n\t#layout .columns {\n\t\t-webkit-box-direction: normal;\n\t\t-webkit-box-orient: horizontal;\n\t\t-webkit-flex-direction: row;\n\t\t-moz-flex-direction: row;\n\t\t-ms-flex-direction: row;\n\t\tflex-direction: row;\n\t}\n}\n";

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	_.extend(awf.ui.Layout.presets, {

		'fluid-dual-grid': {
			template: __webpack_require__(126),
			css: __webpack_require__(127),


			
			// setup
			setup: awf.ui.Layout.presets['dual-grid'].setup,
			
			// preferenceParser
			preferenceParser: awf.ui.Layout.presets['dual-grid'].preferenceParser,
			
			// addCogs
			addCogs: awf.ui.Layout.presets['dual-grid'].addCogs,

			// setupComplete
			setupComplete: function () {
				return awf.ui.Layout.presets['dual-grid'].setupComplete.apply(this, arguments)
					.done(function () {
						
						awf.page.grid
							.setFluid(true);

						awf.page.mini_grid
							.setFluid(true);

						setTimeout(function () {
							awf.page.grid.setAnimated(true);
							awf.page.mini_grid.setAnimated(true);
						}, 0);
					});
			},



			teardown: function () {
				awf.ui.Layout.presets['dual-grid'].teardown.call(this);
			}
		}

	});


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(4);

	_.extend(awf.ui.Layout.presets, {

		'page': {
			css: __webpack_require__(130),
			template: __webpack_require__(131),

			setup: function () {
				var dfr = $.Deferred();
				var cog = null;

				try {
					cog = awf.app.experience.getOrCreateCog(this.cog);
				} catch (er) {
					console.warn("Cannot get cog: ", this.cog);
					console.error(er);
				}

				dfr.resolve(cog);
				return dfr.promise();
			},



			addCogs: function (cog) {

				var dfr = $.Deferred(),
					$container = this.$el.find('#awf-page-container');

				console.log('cog: ', cog);

				if ( ! cog.isAvailable()) {
					console.info('The `' + cog.type + '` cog is disabled from the `' + cog.flag + '` feature flag.');
				} else if (cog.isViewAvailable('page') === null) {
					console.info('The `' + cog.type + '` cog\'s page view does not exist.');
				} else if (cog.isViewAvailable('page') === false) {
					console.info('The `' + cog.type + '` cog\'s page view is disabled from the `' + cog.views.page.flag + '` feature flag.');
				} else {
					try {
						cog.renderView('page', $container);
					} catch (er) {
						console.warn('Could not add cog `' + cog.id + '` to the page.');
						console.error(er);
						$container.append('Cannot load cog.');
					}
				}

				dfr.resolve(cog);
				return dfr.promise();
			}

		}

	});


/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = "#awf-experience-header {\n\tpadding: 30px 20px 20px;\n\tmargin: 0 0 10px;\n}\n\n#awf-experience-header:empty {\n\tdisplay: none;\n}\n\n#awf-experience-message:empty {\n\tdisplay:none;\n}\n\n\n\n@media (min-width: 420px) {\n\n}\n\n\n@media (min-width: 420px) and (max-width: 1019px) {\n\t#leftnav {\n\t\t-webkit-box-flex: 0;\n\t\t-webkit-flex: 0 0 80px;\n\t\t-moz-box-flex: 0;\n\t\t-moz-flex: 0 0 80px;\n\t\t-ms-flex: 0 0 80px;\n\t\tflex: 0 0 80px;\n\t}\n\t.vertical-nav__item__label {\n\t\tdisplay: none;\n\t}\n\t.vertical-nav__item__icon {\n\t\tmargin-left: 18px;\n\t}\n}\n";

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-layout-page-wrap -background-base\">\n\t<div id=\"awf-experience-message\"></div>\n\t<div id=\"awf-experience-header\"></div>\n\t<div id=\"awf-page-container\"></div>\n</div>\n";

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Masthead;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Base,
		template = __webpack_require__(133);

	use(Parent).toCreate(Masthead);

	/**
	 * Masthead UI Component
	 * @type {Masthead}
	 * @implements {Masthead}
	 * @memberOf awf.ui
	 * @class
	 *
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 * @requires awf.__.Color
	 * @requires awf.ui.Stylesheet
	 * @requires awf.ui.MastheadUser
	 * @requires awf.ui.CustomName
	 *
	 * @param {awf.ui.Masthead.mastheadConfig} params The configuration object used to build the masthead
	 *
	 * @property {string|null} name The masthead title
	 * @property {undefined|awf.ui.CustomName} customizable_name Undefined unless customizable_name is a truthy property of params
	 * @property {string|null} background The masthead default background color
	 * @property {string|null} foreground The masthead default title color
	 * @property {string|object|null} logo The path to the logo image, or a jQuery object for the logo
	 * @property {undefined|awf.ui.MastheadUser} user Undefined unless user is a property of params
	 * @property {object} children collection of UI components to be rendered/destroyed with Masthead
	 * @property {undefined|awf.ui.Search} children.search Undefined unless search is a property of params
	 * @property {undefined|awf.ui.Button} children.search_button Undefined unless search is a property of params
	 * @property {object} _$nav_toggle A jQuery reference to the leftnav toggle button, if it exists
	 * @property {object} _$brand A jQuery reference to the brand container element
	 * @property {object} _$brand_logo A jQuery reference to the brand_logo container element
	 * @property {object} _$brand_name A jQuery reference to the brand_name container element
	 * @property {object} _$user_container A jQuery reference to the masthead user container element
	 * @property {object} _$trays_container A jQuery reference to the masthead trays container element
	 * @property {object} _$search A jQuery reference to the search container element
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var masthead = new awf.ui.Masthead();
	 *
	 */
	function Masthead (params) {
		console.group('Constructing Masthead');
		console.log('params: ', params);

		var self = this;

		if (params === true || params === undefined)
			params = {};

		self.template = params.template || self.template || template;

		Parent.call(self, params);

		self.children.stylesheet = new awf.ui.Stylesheet();
		self.orig_scroll_pos = 0;

		awf.util.mixin.properties(self, params, {

			/**
			 * If set to true, this will prevent this.setName from updating the
			 * masthead title.
			 * @memberof awf.ui.Masthead
			 * @name setCustomizableName
			 * @function
			 *
			 * @param {boolean} val=false
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:customizable_name passing old and new values
			 */
			customizable_name: {
				default: false,
				types: ['boolean']
			},


			/**
			 * Updates the masthead title and logo alt text. If this.customizable_name
			 * is true, this method will only update the logo alt text.
			 * @memberof awf.ui.Masthead
			 * @name setName
			 * @function
			 *
			 * @param {string|null} val The new name
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:name passing old and new values
			 */
			name: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					if ( ! this.customizable_name)
						this._$brand_name.html(val);

					// if logo is an image, update the `alt` attribute
					this._$brand_logo.find('.js-brand-logo-image')
							.attr('alt', val + ' Logo');
				}
			},


			/**
			 * Updates the masthead background.
			 * @memberof awf.ui.Masthead
			 * @name setBackground
			 * @function
			 *
			 * @param  {string|null} val CSS background value
			 *
			 * @example
			 * var masthead = new awf.ui.Masthead();
			 *
			 * masthead.setBackground('#ffffff');
			 * masthead.setBackground('rgba(255,255,255,0.95');
			 * masthead.setBackground('url(path/to/background.png) no-repeat');
			 *
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:background passing old and new values
			 */
			background: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					val = val || '';

					this._updateCSS(val, this.foreground);
				}
			},


			/**
			 * Updates the masthead title color.
			 * @memberof awf.ui.Masthead
			 * @name setForeground
			 * @function
			 *
			 * @param  {string|null} val CSS color value
			 *
			 * @example
			 * var masthead = new awf.ui.Masthead();
			 *
			 * masthead.setForeground('#ffffff');
			 * masthead.setForeground('rgba(255,255,255,0.95');
			 *
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:foreground passing old and new values
			 */
			foreground: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					val = val || '';

					this._updateCSS(this.background, val);
				}
			},


			/**
			 * Sets a masthead logo. Hides the logo container if passed null.
			 * @memberof awf.ui.Masthead
			 * @name setLogo
			 * @function
			 *
			 * @param  {string|object|null} val A relative path to the masthead logo to load, or a jQuery DOM object
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:logo passing old and new values
			 */
			logo: {
				default: null,
				types: ['string','object','null'],
				renderHandler: function (val) {
					switch (typeof val) {

						case "object":
							if (val instanceof $) {
								this._$brand_logo.empty().append(val);
								this.showLogo();
							} else {
								this.hideLogo();
							}
							break;

						default:
							var $img = $('<img class="js-brand-logo-image masthead__logo__image" />');

							$img.attr({
								'src': val,
								'alt': this.name + ' Logo'
							});

							this._$brand_logo.empty().append($img);

							this.showLogo();

					}
				}
			},


			/**
			 * Sets the fixed state of the masthead (usefull for search and masthead tray dropdowns
			 * especially on mobile devices).<br><br>
			 * When set to `false`:<br>
			 *  - the masthead is no longer fixed (sticky)<br>
			 *  - the current scroll position is stored (this.orig_scroll_pos)<br>
			 *  - the page automatically scrolls to the top<br><br>
			 * When set to `true` later on:<br>
			 *  - the masthead becomes fixed (sticky)<br>
			 *  - the this.orig_scroll_pos is restored<br>
			 *  - the page automatically scrolls to this.orig_scroll_pos
			 * @memberof awf.ui.Masthead
			 * @name setFixed
			 * @function
			 *
			 * @param  {boolean} val
			 *
			 * @example
			 * // this will toggle the fixed state of the masthead
			 * // along with the masthead trays. When a tray is
			 * // shown, the masthead is no longer fixed. When a
			 * // tray is hidden, the masthead is fixed, again.
			 *
			 * self.children.trays.on('show', function () {
			 *   self.setFixed(false);
			 * });
			 *
			 * self.children.trays.on('hide', function () {
			 *   self.setFixed(true);
			 * });
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:fixed passing old and new values
			 */
			fixed: {
				default: true,
				types: 'boolean',
				renderHandler: function (val) {
					if (val) {
						this.$el.addClass('masthead--fixed');
						$('html, body').animate({ scrollTop: this.orig_scroll_pos }, 0);
					} else {
						this.orig_scroll_pos = $(window).scrollTop();
						this.$el.removeClass('masthead--fixed');
						$('html, body').animate({ scrollTop: 0 }, 0);
					}
				}

			}

		});





		/*	Custom Name
		------------------------------------------*/
			if (this.customizable_name) {
				this.setName(null);
				this.customizable_name_spinner = new awf.ui.Spinner({
					parent: this._$brand_name,
					template: __webpack_require__(94)
				});
			}





		/*	Masthead Trays
		------------------------------------------*/
			// todo: Add unit test -- masthead trays default instance
			/**
			 * The default instance, created if included in awf.init()
			 * @type {MastheadTrays}
			 * @memberOf awf.page.children.masthead
			 * @listens awf.page.children.masthead.children.trays.show
			 * @listens awf.page.children.masthead.children.trays.hide
			 * @name awf.page.children.masthead.children.trays
			 * @instance
			 *
			 * @example
			 * // trays
			 *
			 * // This will create and initialize awf.page.children.masthead.children.trays with
			 * // a template (awf.page.children.masthead.children.trays.$el) that is appended to
			 * // a container within awf.page.children.masthead.$el.
			 *
			 * awf.init({
			 *   page: {
			 *     name: String, //(required) app/company
			 *     masthead: {
			 *       trays: {}
			 *     }
			 *   }
			 * });
			 *
			 */
			self.children.trays = new awf.ui.MastheadTrayCollection(params.trays);
			self._$trays_container.append(self.children.trays.$el);

			self.children.trays.on('show', function () {
				self.setFixed(false);
			});

			self.children.trays.on('hide', function () {
				self.setFixed(true);
			});



		/*	User
		------------------------------------------*/
			// todo: Add unit test -- user instance
			if (params.user) {
				console.log('Adding MastheadUser');
				self.children.user = new awf.ui.MastheadUser({
					parent: this._$user_container,
					loading: true
				});

				self.children.user.on("click:sign-in", awf.user.login);

				awf.user.authentication
					.done(function (is_authenticated) {
						self.children.user.setLoading(false);

						if (is_authenticated) {
							self.children.user
								.setPerson(awf.user)
								.setAsAuthenticated();
						}
					})
					.fail(function () {
						self.children.user.setLoading(false);
					});

			} else {
				console.log('not configured: `user`');
			}



		/*	Search
		------------------------------------------*/
			// todo: Add unit test -- search instance
			if (params.search) {
				console.log('Adding search');
				/**
				 * Undefined unless search is a property of params during instantiation
				 * @type {awf.ui.Search}
				 * @memberOf awf.ui.Masthead
				 */
				this.children.search = new awf.ui.Search({
					parent: this._$search,
					label: params.search.label || null
				});


				/**
				 * Undefined unless search is a property of params during instantiation
				 * @type {awf.ui.Button}
				 * @memberOf awf.ui.Masthead
				 */
				this.children.search_button = new awf.ui.Button({
					parent: this._$search,
					classname: "js-search-mobile-toggle awf-search__mobile-toggle -awf-link -text-decoration-none",
					text: "Open Search",
					icon: "awficon-search1"
				});

				/**
				 * Undefined unless search is a property of params during instantiation
				 * @type {awf.ui.Results}
				 * @memberOf awf.ui.Masthead
				 */
				this.children.search_results = new awf.ui.Results({
					parent: this._$search
				});





				/*	Search Bucket Results Limit CSS
				------------------------------------------------------------------------------------*/
					var css_string = "",
						default_limit = params.search.default_bucket_limit;

					if (default_limit) {
						css_string += "\n.awf-bucket-item:nth-child(n+" + (default_limit + 1) + ") {\n\tdisplay: none;\n}\n";
					}

					_.forEach(params.search.buckets, function (bucket) {
						if (bucket.limit && bucket.limit != default_limit) {
							if (bucket.limit > default_limit) {
								css_string += "\n.search-bucket--" + _.kebabCase(bucket.bucket) + " .awf-bucket-item:nth-child(n) {\n\tdisplay: block;\n}\n";
							}

							css_string += "\n.search-bucket--" + _.kebabCase(bucket.bucket) + " .awf-bucket-item:nth-child(n+" + (bucket.limit + 1) + ") {\n\tdisplay: none;\n}\n";
						}
					});

					this.children.search.children.stylesheet.css(css_string);







				/*	Connect Search UI to awf.search (model)
				------------------------------------------------------------------------------------*/

					awf.search.results.dimensions.bucket.on('add:group', function (ev, bucket) {

						var bucket_params = _.find(params.search.buckets, {bucket:bucket.key});

						if (bucket_params) {

							var label = bucket_params.label;

							bucket.bucket_ui = self.children.search_results.addItem({
									label:label,
									classname: "search-bucket--" + _.kebabCase(bucket.key)
								});

							bucket.bucket_ui.id = bucket.key;

							bucket.on('add:item', function (ev, item) {

								// update title to bold the search term text
								var escaped_term = _.escapeRegExp(self.children.search.term),
									regex = new RegExp('(' + escaped_term + ')', 'gi');

								item.data.title = item.data.title.replace(/<\/?strong>/g, "");
								item.data.title = item.data.title.replace(regex, '<strong>$1</strong>');

								item.bucket_item_ui = bucket.bucket_ui.addItem(_.extend(item.data, {id:item.id}));

								item.bucket_item_ui.on('result:click', function (ev) {
									var flag = params.search.metrics_flag;

									if ( ! flag || (flag && awf.flags.isActive(flag))) {
										awf.tagMetric({
											ev: 'click: search result item',
											name: self.children.search.term,
											target: item.data.title.replace(/<\/?strong>/g, ""),
											action: item.bucket_item_ui.$el.index(),
											section: item.bucket,
											group: item.bucket_item_ui.collection.$el.index(),
											module: item.channel
										});
									}
								});
							});

							bucket.on('remove:item', function (ev, items) {
								_.forEach(items, function (item) {
									item.bucket_item_ui.removeFromCollection();
								});
							});

							// Sort the bucket order
							var indexes = [],
								visible_ids = _.map(self.children.search_results.items, 'id'),
								configed_ids = _.map(params.search.buckets, 'bucket');
							_.forEach(configed_ids, function (id) {
								var ind = _.indexOf(visible_ids, id);
								if (ind > -1)
									indexes.push(ind);
							});
							var order = awf.util.reducedOrder(indexes);
							self.children.search_results.setOrder(order);

						} else {
							console.warn('Not presenting bucket. Bucket was not configured: ', bucket.key);
						}
					});


					awf.search.results.dimensions.bucket.on('remove:group', function (ev, bucket) {
						if (bucket.bucket_ui) {
							bucket.bucket_ui.removeFromCollection();
						}
					});


					var debouncedSearchQuery = _.debounce(function () {
						var term = self.children.search.term;

						awf.search.results.removeAllItems();
						if (term) {
							awf.search.query(term);
							self.children.search_results.setActiveState(true);
						} else {
							self.children.search_results.setActiveState(false);
						}
					}, 500);
					self.children.search.on('change:term', debouncedSearchQuery);

					self.children.search._$input.on('focus', function () {
						if ($(this).val() !== "") {
							self.children.search_results.setActiveState(true);
						}
					});




					/*	Tab Loop
					------------------------------------------*/
						var $refocus_head = $('<button class="awf-access" aria-hidden="true" tabindex="-1">Refocus to last</button>'),
							$refocus_tail = $('<button class="awf-access" aria-hidden="true" tabindex="-1">Refocus to first</button>');

						self._$search
							.prepend($refocus_head)
							.append($refocus_tail);

						$refocus_head
							.on('focus.internal', function(ev) {
								var $target = self._$search.find(':tabbable').eq(-1).focus();
							});
						$refocus_tail
							.on('focus.internal', function(ev) {
								var $target = self._$search.find(':tabbable').eq(1).focus();
							});


					/*	Arrowing
					------------------------------------------*/
						self.children.search
							.on("keydown:down", function (e, params) {
								if (self.children.search_results.active_state) {
									params.ev.preventDefault();
									self._$search.find('.js-bucket-item').first().focus();
								}
							})
							.on("keydown:up", function (e, params) {
								if (self.children.search_results.active_state) {
									params.ev.preventDefault();
									self._$search.find('.js-bucket-item').last().focus();
								}
							});

						self.children.search_results
							.on("results:down", function (ev, params) {
								params.ev.preventDefault();
								var $current = $(params.ev.target).closest('.js-bucket-item')[0],
									$focusable = self._$search.find('.js-bucket-item'),
									len = $focusable.length,
									i = -1;

								while (++i<len && $current !== $focusable[i]);

								if (i === len-1) {
									self.children.search._$input.focus();
								} else {
									$focusable.eq(i+1).focus();
								}
							})
							.on("results:up", function (ev, params) {
								params.ev.preventDefault();
								var $current = $(params.ev.target).closest('.js-bucket-item')[0],
									$focusable = self._$search.find('.js-bucket-item'),
									len = $focusable.length,
									i = -1;

								while (++i<len && $current !== $focusable[i]);

								if (i === 0) {
									self.children.search._$input.focus();
								} else {
									$focusable.eq(i-1).focus();
								}
							});


					/*	GLASS
					------------------------------------------*/
						var $glass = $('<div class="awf-search-glass" aria-hidden="true" role="presentation"></div>');

						self._$search
							.append($glass);

						$glass
							.on('click.internal', function(ev) {
								self.children.search.triggerHandler('click:search_glass');
								self.children.search_results.setActiveState(false);
								self.children.search.setActiveState(false);
							});





					/*	LISTEN FOR RESULTS ACTIVE_STATE
					------------------------------------------*/
						self.children.search_results.on('change:active_state', function (ev, val) {
							if (val) {
								self.setFixed(false);
								$refocus_head.add($refocus_tail)
									.attr('tabindex','0');
								$glass.show();
							} else {
								self.setFixed(true);
								$refocus_head.add($refocus_tail)
									.attr('tabindex','-1');
								$glass.hide();
							}
						});





					/*	LISTEN FOR RESULTS ESCAPE KEY
					------------------------------------------*/
						self.children.search_results.$el
							.on('keyup.internal', function (ev) {
								if (ev.keyCode == awf.util.keyCodes.esc) {
									self.children.search.$el.trigger(
										$.Event( 'keyup', { keyCode: ev.keyCode, which: ev.keyCode } )
									);
									self.children.search_results.setActiveState(false);
								}
							});





					/*	LISTEN FOR MOBILE SEARCH ICON CLICK
					------------------------------------------*/
						self.children.search_button
							.on('click:button', function () {
								$('body').addClass('-search-mobile-is-active');
								self.children.search._$input.focus();
							});


					/*	LISTEN FOR ENTER KEY
					------------------------------------------*/
						self.children.search.on('click:submit', function (ev, term) {
							var endpoint = params.search.endpoint;
							if (endpoint) {
								var url = _.template(endpoint)({
										term: escape(term)
									});

								console.log('Launching search with term: `' + term + '`: ', url);
								window.open(url);
							}
						});

			} else {
				console.log('not configured: `search`');
			}

		console.groupEnd();
	}



	/*	element shortcuts
	------------------------------------------*/
		Parent.generateDomProperties(Masthead, {
			nav_toggle: '.js-nav-toggle',
			brand: '.js-brand',
			brand_logo: '.js-brand-logo',
			brand_name: '.js-brand-name',
			user_container: '.js-user-container',
			trays_container: '.js-trays-container',
			search: '.js-search-container'
		});





	_.extend(Masthead.prototype, {

		/**
		 * Hide the masthead logo image
		 * @memberof awf.ui.Masthead
		 * @return {Object} this (chainable)
		 */
		hideLogo: function () {
			this._$brand_logo
				.hide();

			return this;
		},


		/**
		 * Show the masthead logo image
		 * @memberof awf.ui.Masthead
		 * @return {Object} this (chainable)
		 */
		showLogo: function () {
			this._$brand_logo
				.css('display','');

			return this;
		},


		/**
		 * Helper method that generates inline styles for masthead background color
		 * and title color.
		 * @memberof awf.ui.Masthead
		 * @private
		 * @return {Object} this (chainable)
		 */
		_updateCSS: function () {
			var self = this,
				css = {},
				css_string = '';

			if (self.background || self.foreground) {
				css['html.default header.-background-base'] = {
					'background': self.background
				};
				css['html.default .awf-brand'] = {
					'color': self.foreground
				};

				_.forEach(css, function (pair, query) {
					var props = [];
					_.forEach(pair, function (val, prop) {
						if (val)
							props.push(prop + ': ' + val);
					});
					css_string += query + ' { ' + props.join('; ') + '; }\n';
				});

				self.children.stylesheet.css(css_string);
			}

			return self;
		}

	});

	/**
	 * @typedef mastheadConfig
	 * @memberof awf.ui.Masthead
	 * @type Object
	 * @description The mastheadConfig object is used to describe the configurable elements of a masthead ui component. The configuration is used to build the masthead through {@link awf.init} and [awf.app.compose]{@link awf.__.App.compose}.
	 *
	 * @property {object} [name]
	 * @property {string|null} [name.value] The masthead title
	 * @property {boolean} [name.customizable] Should the masthead title be customizable?
	 * @property {string|object|null} [logo] The path to the logo image, or a jQuery object for the logo
	 * @property {string} [background] The masthead background color (must be valid CSS color value)
	 * @property {string} [foreground] The masthead title color (must be valid CSS color value)
	 *
	 * @example
	 * // This will create and initialize awf.page.masthead with a logo, name, and CSS background
	 * awf.init({
	 * 	page: {
	 * 		name: {
	 * 			value: String, // app/company
	 * 			customizable: Boolean
	 * 		},
	 * 		masthead: {
	 * 			background: String, // CSS declaration
	 * 			foreground: String, // CSS declaration
	 * 			logo: String // path to logo image
	 * 		}
	 * 	}
	 * });
	 */


/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "<header role=\"banner\" class=\"masthead masthead--fixed group -background-base\" data-feature=\"page.masthead\">\n\t<div class=\"js-leftnav-toggle-placeholder\"></div>\n\n\t<div class=\"js-brand-logo masthead__logo\"></div>\n\t<div class=\"js-brand-name masthead__name\"></div>\n\n\t<div class=\"js-search-container masthead__search\" data-feature=\"masthead.search\"></div>\n\t<div class=\"js-trays-container masthead__trays\" data-feature=\"masthead.trays\"></div>\n\t<div class=\"js-user-container masthead__user -border-color-base\" data-feature=\"masthead.user\"></div>\n</header>\n";

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = MastheadUser;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(135);





	use(BaseUI).toCreate(MastheadUser);

	function MastheadUser (params) {
		var self = this;

		params = params || {};
		params.template = params.template || template;

		this.person = null;

		// The dropdown
		this.dropdown = new awf.ui.Dropdown({
			render: false,
			direction: "right",
			content_width: 260,
			label: "User Tooltip",
			offset: {
				x: -5,
				y: -6
			}
		});

		// The avatar
		this.avatar = new awf.ui.ImageCircle({
			render: false,
			size: 26
		});

		// The dropdown's avatar
		this.dropdown.avatar = new awf.ui.ImageCircle({
			render: false,/*
			parent: function () { return self._$auth_dd_avatar; },*/
			size: 68,
			element_type: "a"
		});


		BaseUI.call(this, params);
	}





	MastheadUser.dropdown_template = 'the dropdown template has not been adapted';




	BaseUI.generateDomProperties(MastheadUser, {
		signin         : '.js-signin',
		auth_dd        : '.js-authenticated-dropdown',
		auth_dd_avatar : '.js-authenticated-dropdown .js-avatar',
		auth_dd_name   : '.js-authenticated-dropdown .js-name',
		auth_dd_email  : '.js-authenticated-dropdown .js-email',
		auth_dd_msg    : '.js-authenticated-dropdown .js-msg'
	});







	_.extend(MastheadUser.prototype, {

		render: function () {
			BaseUI.prototype.render.apply(this, arguments);

			// dropdown
			this.dropdown.setContent(awf.ui.MastheadUser.dropdown_template);
			this.dropdown
				.render()
				.$el.appendTo(this._$auth_dd);
			this.dropdown._$button
				.addClass('-awf-link');

			if (this.person) {
				this._renderPerson();
			}

			var self = this;
			this._$signin.on("click", function () {
				self.trigger("click:sign-in");
			});

			return this;
		},

		setPerson: function (person) {
			this.person = person;
			this._renderPerson();
			return this;
		},

		_renderPerson: function () {
			console.warn("MastheadUser _renderPerson has not been adapted.");
			return this;
		},

		setAsAnonymous: function () {
			this.$el.removeClass('-is-authenticated');
			return this;
		},

		setAsAuthenticated: function () {
			this.$el.addClass('-is-authenticated');
			return this;
		}

	});


/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "<div class=\"masthead-user\">\n\t<button class=\"js-signin masthead-user__signin -awf-link-inverted\"><span class=\"-not-mobile\">Welcome,</span> <strong>Sign In</strong></button>\n\t<div class=\"js-authenticated-dropdown masthead-user__dropdown\"></div>\n</div>\n";

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = CustomName;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Base,
		template = __webpack_require__(137);

	use(Parent).toCreate(CustomName);

	/**
	 * Custom Name Component.<br>
	 * This component consists of UI form elements for customizing the masthead title. Normally, the title displays the application's name, but when enabled, this component allows the user to change the default value.
	 * @type {CustomName}
	 * @implements {CustomName}
	 * @memberOf awf.ui
	 * @class
	 *
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param {Object} params
	 * @param {null|number} [params.max_length] The input's maxlength property value
	 * @param {boolean} [params.allow_edit] `false` disables the ability to edit while `true` enables the ability to edit
	 * @param {null|string} [params.name] The initial name to use for instantiation
	 *
	 * @property {null|number} max_length=50 The input's maxlength property value
	 * @property {boolean} allow_edit=false If `false`, the ability to edit is currently disabled. If `true`, the ability to edit is currenlty enabled.
	 * @property {null|string} name=null The displayed name.
	 * @property {object} _$button The jquery reference to the button element
	 * @property {object} _$name The jquery reference to the name element
	 * @property {object} _$input The jquery reference to the input element
	 * @property {object} _$submit The jquery reference to the submit element
	 * @property {object} _$cancel The jquery reference to the cancel element
	 * @property {object} _$max_text The jquery reference to the max_text element
	 * @property {object} _$count The jquery reference to the count element
	 *
	 * @example
	 *  // Creating a simple instance
	 *  var custom_name = new awf.ui.CustomName({
	 *    max_length: 30,
	 *    allow_edit: true,
	 *    name: 'My Default Name'
	 *  });
	 *
	 */
	function CustomName (params) {
		params = params || {};
		this.template = params.template || this.template || template;

		Parent.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Sets this._$input maxlength property value.
			 * @memberof awf.ui.CustomName
			 * @name setMaxLength
			 * @function
			 * @instance
			 *
			 * @param {null|string} len=50 The maxlength to set.
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:max_length passing old and new values
			 */
			max_length: {
				default: 50,
				types: ['null','number'],
				renderHandler: function (len) {
					if (len && Number.isInteger(len)) {
						this._$input.attr("maxLength",len);
						this._$count.html(len);
						this._$max_text.css('display','');
					} else {
						this._$max_text.hide();
						this._$input.removeAttr("maxLength");
						this._$count.html("");
					}
				}
			},


			/**
			 * Enables or disables the custom name form
			 * @memberof awf.ui.CustomName
			 * @name setAllowEdit
			 * @function
			 * @instance
			 *
			 * @param {boolean} val=false `false` disables the form while `true` enables it
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:allow_edit passing old and new values
			 */
			allow_edit: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {
					if (val) {
						this.$el.addClass('-is-editable');
						this._$button.removeAttr('tabindex');
					} else {
						this.$el.removeClass('-is-editable');
						this._$button.attr('tabindex','-1');
					}
				}
			},


			/**
			 * Updates this._$name html
			 * @memberof awf.ui.CustomName
			 * @name setName
			 * @function
			 * @instance
			 *
			 * @param {null|string} val=null The name to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:name passing old and new values
			 */
			name: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					if (val)
						this._$name.html(val);
				}
			}

		});
	}


	/*	element shortcuts
	------------------------------------------*/
		Parent.generateDomProperties(CustomName, {
			button: '.js-custom-name-btn',
			name: '.js-custom-name',
			input: '.js-custom-name-input',
			submit: '.js-custom-name-submit',
			cancel: '.js-custom-name-cancel',
			max_text: '.js-custom-name-max-text',
			count: '.js-custom-name-text-count'
		});


	_.extend(CustomName.prototype, {

		/**
		 * Renders the component and binds a number of events.<br><br>
		 * <strong>this._$button</strong><br>
		 * on "click" fires this#click:edit<br><br>
		 * <strong>this._$cancel</strong><br>
		 * on "click" fires this#click:cancel<br><br>
		 * <strong>this._$submit</strong><br>
		 * on "click" fires this#click:save<br><br>
		 * <strong>this._$input</strong><br>
		 * on "keyup" fires this#input:keyup for any keyup<br>
		 * on "keyup" fires this#keyup:esc when esc key is pressed<br>
		 * on "keyup" fires this#keyup:enter when enter key is pressed
		 * @memberof awf.ui.CustomName
		 * @instance
		 *
		 * @return {object} this (chainable)
		 */
		render: function () {
			var self = this,
				key_code_map = {};
			key_code_map[awf.util.keyCodes.esc] = 'esc';
			key_code_map[awf.util.keyCodes.enter] = 'enter';

			Parent.prototype.render.apply(self, arguments);

			self._$button.on('click', function(ev) {
				ev.stopPropagation();
				self.triggerHandler("click:edit");
			});

			self._$cancel.on('click', function() {
				self.triggerHandler("click:cancel");
			});

			self._$submit.on('click', function() {
				self.triggerHandler("click:save");
			});

			self._$input.on("keyup", function (ev) {
				var kc = ev.keyCode;
				self.triggerHandler("input:keyup");
				if (key_code_map[kc])
					self.triggerHandler("keyup:" + key_code_map[kc]);
			});

			return self;
		}

	});


/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-custom-name\">\n\t<button type=\"button\" class=\"js-custom-name-btn awf-custom-name__btn\" tabindex=\"-1\" aria-label=\"Edit Custom Name\">\n\t\t<span class=\"js-custom-name awf-custom-name__btn__name\"></span>\n\t\t<em class=\"awf-custom-name__btn__icon awficon-edit -color-alt\" alt=\"edit\"></em>\n\t</button>\n\t<form action=\"javascript:;\" class=\"awf-custom-name__form\">\n\t\t<label for=\"awf-custom-name\" class=\"awf-access\">Custom Name</label>\n\t\t<input type=\"text\" id=\"awf-custom-name\" class=\"js-custom-name-input awf-custom-name__form__input -border-color-link -awf-focus\" value=\"\" autocomplete=\"off\" />\n\t\t<button type=\"submit\" class=\"js-custom-name-submit awf-custom-name__form__submit -awf-focus awf-btn\">Save</button>\n\t\t<button type=\"button\" class=\"js-custom-name-cancel awf-custom-name__form__cancel -awf-link\">Cancel</button>\n\t\t<div class=\"js-custom-name-max-text awf-custom-name__form__max-text -color-alt\">(Remaining Characters: <span class=\"js-custom-name-text-count awf-custom-name__form__max-text__count\"></span>)</div>\n\t</form>\n</div>\n";

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = FooterItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		template = __webpack_require__(139),
		Parent = awf.ui.CollectionItem,
		BaseUI = awf.ui.Base;

	use(Parent).toCreate(FooterItem);



	/**
	 * FooterItem Component.
	 * @class
	 * @type {FooterItem}
	 * @implements {FooterItem}
	 * @memberOf awf.ui
	 * @extends {awf.ui.CollectionItem}
	 * @see {@link awf.ui.Footer} for collection details
	 *
	 * @param {object} [params]
	 * @param {null|string} [params.label] The footer item label to set
	 * @param {null|string} [params.href] The footer item href to set
	 * @param {null|string} [params.target] The footer item target attribute value to set
	 *
	 * @property {null|string} label=null The current footer item label.
	 * @property {null|string} href=null The current footer item href attribute value.
	 * @property {null|string} target='_blank' The current footer item target attribute value.
	 * @property {object} _$item A jQuery reference to the footer item element.
	 */
	function FooterItem (params) {
		params = params || {};
		this.template = params.template || this.template || template;

		this._default_parent = function () {
	        if (this.collection) {
	            return this.collection._$links;
	        }
	        return null;
	    };

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates this.label and the footer item's label.
			 * @memberof awf.ui.FooterItem
			 * @name setLabel
			 * @function
			 * @instance
			 *
			 * @param {string|null} val A label for the footer item.
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:label passing old and new values
			 */
			label: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					this._$item.html(val);
				}
			},

			/**
			 * Updates this.href and the footer item link's href attribute.
			 * @memberof awf.ui.FooterItem
			 * @name setHref
			 * @function
			 * @instance
			 *
			 * @param {string|null} val The href value for the footer item link.
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:href passing old and new values
			 */
			href: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					this._$item.attr('href',val);
				}
			},

			/**
			 * Updates this.target and the footer item's target attribute.
			 * @memberof awf.ui.FooterItem
			 * @name setTarget
			 * @function
			 * @instance
			 *
			 * @param {string|null} val The footer link's target.
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:target passing old and new values
			 */
			target: {
				default: '_blank',
				types: ['null','string'],
				renderHandler: function (val) {
					this._$item.attr('target', val || '_blank');
				}
			}

		});

		Parent.apply(this, arguments);
	}


	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(FooterItem, {
			item: '.js-footer-item'
		});


	_.extend(FooterItem.prototype, {
		//
	});


/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = "<li class=\"footer__list-item\">\n\t<a class=\"js-footer-item footer__list-item__a\"></a>\n</li>\n";

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Footer;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Collection,
		template = __webpack_require__(141),
		BaseUI = awf.ui.Base;

	use(Parent).toCreate(Footer);

	/**
	 * @typedef footerConfig
	 * @memberof awf.ui.Footer
	 * @type Object
	 * @see {@link awf.ui.FooterItem} for collection item details
	 *
	 * @description
	 * The footerConfig object is a sub-element of the AWF config ([awfConfig]{@link awf.awfConfig}) and Application Copmposition config ([appCompConfig]{@Link awf.__.App.appCompConfig}) initialization objects. It is used to describe the configurable elements of a page footer component. The configuration is used to build the footer through {@link awf.init} or through [awf.app.compose]{@link awf.__.App.compose}.
	 *
	 * @property  {string} [name] the alt attribute text for the footer image
	 * @property  {string|object|null} [logo] the path to the logo image
	 * @property  {string} [links] the path to the links JSON file
	 */


	/**
	 * Footer UI Component
	 * @type {Footer}
	 * @class
	 * @implements {Footer}
	 * @memberOf awf.ui
	 * @augments {awf.ui.Base}
	 * @see {@link awf.ui.FooterItem} for collection item details
	 *
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param  {awf.ui.Footer.footerConfig} [params]
	 *
	 * @property {object} _list_item Lodash template for a footer link
	 * @property {string} name='App' The alt attribute text for the footer image.
	 * @property {string|object|null} logo=null The path to the logo image
	 * @property {array} links=null An array of link objects (see setLinks() method for details about these objects)
	 * @property {object} _$links jQuery object for links container
	 * @property {object} _$logo_container jQuery object for logo container
	 *
	 * @example
	 *  // Creating a simple instance
	 *  var footer = new awf.ui.Footer();
	 */
	function Footer (params) {
		params = params || {};
		params.template = params.template || this.template || template;

		Parent.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates the footer logo alt text.
			 * @memberof awf.ui.Footer
			 * @name setName
			 * @function
			 * @instance
			 *
			 * @param {string|null} val A name for the footer logo alt text
			 * @return {object} this (chainable)
			 *
			 * @example
			 * this.setName('Hello World');
			 * // Logo Alt attribute value  → "Hello World Footer Logo"
			 *
			 * @fires this#change:name passing old and new values
			 */
			name: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					this._$logo_container.find('.js-footer-logo-image')
						.attr('alt', val + ' Footer Logo');
				}
			},


			/**
			 * Pass in an array of links or relative path to a JSON file to build footer links. Order of items in the
			 * array will dictate the order of their display in the footer.
			 * @memberof awf.ui.Footer
			 * @name setLinks
			 * @function
			 * @instance
			 *
			 * @param {Object[]|string} links An array of links for the footer, or a path to a JSON file with the links.
			 * @param {string} links[].href The link's href
			 * @param {string} links[].label The link's label
			 * @param {string} [links[].target] The link's target attribute value
			 *
			 * @return {Object} this (chainable)
			 *
			 * @example
			 *
			 * var footer = new awf.ui.Footer();
			 *
			 * footer.setLinks([
			 * 	{
			 * 		href: "http://www.google.com",
			 * 		label: "Google",
			 * 		target: "_parent" //optional defaults to '_blank'
			 * 	},
			 * 	{
			 * 		href: "http://www.facebook.com",
			 * 		label: "Facebook"
			 * 	}
			 * ]);
			 *
			 * // or
			 *
			 * footer.setLInks("path/to/links.json");
			 *
			 * @fires this#change:links passing old and new values
			 */
			links: {
				default: null,
				types: ['string','array'],
				renderHandler: function (links) {
					var self = this;

					if (typeof links == 'string') {
						$.ajax({
							url: links,
							timeout: 5000,
							dataType: 'json'
						})
						.done(function (response) {
							self._renderLinks(response);
						})
						.fail(function (response) {
							console.error("Footer Links: The AJAX request for URL '" + links + "' did not resolve. RESPONSE:", response);
						});
					} else {
						self._renderLinks(links);
					}
				}
			},


			/**
			 * Sets a footer logo. Hides the logo container if passed null.
			 * @memberof awf.ui.Footer
			 * @name setLogo
			 * @function
			 * @instance
			 *
			 * @param  {string|object|null} val A relative path to the footer logo to load, or a jQuery DOM object
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:logo passing old and new values
			 */
			logo: {
				default: null,
				types: ['string','object','null'],
				renderHandler: function (val) {
					switch (typeof val) {

						case "object":
							if (val instanceof $) {
								this._$logo_container.empty().append(val);
								this.showImage();
							} else {
								this.hideImage();
							}
							break;

						default:
							var $img = $('<img class="js-footer-logo-image footer__logo__image" />');

							$img.attr({
								'src': val,
								'alt': this.name + ' Footer Logo'
							});

							this._$logo_container.empty().append($img);
							this.showImage();

					}
				}
			}

		});
	}


	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Footer, {
			links: '.js-footer-links',
			logo_container: '.js-footer-logo'
		});


	_.extend(Footer.prototype, {

		Item: awf.ui.FooterItem,


		/**
		 * Hide the footer logo container
		 * @memberof awf.ui.Footer
		 * @instance
		 *
		 * @return {Object} this (chainable)
		 */
		hideImage: function () {
			this._$logo_container
				.addClass('-is-hidden');

			return this;
		},


		/**
		 * Show the footer logo container
		 * @memberof awf.ui.Footer
		 * @instance
		 *
		 * @return {Object} this (chainable)
		 */
		showImage: function () {
			this._$logo_container
				.removeClass('-is-hidden');

			return this;
		},


		/**
		 * Renders this.links. Helper method called by this.setLinks(). This method is private and should not be used independently.
		 * @memberof awf.ui.Footer
		 * @private
		 * @instance
		 *
		 * @param {array} [links] the links provided by this.setLinks()
		 *
		 * @return {Object} this (chainable)
		 */
		_renderLinks: function (links) {
			if (links) {
				var self = this;

				self.links = links;

				self.removeAllItems();

				_.forEach(links, function(link) {
					self.addItem({
						label: link.label,
						href: link.href,
						target: link.target
					});
				});
			}

			return this;
		}

	});




/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = "<footer role=\"contentinfo\" class=\"footer footer--fixed group -background-base\" data-feature=\"page.footer\">\n\n\t<nav role=\"navigation\" aria-label=\"Footer Links\" class=\"footer__nav\" data-feature=\"footer.linklist\">\n\t\t<ul class=\"js-footer-links footer__list-wrap\"></ul>\n\t</nav>\n\n\t<div class=\"js-footer-logo footer__logo -is-hidden\"></div>\n\n</footer>\n";

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Button;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(143);


	use(BaseUI).toCreate(Button);


	/**
	 * Button UI Component
	 * @type {Button}
	 * @class
	 * @implements {Button}
	 * @memberOf awf.ui
	 *
	 * @class
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 * @param  {Object} params
	 * @param {null|string} params.classname The class selector(s) to add to the button
	 * @param {null|feature} params.feature The feature flag for the button, if applicable
	 * @param {null|text} params.text The button's text, hidden but accessible
	 * @param {null|string} params.icon The button's icon. Should be an icon-font class selector
	 * @param {boolean} params.tooltip When `true` a title text tooltip will be added to the button
	 *
	 * @property {null|string} _classname The class selector(s) for the button
	 * @property {null|string} _feature The feature flag for the button
	 * @property {null|string} _text The accessible text for the button
	 * @property {null|string} _icon The icon for the button
	 * @property {boolean} _tooltip=false Adds a title attribute to the button when `true`
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var button = new awf.ui.Button();
	 *
	 *  // Creating an instance with parameters
	 *  // The parameter values are placed in the template
	 *  // on instantiation. All properties are optional.
	 *  var button = new awf.ui.Button({
	 *  		classname: {string}, //classname of button.$el
	 *  		feature:   {string}, //data-feature attribute value of button.$el, for feature flagging
	 *  		text:      {string}, //by default this will be hidden-but-accessible
	 *  		icon:      {string}, //icon-font classname(s)
	 *  		tooltip:   {boolean} //set to `true` if a tooltip should be included with the button
	 *  	});
	 *
	 */
	function Button (params) {
		var _template;
		params = params || {};

		this._classname = params.classname || null;
		this._feature = params.feature || null;
		this._text = params.text || null;
		this._icon = params.icon || null;
		this._tooltip = params.tooltip || false;

		_template = _.template(template);
		params.template = _template({
			classname: this._classname,
			feature: this._feature,
			text: this._text,
			icon: this._icon
		});

		BaseUI.call(this, params);
	}

	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Button, {
			text: '.js-btn-text', // this._$text
			icon: '.js-btn-icon' // this._$icon
		});

	_.extend(Button.prototype, {

		/**
		 * Binds this.$el click event to the instance. So, when this.$el is clicked, the
		 * instance will fire the event "click:button".
		 * @memberof awf.ui.Button
		 * @name render
		 * @return {Object} self chainable
		 *
		 * @example
		 *  var button = new awf.ui.Button();
		 *
		 *  button.on('click:button', function () {
		 *    console.log('Button clicked!');
		 *  });
		 *
		 *  //somewhere else in the code (or user click on button.$el in the UI)
		 *
		 *  button.$el.click();
		 *  // console output → Button clicked!
		 */
		render: function () {
			BaseUI.prototype.render.apply(this, arguments);

			var self = this;

			self.$el.on('click', function () {
				self.triggerHandler('click:button');
			});

			if (self._tooltip) {
				self.$el.attr('title', self._text);
			}

			return self;
		},

		/**
		 * Gives the button an icon.
		 * @memberof awf.ui.Button
		 * @name setIcon
		 * @param {string} value The icon-font classname
		 * @return {Object} self chainable
		 */
		setIcon: function (value) {
			if ( ! value)
				console.warn("Cannot set button icon, no classname was given.");
			else
				this._$icon.attr('class','js-btn-icon btn-control__icon ' + value);

			return this;
		},

		/**
		 * Hides the button's icon
		 * @memberof awf.ui.Button
		 * @name hideIcon
		 * @return {Object} self chainable
		 */
		hideIcon: function() {
			this._$icon.hide();
			return this;
		},

		/**
		 * Shows the button's icon (it is visible by default)
		 * @memberof awf.ui.Button
		 * @name showIcon
		 * @return {Object} self chainable
		 */
		showIcon: function() {
			this._$icon.show();
			return this;
		},

		/**
		 * Gives the button accessible text.
		 * Whatever is passed will replace any pre-existing text.
		 * @memberof awf.ui.Button
		 * @name setAccessText
		 * @param {string|element} value The button's text.
		 * @return {Object} self chainable
		 */
		setAccessText: function (value) {
			this._$text.empty().html(value);
			return this;
		}

	});


/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = "<button class=\"btn-control {{classname}}\"{[ if (feature) { ]} data-feature=\"{{feature}}\"{[ } ]}>\n\t<span class=\"js-btn-text btn-control__text{[ if (icon) { ]} awf-access{[ } ]}\">{{text}}</span>\n\t<em class=\"js-btn-icon btn-control__icon {{icon}}\"></em>\n</button>\n";

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = MastheadTrayCollection;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		template = __webpack_require__(145),
		Parent = awf.ui.Base;



	awf.util.use(Parent).toCreate(MastheadTrayCollection);

	/**
	 * MastheadTrayCollection UI Component
	 * @memberOf awf.ui
	 * @class
	 *
	 * @extends {awf.ui.Collection}
	 *
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param  {Object} parameters
	 * @property {object} items - collection of items MastheadTrayCollection tracks
	 * @property {string} dropdown_id - the id of the active item
	 * @property {object} _$buttons - jQuery object for buttons container
	 * @property {object} _$dropdown - jQuery object for dropdown container
	 * @property {object} _$dropdown_close - jQuery object for dropdown close button
	 * @property {object} _$dropdown_content - jQuery object for dropdown contents container
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var masthead_trays = new awf.ui.MastheadTrayCollection();
	 */
	function MastheadTrayCollection (params) {
		// todo: Add unit test -- fill in the gaps :/
		console.group("Constructing Trays");
		console.log("params :",params);

		var self = this;

		params = params || {};
		this.template = params.template || this.template || template;

		this.trays = {};
		this.hide_effect = 'slideUp';
		this.show_effect = 'slideDown';

		awf.util.mixin.properties(this, params, {

			overlay_active: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {
					$('body')[val ? 'addClass' : 'removeClass']('-overlay-active');
					this.hide_effect = val ? 'fadeOut' : 'slideUp';
					this.show_effect = val ? 'fadeIn' : 'slideDown';
				}
			},

			// todo: Add unit test -- setCurrent
			current: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val, old_val) {

					var self = this,
						glass_namespace = 'masthead_trays';

					function removeOld (old_tray) {
						// Destroy the old cog view
						old_tray.view_instance.destroy();
						old_tray.view_instance = null;

						// Hide old containers
						old_tray.container.$el.addClass('-hidden');

						old_tray.button.$el
							.removeClass('-is-active') // tell the button to appear "inactive"
							.focus(); // focus on the button

						// Reset Overlay
						self.setOverlayActive(false);
					}


					if (val) {

						if (old_val) {
							removeOld(self.trays[old_val]);
						} else {
							self.triggerHandler('show');
						}

						if (self.trays[val].cog.views.masthead_tray.overlay) {
							self.setOverlayActive(true);
						}

						self._$dropdown[self.show_effect]('fast');

						// tell the new button to appear "active"
						self.trays[val].button.$el.addClass('-is-active');

						// show this container
						self.trays[val].container.$el.removeClass('-hidden');

						// Render the cog view
						self.trays[val].view_instance = self.trays[val].cog.renderView('masthead_tray', self.trays[val].container.$el, {

							hide: function () {
								self.setCurrent(null);
								return this;
							}

						});

						// Move focus to the close button (the start of the tab loop)
						self._$dropdown_close.focus();


						// Faux-Glass & Escape Key
						$('body')
							// click
							.off('click.' + glass_namespace)
							.on('click.' + glass_namespace, function(e) {
								if ( !self.$el.is(e.target) && self.$el.has(e.target).length === 0) {
									self.setCurrent(null);
								}
							})
							// esc
							.off('keyup.' + glass_namespace)
							.on('keyup.' + glass_namespace, function (e) {
								if (e.keyCode == awf.util.keyCodes.esc) {
									self.setCurrent(null);
								}
							});

					} else {
						$('body')
							.off('click.' + glass_namespace)
							.off('keyup.' + glass_namespace);

						if (old_val) {
							self.triggerHandler('hide');
							self._$dropdown[self.hide_effect]('fast', function () {
								removeOld(self.trays[old_val]);
							});
						}
					}
				}
			}

		});

		Parent.call(this, params);

		_.extend(this.children, {
			buttons: new awf.ui.Collection({
				parent: self._$buttons,
				Item: __webpack_require__(146)
			}),
			containers: new awf.ui.Collection({
				parent: self._$dropdown_content
			})
		});

		this.children.buttons.$el
			.addClass('masthead-trays__button-collection');

		console.groupEnd();
	}



	/*	element shortcuts
	------------------------------------------*/
		awf.ui.Base.generateDomProperties(MastheadTrayCollection, {
			buttons: '.js-masthead-trays-buttons',
			dropdown: '.js-masthead-trays-dropdown',
			dropdown_close: '.js-masthead-trays-dropdown-close',
			dropdown_content: '.js-masthead-trays-dropdown-content',
			tab_loop_to_last: '.js-masthead-trays-loop-to-last',
			tab_loop_to_first: '.js-masthead-trays-loop-to-first'
		});



	/*	Prototype Methods
	------------------------------------------*/
		_.extend(MastheadTrayCollection.prototype, {

			// todo: Add unit test -- render
			render: function () {

				var self = this;

				Parent.prototype.render.call(this);

				// Bind the close button
				self._$dropdown_close
					.on('click', function () {
						self.setCurrent(null);
					});

				// Tab loop to first
				self._$tab_loop_to_first
					.on('focus', function () {
						self._$dropdown_close.focus();
					});

				// Tab loop to last
				self._$tab_loop_to_last
					.on('focus', function () {
						var $elem = self._$dropdown_content.find(':tabbable').last();
						if ($elem.length > 0) {
							$elem.focus();
						} else {
							self._$dropdown_close.focus();
						}
					});

			},


			// todo: Add unit test -- addItem
			addItem: function (cog) {

				var self = this;

				console.group("Adding cog to MastheadTrayCollection");

				console.log('cog: ', cog);

				if ( ! (cog.views && cog.views.masthead_tray)) {
					throw new Error('Cannot add cog to MastheadTrayCollection - cog has no `masthead_tray` view defined.');
				}

				console.group("Creating the button");
				var button = self.children.buttons.addItem({
						text: cog.views.masthead_tray.label,
						icon: cog.views.masthead_tray.icon,
						tooltip: true,
						classname: '-awf-link -text-decoration-none'
					});

				// not needed -- just here for DOM inspection
				button.$el.attr('data-cog', cog.id);

				console.log(button);
				console.groupEnd();

				console.group("Creating the container");
				var container = self.children.containers.addItem();

				// not needed -- just here for DOM inspection
				container.$el.attr('data-cog', cog.id);

				console.log(container);
				console.groupEnd();

				var tray = {
						cog: cog,
						button: button,
						container: container
					};

				// hide the container
				tray.container.$el.addClass('-hidden');

				// tie the button to the container (open/close) ...
				tray.button.on('click:button', function (ev) {
					if (self.current === cog.id) {
						self.setCurrent(null);
					} else {
						self.setCurrent(cog.id);
					}
				});

				this.trays[cog.id] = tray;

				// cog._maybeInitializeView('masthead_tray', {

				// 	show: function () {
				// 		self.setCurrent(cog.id);
				// 		return this;
				// 	}

				// });

				console.groupEnd();
			},

			// todo: Add unit test -- removeItem
			removeItem: function (item) {
				self.children.buttons.removeItem(item.button);
				self.children.containers.removeItem(item.container);
			}
		});


/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "<div class=\"masthead-trays\">\n\t<div class=\"js-masthead-trays-buttons masthead-trays__buttons\"></div>\n\t<div id=\"masthead-trays-dropdown\" class=\"js-masthead-trays-dropdown masthead-trays__dropdown -background-base\" role=\"region\" aria-label=\"Masthead Trays\">\n\t\t<button class=\"awf-access js-masthead-trays-loop-to-last\" aria-hidden=\"true\">Loop to last</button>\n\t\t\n\t\t<button class=\"js-masthead-trays-dropdown-close masthead-trays__dropdown__close awficon-close -awf-focus\">\n\t\t\t<span class=\"awf-access\">Close</span>\n\t\t</button>\n\t\t<div class=\"js-masthead-trays-dropdown-content masthead-trays__dropdown__content\"></div>\n\t\t\n\t\t<button class=\"awf-access js-masthead-trays-loop-to-first\" aria-hidden=\"true\">Loop to first</button>\n\t</div>\n</div>\n";

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = MastheadTrayButtonItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		Parent = awf.ui.Button;

	awf.util.use(Parent).toCreate(MastheadTrayButtonItem);


	/*	Constructor
	------------------------------------------*/
		// todo: Add unit test -- entire Class
		function MastheadTrayButtonItem (params) {

			var self = this;

			params = params || {};

			this._default_parent = function () {
		        if (this.collection) {
		            return this.collection.$el;
		        }
		        return null;
		    };

			awf.util.mixin.collectionItem(this, params);

			Parent.apply(this, arguments);
		}


	/*	Prototype Methods
	------------------------------------------*/
		_.extend(MastheadTrayButtonItem.prototype, {

			//

		});


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Message;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(148);

	use(BaseUI).toCreate(Message);

	/**
	 * Creates a new message UI component for error, warning, information, and success messages.
	 * @type {Message}
	 * @class
	 * @implements {Message}
	 * @memberOf awf.ui
	 *
	 * @param {object} [params]
	 * @param {null|string} [params.type] The type of message. Must be null, "error", "warn", "info", or "success".
	 * @param {null|string} [params.icon] The icon's CSS classname.
	 * @param {null|string} [params.message] The message.
	 * @param {boolean} [params.show_dismiss] true or false, hide or show the dismiss icon.
	 *
	 * @property {string} template The HTML template for the message.
	 * @property {null|string} type=null The type of message.
	 * @property {null|string} icon=null The message icon's classname.
	 * @property {null|string} message=null The message.
	 * @property {show_dismiss} show_dismiss=false The dismiss button's hidden state. If true, the button is hidden, if false, it is not hidden.
	 * @property {object} _$icon A jQuery reference to the icon element.
	 * @property {object} _$message A jQuery reference to the message element.
	 * @property {object} _$dismiss A jQuery reference to the dismiss button element.
	 */
	function Message (params) {
		params = params || {};
		params.template = params.template || this.template || template;

		this.timeout = null;

		BaseUI.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Sets the type of message for the component and updates this.type.
			 * @memberof awf.ui.Message
			 *
			 * @name setType
			 * @function
			 * @instance
			 *
			 * @param {null|string} val The type of message
			 * @return {Object} this chainable
			 *
			 * @fires this#change:type
			 */
			type: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					this.$el
						.removeAttr('class')
						.attr('class', 'awf-message');

					if (val)
						this.$el.addClass(val);
				}
			},

			/**
			 * Sets the icon for the message component and updates this.icon.
			 * @memberof awf.ui.Message
			 *
			 * @name setIcon
			 * @function
			 * @instance
			 *
			 * @param {null|string} val The icon CSS classname
			 * @return {Object} this chainable
			 *
			 * @fires this#change:icon
			 */
			icon: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					this._$icon
						.removeAttr('class')
						.attr('class', 'js-message-icon awf-message__icon');

					if (val)
						this._$icon.addClass(val);
				}
			},

			/**
			 * Sets the message text for the component and updates this.message.
			 * @memberof awf.ui.Message
			 *
			 * @name setMessage
			 * @function
			 * @instance
			 *
			 * @param {null|string} val The message
			 * @return {Object} this chainable
			 *
			 * @fires this#change:message
			 */
			message: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					this._$message.empty();

					if (val)
						this._$message.html(val);
				}
			},

			/**
			 * Hides/Unhides the dismiss button for the message and updates this.show_dismiss.
			 * @memberof awf.ui.Message
			 *
			 * @name setShowDismiss
			 * @function
			 * @instance
			 *
			 * @param {boolean} val The dismiss button's hidden state. True = hidden, false = visible.
			 * @return {Object} this chainable
			 *
			 * @fires this#change:show_dismiss
			 */
			show_dismiss: {
				default: true,
				types: ['boolean'],
				renderHandler: function (val) {
					if (val)
						this._$dismiss.show();
					else
						this._$dismiss.hide();
				}
			}

		});
	}


	BaseUI.generateDomProperties(Message, {
		icon: '.js-message-icon',
		message: '.js-message-message',
		dismiss: '.js-message-dismiss'
	});


	_.extend(Message.prototype, {

		/**
		 * Renders the Message component, adds a click/keypress event to the dismiss button, and calls this._show().
		 * @memberof awf.ui.Message
		 * @instance
		 *
		 * @return {Object} this chainable
		 *
		 * @fires this#dismiss on dismiss button click or enter-key keypress
		 */
		render: function () {
			var self = this;

			BaseUI.prototype.render.apply(self, arguments);

			self._$dismiss
				.on('click keypress', function (e) {
					if (e.type == 'click' || e.keyCode == awf.util.keyCodes.enter)
						self.triggerHandler('dismiss');
				});

			self._show();

			return self;
		},


		/**
		 * Shows the message with a slide-down effect. A promise is returned when the animation is finished.
		 * @memberOf awf.ui.Message
		 * @instance
		 *
		 * @return {$.Deferred} A jquery deferred object promise.
		 */
		_show: function () {
			var dfr = $.Deferred();

			this.$el
				.slideDown('fast', function () {
					dfr.resolve('message shown');
				});

			return dfr;
		},


		/**
		 * Hides the message with a slide-up effect. A promise is returned when the animation is finished.
		 * @memberOf awf.ui.Message
		 * @instance
		 *
		 * @return {$.Deferred} A jquery deferred object promise.
		 */
		hide: function () {
			var self = this,
				dfr = $.Deferred();

			clearTimeout(this.timeout);

			self.$el.slideUp('fast', function () {
				self.destroy();
				dfr.resolve('message hidden');
			});

			return dfr;
		},

		/**
		 * Will call this.hide() for a rendered message after a delayed amount of time.
		 * @memberOf awf.ui.Message
		 * @instance
		 *
		 * @param  {number} seconds The number of seconds to delay before hiding the message.
		 *
		 * @return {null|object} if soft error, returns null, otherwise returns this
		 */
		andDismissIn: function (seconds) {
			var self = this;

			if ( arguments.length === 0 || typeof seconds != 'number' || this.$el === null)
				return null;

			this.timeout = setTimeout(function () {
				self.hide();
			}, Math.round(seconds * 1000));

			return self;
		}

	});


/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-message\" role=\"alert\">\n\t<div class=\"awf-message-flex\">\n\t\t<span class=\"js-message-icon awf-message__icon\"></span>\n\t\t<span class=\"js-message-message awf-message__message\"></span>\n\t\t<button class=\"js-message-dismiss awf-message__dismiss awficon-search-clear -awf-focus -color-alt\" title=\"Dismiss\"><span class=\"awf-access\">Dismiss/Close</span></button>\n\t</div>\n</div>\n";

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Modal;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(150);

	use(BaseUI).toCreate(Modal);

	/**
	 * @type {Modal}
	 * @class
	 * @implements {Modal}
	 * @memberOf awf.ui
	 *
	 * @property {null|string} label The dialog window's arial label
	 * @property {boolean} active_state The dialog window's active state
	 * @property {null|number|string} width The container's width
	 * @property {null|number|string} height The container's height
	 * @property {object} _$modal_container A jQuery reference to the modal container
	 * @property {object} _$loop_last A jQuery reference to a helper
	 * element that when focused sets focus on the last tabbable
	 * element in this._$modal_container
	 * @property {object} _$loop_first A jQuery reference to a helper
	 * element that when focused sets focus on the first tabbable
	 * element in this._$modal_container
	 *
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var modal = new awf.ui.Modal();
	 *
	 */
	function Modal (params) {
		console.group("Constructing Modal");
		params = params || {};
		params.template = params.template || this.template || template;

		awf.util.mixin.properties(this, params, {

			/**
			 * Sets this._$modal_container HTML to passed value
			 * @memberof awf.ui.Modal
			 * @function
			 *
			 * @param {null|string|object} val HTML string or jQuery object
			 * @return {Object} self chainable
			 *
			 * @fires this#change:content passing old and new values
			 */
			content: {
				default: null,
				types: ["null","string","object"],
				renderHandler: function(val) {
					this._$modal_container.html(val);
				}
			},

			/**
			 * Sets the aria label for the entire modal window
			 * @memberOf awf.ui.Modal
			 *
			 * @name  setLabel
			 * @function
			 *
			 * @param {null|string} [val="Dialog Window"] The dialog window's aria label to set
			 * @return {object} self (chainable)
			 *
			 * @fires this#change:label passing old and new values
			 */
			label: {
				default: "Dialog Window",
				types: ["null","string"],
				renderHandler: function (val) {
					val = val || "Dialog Window";
					this._$label.html(val);
				}
			},

			/**
			 * Sets the active state of the component and updates the DOM
			 * appropriately in order to show/hide the modal window. When active,
			 * this#request-close is an event that can be listened to for taking
			 * appropriate action when the user is requesting to close the modal window.
			 *
			 * this#request-close is triggered on pressing the `esc` key or clicking
			 * outside of this._$modal_container.
			 *
			 * @memberof awf.ui.Modal
			 *
			 * @name setActiveState
			 * @function
			 *
			 * @param {boolean} val true to set active, false to set inactive
			 * @return {Object} self chainable
			 *
			 * @fires this#change:active_state passing old and new values
			 */
			active_state: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {
					var self = this;

					if (val) {

						$('body')
							.addClass('-modal-active')
							.off('keyup.modal')
							.on('keyup.modal', function (e) {
								if (e.keyCode == awf.util.keyCodes.esc)
									self.triggerHandler('request-close');
							});

						self.$el
							.attr('aria-hidden', 'false')
							.removeAttr('style')
							.siblings()
							.attr('aria-hidden', 'true');

						// fail-safe for animations
						setTimeout(function () {
							self._$modal_container.find(':tabbable').first().focus();
						}, 10);

					} else {

						$('body')
							.removeClass('-modal-active')
							.off('keyup.modal');

						self.$el
							.attr('aria-hidden', 'true')
							.siblings()
							.attr('aria-hidden', 'false');

						self
							.setContent(null)
							.setWidth(null)
							.setHeight(null);

					}
				}
			},

			/**
			 * Sets the width of this._$modal_container
			 * @memberof awf.ui.Modal
			 *
			 * @name setWidth
			 * @function
			 *
			 * @param {null|number|string} val the new width to set
			 * @return {Object} self chainable
			 *
			 * @fires this#change:width passing old and new values
			 */
			width: {
				default: null,
				types: ['null','number','string'],
				renderHandler: function (val) {
					if (val) {
						val = isNaN(val) ? val : val + 'px';
						this._$modal_container.css('width', val);
					} else {
						this._$modal_container.removeStyle('width');
					}
				}
			},

			/**
			 * Sets the height of this._$modal_container
			 * @memberof awf.ui.Modal
			 *
			 * @name setHeight
			 * @function
			 *
			 * @param {null|number|string} val the new width to set
			 * @return {Object} self chainable
			 *
			 * @fires this#change:height passing old and new values
			 */
			height: {
				default: null,
				types: ['null','number'],
				renderHandler: function (val) {
					if (val) {
						val = isNaN(val) ? val : val + 'px';
						this._$modal_container.css('height', val);
					} else {
						this._$modal_container.removeStyle('height');
					}
				}
			}

		});

		BaseUI.call(this, params);

		console.groupEnd();
	}


	BaseUI.generateDomProperties(Modal, {
		modal_container: '.js-modal-inner',
		loop_last: '.js-modal-loop-to-last',
		loop_first: '.js-modal-loop-to-first',
		label: '.js-dialog-label'
	});


	_.extend(Modal.prototype, {

		/**
		 * Renders the Modal component. Listens to click events for
		 * this.$el in order to determine whether or not the
		 * 'request-close' event should be triggered, and adds
		 * a tabloop for the contents of this._$modal_container.
		 * @memberof awf.ui.Modal
		 *
		 * @return {Object} self chainable
		 */
		render: function() {
			var self = this;

			BaseUI.prototype.render.apply(self, arguments);

			/**
			 * Fires event if the click event's target is this.$el
			 * specifically, (not any of its child elements).
			 * @type {Object}
			 * @name $el.on
			 * @function
			 * @memberof awf.ui.Modal
			 * @listens this.$el#click
			 * @fires this#request-close
			 */
			self.$el.on('click', function (e) {
				if(self.$el.is(e.target))
					self.triggerHandler('request-close');
			});

			//Create tabloop
			/**
			 * Sets focus on last tabbable element in this._$modal_container
			 * @type {Object}
			 * @name _$loop_last.on
			 * @function
			 * @memberof awf.ui.Modal
			 * @listens this._$loop_last#focus
			 */
			self._$loop_last.on('focus', function () {
				self._$modal_container.find(':tabbable').last().focus();
			});

			/**
			 * Sets focus on first tabbable element in this._$modal_container
			 * @type {Object}
			 * @name _$loop_first.on
			 * @function
			 * @memberof awf.ui.Modal
			 * @listens this._$loop_first#focus
			 */
			self._$loop_first.on('focus', function () {
				self._$modal_container.find(':tabbable').first().focus();
			});

			return self;
		}

	});


/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-modal\" role=\"dialog\" aria-hidden=\"true\" aria-labelledby=\"dialog-label\">\n\t<label id=\"dialog-label\" class=\"js-dialog-label awf-access\"></label>\n\t<button class=\"awf-access js-modal-loop-to-last\" aria-hidden=\"true\">Loop to last</button>\n\t<div class=\"js-modal-inner awf-modal__inner\"></div>\n\t<button class=\"awf-access js-modal-loop-to-first\" aria-hidden=\"true\">Loop to first</button>\n</div>\n";

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Search;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(152);

	use(BaseUI).toCreate(Search);

	/**
	 * Search UI Component. A simple input and submit form that fires events.
	 * @type {Search}
	 * @implements {Search}
	 * @memberOf awf.ui
	 *
	 * @param {object} params
	 * @param {string} params.label Optional: The search's label and placeholder text. The value is 'Search' by default.
	 *
	 * @property {string|null} label The search label & placeholder text
	 * @property {string|null} term The input's current value
	 * @property {boolean} active_state The search's current active state
	 * @property {object} _$access_label A jQuery reference to the accessible label
	 * @property {object} _$input A jQuery reference to the input
	 * @property {object} _$submit A jQuery reference to the submit button
	 * @property {object} _$clear A jQuery reference to the clear button
	 *
	 * @class
	 * @augments {BaseUI}
	 * @requires jQuery
	 */
	function Search (params) {
		params = params || {};
		params.template = params.template || this.template || template;

		BaseUI.call(this, params);

		this.children.stylesheet = new awf.ui.Stylesheet();

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates the input's placeholder text as well as
			 * accessible attributes with passed value.
			 * @memberof awf.ui.Search
			 * @name setLabel
			 * @function
			 *
			 * @param {string|null} val The label to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:label passing old and new values
			 */
			label: {
				default: "Search",
				types: ['string','null'],
				renderHandler: function (val) {
					if ( ! val)
						val = "Search";

					this._$access_label.html(val);
					this._$input.attr('placeholder',val);
					this._$submit
						.attr({
							alt : val,
							title : val
						})
						.find('.awf-access').html(val);
				}
			},


			/**
			 * In addition to storing the input value in this.term, the
			 * method will call this.showClear() if passed value's length
			 * is greater than 1, otherwise, it will call this.hideClear().
			 * @memberof awf.ui.Search
			 * @name setTerm
			 * @function
			 * @private
			 *
			 * @param {string|null} val The term to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:term passing old and new values
			 */
			term: {
				default: null,
				types: ['string','null'],
				handler: function (val) {
					val = val || "";
					this[val.length > 0 ? 'showClear' : 'hideClear']();
				}
			},


			/**
			 * When passed true, the method will add a class, '-search-is-active',
			 * to the body element. When passed false, the method will remove the
			 * class in addition to removing the class, '-search-mobile-is-active',
			 * from the body element, if present.
			 * @memberof awf.ui.Search
			 * @name setActiveState
			 * @function
			 *
			 * @param {boolean} val True to set active; False to set inactive
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:active_state passing old and new values
			 */
			active_state: {
				default: false,
				types: ['boolean'],
				handler: function (val) {
					$('body')[val ? 'addClass' : 'removeClass']('-search-is-active');
					if (val === false)
						$('body').removeClass('-search-mobile-is-active');
				}
			}

		});
	}


	BaseUI.generateDomProperties(Search, {
		access_label : '.js-access-label',
		input : '.js-search-input',
		submit : '.js-search-submit',
		clear : '.js-search-clear'
	});


	_.extend(Search.prototype, {

		/**
		 * Renders the UI component and calls this._bindEvents()
		 * @memberOf awf.ui.Search
		 * @return {object} this (chainable)
		 */
		render: function () {
			BaseUI.prototype.render.call(this);

			this._bindEvents();

			return this;
		},


		/**
		 * This method will attach event handlers to various elments.<br><br>
		 * <strong>this.$el</strong><br>
		 * on "submit" fires this#submit and passes this.getValue()<br>
		 * on "keydown" fires this#keydown:esc when escape key is pressed<br>
		 * on "keydown" fires this#keydown:tab when tab key is pressed<br>
		 * on "keydown" fires this#keydown:left when left key is pressed<br>
		 * on "keydown" fires this#keydown:up when up key is pressed<br>
		 * on "keydown" fires this#keydown:right when right key is pressed<br>
		 * on "keydown" fires this#keydown:down when down key is pressed<br>
		 * on "keyup" fires this#keyup:esc when escape key is pressed<br>
		 * on "keyup" fires this#keyup:tab when tab key is pressed<br>
		 * on "keyup" fires this#keyup:left when left key is pressed<br>
		 * on "keyup" fires this#keyup:up when up key is pressed<br>
		 * on "keyup" fires this#keyup:right when right key is pressed<br>
		 * on "keyup" fires this#keyup:down when down key is pressed<br><br>
		 * <strong>this._$clear</strong><br>
		 * on "click" fires this#click:clear<br><br>
		 * <strong>this._$submit</strong><br>
		 * on "click" fires this#click:submit<br><br>
		 *
		 * @memberOf awf.ui.Search
		 * @private
		 * @return {object} this (chainable)
		 */
		_bindEvents: function () {
			var self = this,
				key_code_map = {
					27 : "esc",
					37 : "left",
					38 : "up",
					39 : "right",
					40 : "down",
					9  : "tab"
				};

			// the form
			self.$el
				.off('focusin focusout submit keydown keyup')
				.on('submit', function (ev) {
					ev.preventDefault();
					self.triggerHandler("submit", [self.getValue()]);
				})
				.on('keydown', function (ev) {
					var kc = ev.keyCode;

					if (key_code_map[kc])
						self.triggerHandler("keydown:" + key_code_map[kc], { ev:ev });
				})
				.on('keyup', function (ev) {
					var kc = ev.keyCode;

					if (key_code_map[kc])
						self.triggerHandler("keyup:" + key_code_map[kc], { ev:ev });

					if (key_code_map[kc] == "esc") {
						if (self.getValue() === "") {
							self._$input.blur();
						} else {
							self._$input.val("").focus();
							self.setTerm(null);
						}
					} else {
						self.setTerm(self.getValue());
					}
				})
				.on('focusin', function () {
					self.setActiveState(true);
				})
				.on('focusout', function () {
					if (self.getValue().length === 0)
						self.setActiveState(false);
				});

			// reset button
			self._$clear
				.off('click')
				.on('click', function (ev) {
					self.triggerHandler("click:clear");
					self.setTerm(null);
					self._$input.focus();
				});

			// submit button
			self._$submit
				.off('click')
				.on('click', function (ev) {
					self.triggerHandler("click:submit", [self.term]);
				});

			return self;
		},


		/**
		 * @memberOf awf.ui.Search
		 * @return {string} the search input's value
		 */
		getValue: function () {
			return this._$input.val();
		},


		/**
		 * Sets the input value and triggers this#change:term
		 * @memberof awf.ui.Search
		 * @function
		 *
		 * @param {string|null} val The term to set
		 * @return {object} this (chainable)
		 *
		 * @fires this#change:term passing old and new values
		 */
		setValue: function (val) {
			val = val || "";

			this._$input.val(val);
			this.setTerm(val);

			return this;
		},


		/**
		 * Removes the class, '-is-active', from the clear button element
		 * and sets the tabindex attribute to '-1'
		 * @memberOf awf.ui.Search
		 * @return {object} this (chainable)
		 */
		hideClear: function () {
			this._$clear
				.removeClass("-is-active")
				.attr("tabindex","-1");
			return this;
		},


		/**
		 * Adds the class, '-is-active', to the clear button element
		 * and sets the tabindex attribute to '0'
		 * @memberOf awf.ui.Search
		 * @return {object} this (chainable)
		 */
		showClear: function () {
			this._$clear
				.addClass("-is-active")
				.attr("tabindex","0");
			return this;
		},


		/**
		 * Returns true if the input is currently focused, otherwise it
		 * returns false.
		 * @memberOf awf.ui.Search
		 * @return {boolean}
		 */
		isFocused: function () {
			return this._$input.is(":focus");
		}

	});


/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "<form class=\"awf-search\" action=\"javascript:;\" role=\"search\" aria-label=\"Rapid Search Form\">\n\t<div class=\"awf-search__wrap\">\n\t\t<label for=\"awf-search-input\" class=\"js-access-label awf-access\"></label>\n\t\t<input type=\"search\" id=\"awf-search-input\" class=\"js-search-input awf-search__input -awf-focus -border-color-link\" autocomplete=\"off\" />\n\t\t<button type=\"reset\" class=\"js-search-clear awf-search__clear awficon-search-clear -color-alt\" tabindex=\"-1\"><span class=\"awf-access\">Clear</span></button>\n\t\t<button type=\"submit\" class=\"js-search-submit awf-search__submit awficon-search1 -awf-link -text-decoration-none\"><span class=\"awf-access\"></span></button>\n\t</div>\n</form>\n";

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = BucketItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.CollectionItem,
		template = __webpack_require__(154),
		BaseUI = awf.ui.Base;

	use(Parent).toCreate(BucketItem);

	/**
	 * Search results BucketItem UI Component.
	 * @type {BucketItem}
	 * @implements {BucketItem}
	 * @memberOf awf.ui
	 * @private
	 *
	 * @class
	 * @augments {awf.ui.CollectionItem}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param {string} url The result item's url to set
	 * @param {string} title The result item's title to set
	 * @param {string|object} description The result item's description to set as an HTML string or jQuery object
	 * @param {string|object} image The result item's image to set as an HTML string or jQuery object
	 *
	 * @property {string} url The result item's url
	 * @property {string} title The result item's title
	 * @property {string|object} description The result item's description (an HTML string or jQuery object)
	 * @property {string|object} image The result item's image (an HTML string or jQuery object)
	 */
	function BucketItem (params) {
		params = params || {};

		this.template = params.template || this.template || template;

		this._default_parent = function () {
	        if (this.collection) {
	            return this.collection._$items;
	        }
	        return null;
	    };

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates the result image
			 * @memberof awf.ui.BucketItem
			 * @name setImage
			 * @function
			 *
			 * @param {string|null|object} val The image to set as an HTML string or jQuery object
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:image passing old and new values
			 */
			image: {
				default: null,
				types: ['string','null','object'],
				renderHandler: function (val) {
					this._$image.html(val);
				}
			},

			/**
			 * Updates the result title
			 * @memberof awf.ui.BucketItem
			 * @name setTitle
			 * @function
			 *
			 * @param {string|null} val The title to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:title passing old and new values
			 */
			title: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					this._$title.html(val);
				}
			},

			/**
			 * Updates the result description
			 * @memberof awf.ui.BucketItem
			 * @name setDescription
			 * @function
			 *
			 * @param {string|null|object} val The description to set as an HTML string or jQuery object
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:description passing old and new values
			 */
			description: {
				default: null,
				types: ['string','null','object'],
				renderHandler: function (val) {
					this._$description.html(val);
				}
			},

			/**
			 * Updates the result url
			 * @memberof awf.ui.BucketItem
			 * @name setUrl
			 * @function
			 *
			 * @param {string|null} val The url to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:url passing old and new values
			 */
			url: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					if (val) {
						this.$el.attr({
							"onclick" : "window.open('" + val + "'); return false;",
							"onkeypress" : "if (event.keyCode == awf.util.keyCodes.enter) { window.open('" + val + "'); } else { return true; }"
						});
					} else {
						this.$el
							.removeAttr("onclick")
							.removeAttr("onkeypress");
					}
				}
			}

		});

		Parent.apply(this, arguments);
	}


	BaseUI.generateDomProperties(BucketItem, {
		image : '.js-bucket-item-image',
		title : '.js-bucket-item-title',
		description : '.js-bucket-item-description',
		tooltip : '.js-bucket-item-tooltip'
	});


	_.extend(BucketItem.prototype, {

		/**
		 * Renders the UI component, sets up aria labelling, and calls this._bindEvents()
		 * @memberOf awf.ui.BucketItem
		 * @return {object} this (chainable)
		 */
		render: function () {
			Parent.prototype.render.call(this);

			this.aria_id = awf.util.randomID();

			this._$title.attr('id',this.aria_id);
			this.$el.attr('aria-labelledby',this.aria_id);
			this._bindEvents();

			return this;
		},


		/**
		 * This method will attach event handlers to various elments.<br><br>
		 * <strong>this.$el</strong><br>
		 * on "mouseenter" fires this#hover-start if hovered for at least 500ms<br>
		 * on "focus" fires this#hover-start if focused for at least 500ms<br>
		 * on "mouseleave" fires this#hover-end<br>
		 * on "focusout" fires this#hover-end
		 * on "click" fires this#results:click
		 * on "keypress" fires this#result:click if 'enter' key
		 *
		 * @memberOf awf.ui.BucketItem
		 * @private
		 * @return {object} this (chainable)
		 */
		_bindEvents: function () {
			var self = this,
				hover_timeout = null;

			self.$el
				.off('mouseenter.internal focus.internal mouseleave.internal focusout.internal keypress.internal click.internal')
				.on("mouseenter.internal focus.internal", function (ev) {
					hover_timeout = setTimeout(function () {
						self.triggerHandler("hover-start");
					}, 500);
				})
				.on("mouseleave.internal focusout.internal", function(ev) {
					setTimeout( function() {
						var $active = $(document.activeElement);
						if( ! (ev.type == "focusout" && (self.$el.is($active) || self.$el.has($active).length))) {
							clearTimeout(hover_timeout);
							self.triggerHandler("hover-end");
						}
					}, 10);
				})
				.on("click.internal", function (ev) {
					self.triggerHandler("result:click");
				})
				.on("keypress.internal", function (ev) {
					if (ev.keyCode == awf.util.keyCodes.enter)
						self.triggerHandler("result:click");
				});

			self._$tooltip
				.off('click.internal')
				.on("click.internal", function (ev) {
					ev.stopImmediatePropagation();
				});

			self.$el.find('a, button, input')
				.off('click.internal keypress.internal')
				.on('click.internal', function (ev) {
					ev.stopImmediatePropagation();
				})
				.on('keypress.internal', function (ev) {
					if (ev.keyCode == awf.util.keyCodes.enter)
						ev.stopImmediatePropagation();
				});

			return self;
		}

	});


/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = "<li tabindex=\"0\" class=\"js-bucket-item awf-bucket-item\" role=\"listitem\">\n\t<div class=\"js-bucket-item-image awf-bucket-item__image\"></div>\n\t<div class=\"js-bucket-item-title awf-bucket-item__title\"></div>\n\t<div class=\"js-bucket-item-description awf-bucket-item__description -color-alt\"></div>\n\t<div class=\"js-bucket-item-tooltip awf-bucket-item__tooltip -background-base\"></div>\n</li>\n";

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Bucket;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Collection,
		template = __webpack_require__(156),
		BaseUI = awf.ui.Base;

	use(Parent).toCreate(Bucket);

	/**
	 * Search results Bucket UI Component.
	 * @type {Bucket}
	 * @implements {Bucket}
	 * @memberOf awf.ui
	 * @private
	 *
	 * @class
	 * @augments {awf.ui.Collection}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param {object} params
	 * @param {string} label The label to set
	 *
	 * @property {string|null} label The bucket label
	 * @property {object} _$label A jQuery reference to the bucket's label container
	 * @property {object} _$items A jQuery reference to the bucket's items container
	 */
	function Bucket (params) {
		params = params || {};
		this.template = params.template || this.template || template;

		this._default_parent = function () {
	        if (this.collection) {
	            return this.collection._$buckets;
	        }
	        return null;
	    };

	    awf.util.mixin.collectionItem(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates the label
			 * @memberof awf.ui.Bucket
			 * @name setLabel
			 * @function
			 *
			 * @param {string|null} val The label to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:label passing old and new values
			 */
			label: {
				default: null,
				types: ['string','null'],
				renderHandler: function (val) {
					this._$label.html(val);
				}
			},


			/**
			 * Updates this.classname and updates this._$items `class` attribute.
			 * @memberof awf.ui.Bucket
			 * @name setClassname
			 * @function
			 *
			 * @param {string|null} val=null The id to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:id passing old and new values
			 */
			classname: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val, old_val) {
					if (old_val) {
						this._$items.removeClass(old_val);
					}
					if (val) {
						this._$items.addClass(val);
					}
				}
			}

		});

		Parent.apply(this, arguments);
	}


	BaseUI.generateDomProperties(Bucket, {
		label : '.js-bucket-label',
		items : '.js-bucket-items'
	});


	_.extend(Bucket.prototype, {
		Item: awf.ui.BucketItem,

		/**
		 * Removes all current bucket results, and adds an item for each bucket result passed to it.
		 * @memberof awf.ui.Bucket
		 *
		 * @param {array} results the results to render
		 * @param {string} results[n].title The result's title text
		 * @param {string|object} results[n].description The result's short description as an HTML string or jQuery object
		 * @param {object|string} results[n].image The result's image as an HTML string or jQuery object
		 * @param {string} results[n].url The result's url
		 *
		 * @return {Object} this (chainable)
		 */
		renderResults: function (results) {
			if (results) {
				var self = this;

				self.removeAllItems();

				_.forEach(results, function(result) {
					self.addItem(result);
				});
			}

			return this;
		}
	});


/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-bucket\">\n\t<h2 class=\"js-bucket-label awf-bucket__label -border-color-base\"></h2>\n\t<ul class=\"js-bucket-items awf-bucket__items\" role=\"list\"></ul>\n</div>\n";

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Results;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Parent = awf.ui.Collection,
		template = __webpack_require__(158),
		BaseUI = awf.ui.Base;

	use(Parent).toCreate(Results);

	/**
	 * Search Results UI Component.
	 * @type {Results}
	 * @implements {Results}
	 * @memberOf awf.ui
	 * @private
	 *
	 * @class
	 * @augments {awf.ui.Collection}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param {object} params
	 * @param {string} params.footer The footer text to set
	 *
	 * @property {string|null} footer The footer text
	 * @property {boolean} active_state The active state of the results
	 * @property {object} _$buckets A jQuery reference to the buckets container
	 * @property {object} _$footer A jQuery reference to the footer container
	 */
	function Results (params) {
		var self = this;
		params = params || {};
		this.template = params.template || this.template || template;

		this.aria_id = awf.util.randomID();

		Parent.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Updates the footer text
			 * @memberof awf.ui.Results
			 * @name setFooter
			 * @function
			 *
			 * @param {string|null} val The footer text to set
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:footer passing old and new values
			 */
			footer: {
				default: "Press Enter to see all search results.",
				types: ['string','null'],
				renderHandler: function (val) {
					this._$footer.html(val);
				}
			},

			/**
			 * Updates the results active state. Adds '-is-active' class to this.$el,
			 * when passed true. Removes '-is-active' class from this.$el when passed false.
			 * @memberof awf.ui.Results
			 * @name setActiveState
			 * @function
			 *
			 * @param {boolean} val The results active state
			 * @return {object} this (chainable)
			 *
			 * @fires this#change:active_state passing old and new values
			 */
			active_state: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {
					this.$el[val ? "addClass" : "removeClass"]('-is-active');
				}
			}

		});
	}


	BaseUI.generateDomProperties(Results, {
		buckets : '.js-results-wrap',
		footer : '.js-results-footer'
	});


	_.extend(Results.prototype, {

		Item: awf.ui.Bucket,

		/**
		 * Renders the UI component and calls this._bindEvents()
		 * @memberOf awf.ui.Results
		 * @return {object} this (chainable)
		 */
		render: function () {
			Parent.prototype.render.call(this);

			this.setId(this.aria_id);
			this._bindEvents();

			return this;
		},


		/**
		 * This method will attach event handlers to various elments.<br><br>
		 * <strong>this.$el</strong><br>
		 * on "keyup" fires this#results:esc when escape key is pressed
		 *
		 * @memberOf awf.ui.Results
		 * @private
		 * @return {object} this (chainable)
		 */
		_bindEvents: function () {
			var self = this;

			self.$el
				.off('keyup.internal')
				.on('keyup.internal', function (ev) {
					if (ev.keyCode == awf.util.keyCodes.esc) {
						self.triggerHandler('results:esc');
					}
				})
				.on('keydown.internal', function (ev) {
					if (ev.keyCode == awf.util.keyCodes.up) {
						self.triggerHandler('results:up', { ev:ev });
					}
					if (ev.keyCode == awf.util.keyCodes.down) {
						self.triggerHandler('results:down', { ev:ev });
					}
				});

			return self;
		},


		/**
		 * Removes all collection items, and adds items for each bucket passed to it.
		 * @memberof awf.ui.Results
		 *
		 * @param {array} buckets the buckets to render
		 * @param {object} buckets[n].label The bucket label
		 *
		 * @return {Object} this (chainable)
		 */
		renderBuckets: function (buckets) {
			if (buckets) {
				var self = this;

				self.removeAllItems();

				_.forEach(buckets, function(bucket) {
					self.addItem(bucket);
				});
			}

			return this;
		}

	});


/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-results -border-color-base -background-base\" role=\"region\" aria-label=\"Search Results\">\n\t<div class=\"js-results-wrap awf-results__wrap\"></div>\n\t<div class=\"js-results-footer awf-results__footer -awf-focus -border-color-base\"></div>\n</div>\n";

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Settings;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(160);


	use(BaseUI).toCreate(Settings);

	/**
	 * Settings UI Component
	 * @type {Settings}
	 * @implements {Settings}
	 * @memberOf awf.ui
	 *
	 * @class
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param {Object} params
	 * @param {string} params.label aria-label attribute value
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var settings = new awf.ui.Settings({
	 *    label: 'Site Settings'
	 *  });
	 *
	 */
	function Settings (params) {
		// todo: Add uni test -- fill in the gaps :/
		console.group("Constructing Settings");
		console.log("params :",params);

		if (params === true || params === undefined)
			params = {};
		params.template = params.template || this.template || template;

		this.label = params.label || '';

		BaseUI.call(this, params);

		if (params.theme_switcher) {
			awf.page.children.masthead.children.trays.one('showing.settings', function () {
				var theme_switcher_params = params.theme_switcher;

				this.theme_switcher = new awf.ui.ThemeSwitcher({
					themes: awf.page.themes.items
				});
			});
		}

		console.groupEnd();
	}


	_.extend(Settings.prototype, {

		render: function () {
			var self = this;

			BaseUI.prototype.render.apply(self, arguments);

			if(self.label)
				self.setAriaLabel(self.label);

			return self;
		},

		/**
		 * Pass in an aria label for the settings component
		 * @memberof awf.ui.Settings
		 * @param  {String} value aria-label attribute value
		 * @return {Object} self chainable
		 */
		setAriaLabel: function (value) {
			this.$el.attr('aria-label',value);
			return this;
		}

	});


/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<div role=\"region\" class=\"settings\" aria-label=\"\">\n</div>\n";

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	//TODO: Metrics tagging?
	module.exports = Sitelinks;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(162);

	use(BaseUI).toCreate(Sitelinks);

	/**
	 * Sitelinks UI Component
	 * @type {Sitelinks}
	 * @implements {Sitelinks}
	 * @memberOf awf.ui
	 *
	 * @class
	 * @augments {awf.ui.Base}
	 *
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @param  {Object} params
	 * @param {string} params.label Optional aria-label attribute value
	 * @param {array} params.json Optional json data for the sitelinks
	 *
	 * @property {string} label - aria-label attribute value ('' by default)
	 * @property {array} json - json data for the sitelinks (null by default)
	 * @property {object} _$tabs - jQuery object for tabs container
	 * @property {object} _$panels - jQuery object for panels container
	 * @property {object} _$dropdown_close - jQuery object for dropdown close button
	 * @property {string} _tab - tab template
	 * @property {string} _panel - panel template
	 * @property {string} _link - link template
	 * @property {string} _ul - ul template
	 * @property {string} _h2 - heading template
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var sitelinks = new awf.ui.Sitelinks({
	 *    label: 'Sitelinks',
	 *    json: [
	 *      {
	 *        "tab": "Tab 1 Title",
	 *        "panel": [
	 *          {
	 *            "heading": "An optional heading",
	 *            "links": [
	 *              {
	 *                "text": "Link 1 Text",
	 *                "url": "http://www.google.com"
	 *              },
	 *              {
	 *                "text": "Link 2 Text",
	 *                "url": "http://www.facebook.com"
	 *              }
	 *            ]
	 *          }
	 *        ]
	 *      },
	 *      {
	 *        "tab": "Tab 2 Title",
	 *        "panel": [
	 *          {
	 *            "heading": "",
	 *            "links": [
	 *              {
	 *                "text": "Link 3 Text",
	 *                "url": "http://www.msn.com"
	 *              },
	 *              {
	 *                "text": "Link 4 Text",
	 *                "url": "http://www.yahoo.com"
	 *              }
	 *            ]
	 *          }
	 *        ]
	 *      }
	 *    ]
	 *  });
	 */
	function Sitelinks (params) {
		var self = this;

		if (params === true || params === undefined)
			params = {};
		params.template = params.template || this.template || template;

		this.label = params.label || '';
		this.json = params.json || null;

		BaseUI.call(this, params);
	}

	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Sitelinks, {
			tabs: '.js-sitelinks-tabs',
			panels: '.js-sitelinks-panels'
		});

	_.extend(Sitelinks.prototype, {
		_tab: '<li class="sitelinks__tablist__tab -awf-link-inverted"></li>',
		_panel: '<div class="sitelinks__panel"></div>',
		_h2: '<h2 class="sitelinks__panel__heading"></h2>',
		_ul: '<ul class="sitelinks__panel__list"></ul>',
		_link: '<li class="sitelinks__panel__list__item"><a class="sitelinks__panel__list__item__a" href="javascript:;"></a></li>',

		render: function () {
			var self = this;

			BaseUI.prototype.render.apply(self, arguments);

			if (this.loading)
				return self;

			if (self.label)
				self.setAriaLabel(self.label);

			if (self.json)
				self.renderSiteLinks();

			return self;
		},

		/**
		 * Renders the sitelinks that have been set. A tablist of links will
		 * be created and fully accessible to keyboard and screenreader users.
		 * @memberof awf.ui.Sitelinks
		 * @return {Object} self chainable
		 */
		renderSiteLinks: function () {
			if (this.$el === null)
				return this;

			var self = this,
				first_tab = true;

			_.forEach(self.json, function(item) {
				createTab(item);
			});

			function createTab(item) {
				var $tab = $(self._tab),
					$panel = $(self._panel),
					tab_id = awf.util.randomID();
					panel_id = awf.util.randomID();

				$tab
					.attr({
						'id': tab_id,
						'aria-selected': 'false',
						'aria-controls': panel_id,
						'tabindex': '-1',
						'role': 'tab'
					})
					.html(item.tab);

				$panel
					.attr({
						'id': panel_id,
						'aria-labelledby': tab_id,
						'aria-hidden': "true",
						'role': 'tabpanel'
					});

				if (first_tab) {
					first_tab = false;
					$tab
						.addClass('-is-active')
						.attr({
						'aria-selected': 'true',
						'tabindex': '0'
					});
					$panel
						.addClass('-is-active')
						.attr('aria-hidden', "false");
				}

				self._$tabs.append($tab);
				createPanel(item.panel, $panel);
				self._$panels.append($panel);

				attachEvents($tab, $panel);
			}

			function createPanel(panel, $panel) {
				_.forEach(panel, function(item) {
					if (item.heading !== '')
						$(self._h2).html(item.heading).appendTo($panel);
					createLinks(item.links, $panel);
				});
			}

			function createLinks(links, $panel) {
				var $ul = $(self._ul);
				_.forEach(links, function(link) {
					$(self._link).find('a')
						.attr({
							'href': link.url,
							'target': link.target || '_blank'
						})
						.html(link.text)
						.parent()
						.appendTo($ul);
				});
				$panel.append($ul);
			}

			function attachEvents($tab, $section) {
				$tab
					.on('click', function(e) {
						$tab
							.addClass('-is-active')
							.attr({
								'aria-selected': 'true',
								'tabindex': '0'
							})
							.siblings()
							.removeClass('-is-active')
							.attr({
								'aria-selected': 'false',
								'tabindex': '-1'
							});
						$tab.focus();

						$section
							.addClass('-is-active')
							.attr('aria-hidden', "false")
							.siblings()
							.removeClass('-is-active')
							.attr('aria-hidden', "true");
					})
					.on('keydown', function(e){
						var tabIndex = $tab.index(),
							tabsLength = $tab.siblings().length;

						if (e.altKey || e.ctrlKey) {
							// do nothing
							return true;
						}

						switch (e.keyCode) {
							case awf.util.keyCodes.left:
							case awf.util.keyCodes.up: {
								if (tabIndex === 0) {
									// tab is the first one:
									// switch to last tab
									$tab.siblings().last().trigger('click');
								} else {
									// switch to previous tab
									$tab.prev().trigger('click');
								}

								e.stopPropagation();
								return false;
							}
							case awf.util.keyCodes.right:
							case awf.util.keyCodes.down: {
								if (tabIndex == tabsLength) {
									// tab is the last one:
									// switch to first tab
									$tab.siblings().first().trigger('click');
								}
								else {
									// switch to next tab
									$tab.next().trigger('click');
								}

								e.stopPropagation();
								return false;
							}
							case awf.util.keyCodes.home: {
								// switch to the first tab
								$tab.siblings().add($tab).first().trigger('click');

								e.stopPropagation();
								return false;
							}
							case awf.util.keyCodes.end: {
								// switch to the last tab
								$tab.siblings().add($tab).last().trigger('click');

								e.stopPropagation();
								return false;
							}
						}
					});
			}

			return self;
		},



		/**
		 * Pass in an array of links to use to build the sitelinks. renderSiteLinks() can be called at a later time to build a tablist from the passed array.
		 * @memberof awf.ui.Sitelinks
		 * @param  {Array} data the tablist of links for the sitelinks
		 * @return {Object} self chainable
		 *
		 * @example
		 *
		 * var sitelinks = new awf.ui.Sitelinks();
		 *
		 * sitelinks.setSiteLinks([
		 *  {
		 *    "tab": "Tab 1 Title",
		 *    "panel": [
		 *      {
		 *        "heading": "An optional heading",
		 *        "links": [
		 *          {
		 *            "text": "Link 1 Text",
		 *            "url": "http://www.google.com"
		 *          },
		 *          {
		 *            "text": "Link 2 Text",
		 *            "url": "http://www.facebook.com"
		 *          }
		 *        ]
		 *      }
		 *    ]
		 *  },
		 *  {
		 *    "tab": "Tab 2 Title",
		 *    "panel": [
		 *      {
		 *        "heading": "",
		 *        "links": [
		 *          {
		 *            "text": "Link 3 Text",
		 *            "url": "http://www.msn.com"
		 *          },
		 *          {
		 *            "text": "Link 4 Text",
		 *            "url": "http://www.yahoo.com"
		 *          }
		 *        ]
		 *      }
		 *    ]
		 *  }
		 * ]);
		 *
		 */
		setSiteLinks: function (data) {
			this.json = data;

			if (this.loading)
				this.loading = false;

			this.render();

			return this;
		},

		/**
		 * Pass in an aria label for the sitelinks component
		 * @memberof awf.ui.Sitelinks
		 * @param  {String} value the aria label
		 * @return {Object} self chainable
		 */
		setAriaLabel: function(value) {
			this.$el.attr('aria-label',value);
			return this;
		}
	});


/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = "<div role=\"navigation\" class=\"sitelinks\" aria-label=\"\" tabindex=\"-1\">\n\t<div class=\"sitelinks__tab-wrapper\">\n\t\t<ul class=\"js-sitelinks-tabs sitelinks__tablist\" role=\"tablist\" tabindex=\"-1\"></ul>\n\t</div>\n\t<div class=\"js-sitelinks-panels sitelinks__panels\"></div>\n</div>\n";

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Stylesheet;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base;

	use(BaseUI).toCreate(Stylesheet);

	/**
	 * Stylesheet UI Component
	 * @type {Stylesheet}
	 * @implements {Stylesheet}
	 * @memberOf awf.ui
	 *
	 * @constructor
	 * @augments {BaseUI}
	 * @requires jQuery
	 * @requires lodash
	 * @memberOf awf.ui
	 * @param {Object} params
	 * @param {String} params.content The content of the stylesheet. The value will be stored to this.content
	 *
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var ss = new awf.ui.Stylesheet();
	 *
	 * @example
	 *  // Creating a simple instance, but waiting to apply it
	 *  // render() is NOT called on instantiation
	 *  var ss = new awf.ui.Stylesheet({
	 *  	render: false,
	 *  	content: 'span.bar { color: #f00; }'
	 *  });
	 *
	 * // span.bar remains unaffected
	 *
	 * // Sometime later...
	 * ss.render();
	 *
	 * // span.bar may now be of a red color (unless some other CSS retains senority)
	 *
	 */
	function Stylesheet (params) {

		params = params || {};

		/**
		 * The template of this UI component: A style element
		 * @type {String}
		 */
		this.template = '<style type="text/css"></style>';

		/**
		 * The passive holder for the element's content. Calling render will pull this in.
		 * Prefered: use the css() method to update this, as it will call render as needed for you.
		 * Takes params.content
		 * @default ''
		 * @type {String}
		 */
		this.content = params.content || this.content || '';

		BaseUI.apply(this, arguments);
	}

	_.extend(Stylesheet.prototype, {

		/**
		 * Adds/replaces a &lt;style&gt; element to &lt;head&gt;, filling it with `this.content`
		 * Unlike other render methods, this will automatically append (or replace) itself in the DOM (&lt;head&gt;)
		 * @memberOf awf.ui.Stylesheet
		 * @return {this} (chainable)
		 */
		render: function () {
			BaseUI.prototype.render.call(this);

			if (this.content) {
				this.$el.html(this.content);

				// auto-add to <head>
				if (this.$el.parent().length === 0)
					$('head').append(this.$el);
			}

			return this;
		},

		/**
		 * Gives new content to the stylesheet by updating `this.content` -- and calling render if already in the DOM.
		 * If the component is in the DOM, styles will naturally apply instantly.
		 * If not in the DOM, they will appear as soon as render() is called.
		 * @memberOf awf.ui.Stylesheet
		 * @param  {String} new_css The content of the stylesheet
		 * @return {this}         (chainable)
		 *
		 * @example
		 * // Gives &lt;span class="bar"&gt;Hello&lt;/span&gt; a red text color.
		 * ss.css('span.bar { color: #f00; }');
		 */
		css: function (new_css) {
			if (arguments.length === 0)
				return this.content;

			this.content = new_css;

			if (new_css) {
				if (this.$el)
					return this.render();
			} else {
				this.destroy();
			}

			return this;
		}

	});


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = TitledCard;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		Card = awf.ui.Card,
		BaseUI = awf.ui.Base,
		template = __webpack_require__(165);

	use(Card).toCreate(TitledCard);

	/**
	 * TitledCard UI Component
	 * @type {TitledCard}
	 * @class
	 * @implements {TitledCard}
	 * @memberOf awf.ui
	 *
	 * @param {object} params
	 * @param {string} params.title The TitledCard's title.
	 * @param {string|object} params.content The TitledCard's content
	 * which can be an html string or a jQuery object.
	 *
	 * @property {string} title The TitleCard's title. Initial
	 * value set to null unless passed a value on instantiaion.
	 * @property {string|object} content The TitledCard's content.
	 * Initial value set to null unless passed a value on instantiation.
	 * @property {string} aria_id A random id used for aria labelling.
	 * @property {object} _$titlebar A jQuery reference to the titlebar wrapper
	 * @property {object} _$title A jQuery reference to the title container
	 * @property {object} _$content A jQuery reference to the content container
	 *
	 * @augments {awf.ui.Card}
	 * @requires jQuery
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var titled_card = new awf.ui.TitledCard();
	 *
	 * @example
	 *  // Pass some parameters to start
	 *
	 * var titled_card = new awf.ui.TitledCard({
	 *   title: "Hello World",
	 *   content: "&lt;div&gt;Lorem ipsum dolor sit&lt;/div&gt;"
	 * });
	 *
	 * // or pass a jQuery object as content
	 *
	 * var titled_card = new awf.ui.TitledCard({
	 *   title: "Hello World",
	 *   content: $hello_world_content
	 * });
	 *
	 */
	function TitledCard (params) {
		//Extend Superclass template
		var $card = $(awf.ui.Card.template),
			$div = $('<div></div>');

		$card.addClass('-titled-card');
		$card.find('.js-card').append($(template));

		$div.append($card);

		this.template = $div.html();


		params = params || {};

		awf.util.mixin.properties(this, params, {

			/**
			 * @memberof awf.ui.TitledCard
			 * @name setTitle
			 * @function
			 * @instance
			 *
			 * @param {String} val The title to set
			 * @return {Object} this (chainable)
			 */
			title: {
				default: null,
				types: ['string'],
				renderHandler: function (val) {
					this._$title
						.html(val);
				}
			},

			/**
			 * @memberof awf.ui.TitledCard
			 * @name setContent
			 * @function
			 * @instance
			 *
			 * @param  {String|Object} val The content to set.
			 * Can be an html string or a jQuery object
			 * @return {Object} this (chainable)
			 */
			content: {
				default: null,
				types: ['string','object'],
				renderHandler: function (val) {
					this._$content
						.html(val);
				}
			}

		});


		Card.apply(this, arguments);
	}


	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(TitledCard, {
			titlebar: '.js-card-titlebar',
			title: '.js-card-title',
			content: '.js-card-content',
			message: '.js-card-message'
		});


	_.extend(TitledCard.prototype, {

		/**
		 * Renders the TitledCard. This includes automatically calling
		 * setTitle and/or setContent if they were defined during
		 * instantiation, and setting up appropriate event handlers.
		 * @memberof awf.ui.TitledCard
		 * @instance
		 *
		 * @return {Object} self chainable
		 */
		render: function () {
			var self = this;

			Card.prototype.render.apply(self, arguments);

			//Generate ARIA attribute(s)
			self._$title
				.attr('id',self.aria_id);
			self._$content
				.attr('aria-labelledby',self.aria_id);

			/**
			 * @type {Object}
			 * @name _$title.on
			 * @function
			 * @memberof awf.ui.TitledCard
			 * @listens this._$title#click
			 * @fires this#request-open
			 */
			self._$title.on('click', function () {
				self.triggerHandler('request-open');
			});

			/**
			 * @type {Object}
			 * @name _$card.on
			 * @function
			 * @memberof awf.ui.TitledCard
			 * @listens this._$card#keyup
			 * @fires this#request-open
			 */
			self._$card.on("keyup", function (e) {
				var $target = $(e.target);

				//not the container? don't do anything
				if( $target[0] != self._$card[0])
					return;

				//IF ENTER, act like someone clicked on the title.
				if(e.keyCode === awf.util.keyCodes.enter){
					self.triggerHandler("request-open");
				}
			});

			return self;
		},


		/**
		 * Creates an instance of awf.ui.Message, and displays the message in this._$message DOM element
		 * @param {null|string} type The type of message. Must be null, "error", "warn", "info", or "success".
		 * @param {null|string} message The message to post.
		 * @param {boolean} [show_dismiss=true] If false, the message's dismiss button will be hidden, otherwise it will be shown.
		 * @memberOf awf.ui.TitledCard
		 * @instance
		 * @see awf.ui.Message
		 *
		 * @return {awf.ui.Message} The awf.ui.Message instance
		 *
		 * @example
		 * // a warning that stays until a user dismisses it
		 * card_instance.postMessage('warn', "Please dismiss me");
		 *
		 * // information that dismisses itself after 5 seconds unless a user dismisses it manually, sooner
		 * card_instance.postMessage('info', "I will go away in 5 seconds, unless you dismiss me sooner than that.").andDismissIn(5);
		 *
		 * // a success message that doesn't have a dismiss button, but will dismiss itself after 3 seconds
		 * card_instance.postMessage('success', "Hello World!", false).andDismissIn(3);
		 */
		postMessage: function (type, message, show_dismiss) {
			return awf.util.postMessage(this._$message, type, message, show_dismiss);
		}

	});


/***/ },
/* 165 */
/***/ function(module, exports) {

	module.exports = "<div class=\"js-card-titlebar awf-card__titlebar\">\n\t<h2 class=\"js-card-title awf-card__titlebar__title -color-alt -border-color-base js-drag-handle\"></h2>\n</div>\n<div class=\"js-card-message awf-card__message\"></div>\n<div class=\"js-card-content awf-card__content\" role=\"region\"></div>\n";

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = LargeCard;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		TitledCard = awf.ui.TitledCard,
		BaseUI = awf.ui.Base;

	use(TitledCard).toCreate(LargeCard);

	/**
	 * LargeCard UI Component
	 * @type {LargeCard}
	 * @class
	 * @implements {LargeCard}
	 * @memberOf awf.ui
	 *
	 * @param {object} params parameters for this Class or its Super Classes
	 *
	 * @property {object} _$close jQuery object reference for the close button
	 *
	 * @augments {awf.ui.TitledCard}
	 * @requires jQuery
	 *
	 * @example
	 * // Creating a simple instance
	 * // render() is called on instantiation
	 * var large_card = new awf.ui.LargeCard();
	 *
	 * @example
	 * // Pass some parameters to start *
	 * var large_card = new awf.ui.LargeCard({
	 *   title: "Hello World",
	 *   content: $hello_world_content
	 * });
	 *
	 */
	function LargeCard () {
		var self = this;

		TitledCard.apply(self, arguments);

		/**
		 * The Large Card close button.
		 * @type {awf.ui.Button}
		 * @memberOf awf.ui.LargeCard
		 */
		self.children.close = new awf.ui.Button({
			parent: function () {
				return self._$titlebar;
			},
			classname: 'js-large-card-close awf-card__titlebar__close -awf-focus -awf-link-inverted',
			icon: 'awficon-close',
			text: 'Close ' + self.title,
			renderHandler: function () {
				this.$el.on('click', function () {
					self.triggerHandler('request-close');
				});
			}
		});

	}


	/*	element shortcuts
	------------------------------------------*/
		// BaseUI.generateDomProperties(LargeCard, {
		// });


	_.extend(LargeCard.prototype, {

		/**
		 * Renders the LargeCard. Augments the TitledCard Super Class by
		 * no longer listening to 'click-title' events, updating some
		 * template elements' attributes, and adding a close button
		 * @memberof awf.ui.LargeCard
		 *
		 * @return {Object} self chainable
		 */
		render: function () {
			var self = this;

			TitledCard.prototype.render.apply(this, arguments);

			self.$el.addClass('-large-card');
			self._$card
				.removeClass('-awf-focus')
				.removeAttr('tabindex');

			self._$title.removeClass('js-drag-handle');


			//Events
			// stop listening to super class' events
			self._$title.off('click');
			self.$el.off('keyup');

			return self;
		}

	});


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Notifications;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(168);



	use(BaseUI).toCreate(Notifications);

	/**
	 * Notifications UI Component
	 * @type {Notifications}
	 * @implements {Notifications}
	 * @memberOf awf.ui
	 *
	 * @class
	 * @augments {awf.ui.Base}
	 * @requires jQuery
	 * @requires lodash
	 * @param {Object} params
	 * @param {array} params.json Optional json data for the notifications banner
	 *
	 * @property {array} json - set to the value of params.json (an empty array by default)
	 * @property {array} items - array of notification objects populated by
	 * addItem() method, created on render()
	 * @property {object} active - the active notification object populated by
	 * updateNotifications() method, created on render()
	 * @property {object} _$dismiss - jQuery object for the dismiss button
	 * @property {object} _$icon - jQuery object for the notification's icon
	 * @property {object} _$title - jQuery object for the notification's title
	 * @property {object} _$description - jQuery object for the notification's description
	 *
	 * @example
	 *  // Creating a simple instance
	 *  // render() is called on instantiation
	 *  var notifications = new awf.ui.Notifications();
	 *
	 * @example
	 *  // Creating an instance with JSON data
	 *  var notifications = new awf.ui.Notifications({
	 *    json: [
	 *      {
	 *        "id" : 0, //required, unique identifier
	 *        "start" : "Sun Jun 14 2015 00:00:00 (EDT)", //required, a valid date
	 *        "end" : "Fri Aug 14 2015 00:00:00 (EDT)", //required, a valid date
	 *        "title": "First Notification Title", //optional, string of text or html
	 *        "description": "Lorem ipsuom dolor &lt;a href='http://www.google.com'&gt;sit amet.&lt;/a&gt;", //optional, string of text or html
	 *        "theme" : "theme-error", //optional
	 *        "icon" : "awficon-discover", //optional
	 *        "hide_icon" : true, //optional
	 *        "hide_dismiss" : true //optional
	 *      },
	 *      {
	 *        "id" : 1,
	 *        "title": "Second Notification Title",
	 *        "description": "Lorem ipsuom dolor sit amet.",
	 *        "start" : "Aug 8 2015 00:00:00 (EDT)",
	 *        "end" : "Fri Aug 21 2015 00:00:00 (EDT)"
	 *      }
	 *    ]
	 *  });
	 */
	function Notifications (params) {
		params = params || {};
		params.template = params.template || this.template || template;
		this.json = params.json || [];

		BaseUI.call(this, params);
	}

	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Notifications, {
			dismiss: '.js-notifications-dismiss',
			icon: '.js-notifications-icon',
			title: '.js-notifications-title',
			description: '.js-notifications-description'
		});

	_.extend(Notifications.prototype, {

		/**
		 * Clears Notifications.items and Notifications.active, calls
		 * Notifications.addItem() for each object in Notifications.json, and
		 * calls Notifications.updateNotifications()
		 * @memberof awf.ui.Notifications
		 * @listens Notifications._$dismiss.click
		 * @return {Object} self chainable
		 */
		render: function () {
			var self = this;

			BaseUI.prototype.render.apply(self, arguments);

			//clear out items property on render, otherwise we get duplicated data
			self.items = [];
			self.active = null;

			self._$dismiss.on('click', function() {
				self.dismiss();
			});

			_.forEach(self.json, function (item) {
				self.addItem(item);
			});

			self.updateNotifications();

			return self;
		},

		/**
		 * Shows the Notifications.$el and sets appropriate aria attributes
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		show: function () {
			var self = this;

			self.$el
				.attr('aria-hidden','false')
				.slideDown('fast');

			self._$dismiss
				.attr('aria-expanded','true');

			return self;
		},

		/**
		 * Hides the Notifications.$el and sets appropriate aria attributes
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		hide: function () {
			var self = this;

			self.$el
				.attr('aria-hidden','true')
				.slideUp('fast');

			self._$dismiss
				.attr('aria-expanded','false');

			return self;
		},

		/**
		 * Sets the Notifications._$title HTML to passed value
		 * @memberof awf.ui.Notifications
		 * @param  {string} new_value title to set
		 * @return {Object} self chainable
		 */
		setTitle: function (new_value) {
			this._$title.html(new_value);
			return this;
		},

		/**
		 * Sets the Notifications._$description HTML to passed value
		 * @memberof awf.ui.Notifications
		 * @param  {string} new_value description to set
		 * @return {Object} self chainable
		 */
		setDescription: function (new_value) {
			this._$description.html(new_value);
			return this;
		},

		/**
		 * Sets a local storage item, calls Notifications.hide(), and sets Notifications.active to null
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		dismiss: function () {
			var self = this;

			if ( ! self.active) {
				self.hide();
				return false;
			}

			localStorage.setItem("banner-dismissed-date",new Date());

			self.hide();
			self.active = null;

			return self;
		},

		/**
		 * Hides the dismiss button
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		hideDismiss: function () {
			this.$el.addClass('-hide-dismiss');
			return this;
		},

		/**
		 * Shows the dismiss button
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		showDismiss: function () {
			this.$el.removeClass('-hide-dismiss');
			return this;
		},

		/**
		 * Sets the notification icon to passed value. "awficon-" prefix will
		 * be added to passed value if it isn't already present. Defaults to "awficon-alert-announcement" if null is passed.
		 * @memberof awf.ui.Notifications
		 * @param  {string|null} classname CIO Icon selector classname
		 * @return {Object} self chainable
		 */
		setIcon: function (classname) {
			// remove all icons
			this._$icon.removeClass(function (index, css) {
				return (css.match (/(^|\s)awficon-\S+/g) || []).join(' ');
			});

			// must have a default
			classname = classname || "alert-announcement";
			// remove 'awficon-' identifier, if it is there
			classname = classname.replace(/^(awficon-)/,"");
			this._$icon.addClass("awficon-" + classname);

			return this;
		},

		/**
		 * Hides the notification icon
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		hideIcon: function () {
			this.$el.addClass('-hide-icon');
			return this;
		},

		/**
		 * Shows the notification icon
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		showIcon: function () {
			this.$el.removeClass('-hide-icon');
			return this;
		},

		/**
		 * Removes all class names prefixed by "theme-" from Notifications.$el, and
		 * adds classname passed. "theme-" prefix will be added to the passed value
		 * if it isn't already present.
		 * @memberof awf.ui.Notifications
		 * @param  {string|null} classname classname for the theme
		 * @return {Object} self chainable
		 */
		setTheme: function (classname) {
			// remove all themes
			this.$el.removeClass(function (index, css) {
				return (css.match (/(^|\s)theme-\S+/g) || []).join(' ');
			});

			// if a new one was provided, add it
			if (classname)
				// remove 'theme-' identifier, if it is there
				classname = classname.replace(/^(theme-)/,"");
				this.$el.addClass("theme-" + classname);

			return this;
		},

		/**
		 * Adds passed object to the Notifications.items array.
		 * @memberof awf.ui.Notifications
		 * @param {object} item the notification to add
		 * @param {string|integer} item.id unique id
		 * @param {string|undefined} item.title notification's title
		 * @param {string|undefined} item.description notification's description
		 * @param {string|undefined} item.theme notification's theme classname
		 * @param {string|undefined} item.icon notification's CIO Icon classname
		 * @param {boolean|undefined} item.hide_icon if true, CIO Icon will be
		 *        hidden for this notification by default.
		 * @param {boolean|undefined} item.hide_dismiss if true, the dismiss
		 *        button will be hidden by default for this notification.
		 * @param {string} item.start notification's start date (must be valid date string)
		 * @param {string} item.end notification's end date (must be valid date string)
		 * @throws Will throw an error if passed item is not a valid object
		 * @return {Object} self chainable
		 */
		addItem: function (item) {

			if (typeof item == "object") {
				var self = this,
					obj = {
						id: item.id || awf.util.randomID(),
						title: item.title || null,
						description: item.description || null,
						theme: item.theme || null,
						icon: item.icon || null,
						hide_icon: item.hide_icon || null,
						hide_dismiss: item.hide_dismiss || null
					};

				_.extend(obj, {
					start: new Date(item.start),

					end: new Date(item.end),

					isActive: function () {
						var dtmNow = new Date(),
							dtmStart = this.start,
							dtmEnd = this.end;
						return (dtmStart <= dtmNow) && (dtmNow < dtmEnd);
					},

					isDismissed: function () {
						var strDismissed = localStorage.getItem("banner-dismissed-date");
						if (strDismissed===null)
							return false;
						var dtmDismissed = new Date(strDismissed),
							dtmStart = this.start;
						return dtmDismissed > dtmStart;
					},

					eta: function () {
						var dtmNow = new Date(),
							dtmStart = this.start;
						return dtmStart-dtmNow;
					}
				});

				var eta = obj.eta();
				if (eta > 0) {
					obj.timeout = setTimeout(function () {
						self.updateNotifications();
					}, eta);
				}

				self.items.push(obj);
			} else {
				throw new Error("Cannot add a notification of type '" + typeof item + "'. Review documentation for further instruction.");
			}

			return this;
		},

		/**
		 * Calls this.set() with this.items object with passed id
		 * @memberof awf.ui.Notifications
		 * @param {string|id} id the id of the item to set
		 * @return {Object} self chainable
		 */
		setById: function (id) {
			var item = _.find(this.items, function(o) {
				return o.id == id;
			});

			if (item)
				this.set(item);

			return this;
		},

		/**
		 * Removes notification with passed id from Notifications.items object
		 * @memberof awf.ui.Notifications
		 * @param {string|id} id the id of the notification to remove
		 * @return {Object} self chainable
		 */
		removeItem: function (id) {
			var item = _.find(this.items, function(o) {
				return o.id == id;
			});

			clearTimeout(item.timeout);

			_.remove(this.items, item);

			return this;
		},

		/**
		 * Sorts Notifications.items descending by start property's value.
		 * The method then determines if there is an active notification. If there
		 * is an active notification, Notifications.active will be set to it and
		 * Notifications.set() will be called with it.
		 * If there is no active notification, Notifications.hide() is called.
		 * @memberof awf.ui.Notifications
		 * @return {Object} self chainable
		 */
		updateNotifications: function () {
			this.items = _.sortBy(this.items, 'start');

			var active_items = _.filter(this.items, function(o) {
				var is_active = o.isActive(),
					is_dismissed = o.isDismissed();

				return (is_active && ! is_dismissed);
			});

			if ( active_items.length > 0 ) {
				var active = active_items[0];

				if ( ! _.isEqual(active, this.active)) {
					this.active = active;

					var active_to_set = _.pick(active, [
							'title',
							'description',
							'icon',
							'hide_icon',
							'hide_dismiss',
							'theme'
						]);
					this.set(active_to_set);
				}
			} else {
				this.hide();
			}

			return this;
		},


		/**
		 * Calls a number of methods to set the notification to the passed parameters.
		 * Calls Notifications.show() if params is truthy, otherwise it will call
		 * Notifications.hide().
		 * @memberof awf.ui.Notifications
		 * @param {object} params the notification to set
		 * @param {string|undefined} params.title notification's title,
		 *        Notifications.setTitle() will be called with its value
		 * @param {string|undefined} params.description notification's description,
		 *        Notifications.setDescription() will be called with its value
		 * @param {string|undefined} params.theme notification's theme classname,
		 *        Notifications.setTheme() will be called with its value
		 * @param {string|undefined} params.icon notification's CIO Icon classname,
		 *        Notifications.setIcon() will be called with its value
		 * @param {boolean|undefined} params.hide_icon Notifications.hideIcon() will
		 *        be called if truthy, otherwise Notifications.showIcon() is called.
		 * @param {boolean|undefined} params.hide_dismiss Notifications.hideDismiss() will
		 *        be called if truthy, otherwise Notifications.showDismiss() is called.
		 * @return {Object} self chainable
		 */
		set: function (params) {
			if (params) {
				this.setTitle(params.title || null);
				this.setDescription(params.description || null);
				this.setTheme(params.theme || null);
				this.setIcon(params.icon || null);
				this[params.hide_icon ? "hideIcon" : "showIcon"]();
				this[params.hide_dismiss ? "hideDismiss" : "showDismiss"]();

				this.show();
			} else {
				this.hide();
			}

			return this;
		}
	});



	/**
	 * @typedef notifyConfig
	 * @memberof awf.ui.Notifications
	 * @type Object
	 * @description The notifyConfig object is used to describe the configurable elements of a notifications banner ui component. The configuration is used to build the page through {@link awf.init} or [awf.app.compose]{@link awf.__.App.compose}.
	 * 
	 * @property {string} [data] path to a notifications JSON configuration file
	 * 
	 * @example
	 * // This will create and initialize awf.page.notifications with
	 * // a template (awf.page.notifications.$el) that is appended to
	 * // a container within awf.page.$el.
	 *
	 * awf.init({
	 *   page: {
	 *     name: "My App",
	 *     notifications: {
	 *       data: "/data/notifications.json"
	 *     }
	 *   }
	 * });
	 * 
	 */


/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"js-notifications notifications\" aria-hidden=\"true\" style=\"display:none;\">\n\t<span class=\"js-notifications-icon notifications__icon awficon-alert-announcement\"></span>\n\t<div class=\"notifications__wrap\">\n\t\t<div class=\"notifications__wrap__text\">\n\t\t\t<span class=\"js-notifications-title notifications__wrap__text__title\" role=\"heading\"></span>\n\t\t\t<span class=\"js-notifications-description notifications__wrap__text__description\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"notifications__dismiss\">\n\t\t<button class=\"js-notifications-dismiss notifications__dismiss__button awficon-close\" title=\"Dismiss\" aria-controls=\"notifications-banner\" aria-expanded=\"false\" role=\"button\"><span class=\"awf-access\">Dismiss/Close</span></button>\n\t</div>\n</div>\n";

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Themes;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Stylesheet = __webpack_require__(163),
		_themeables = _.template(__webpack_require__(170)),
		BaseObject = awf.__.BaseObject;

	use(BaseObject).toCreate(Themes);


	/**
	 * @typedef themeConfig
	 * @memberof awf.ui.Themes
	 * @type Object
	 *
	 * @description
	 * The themeConfig object is used to configure a single theme. Default values will be used wherever an optional parameter is not defined.
	 *
	 * @property {string} classname A classname that can be leveraged in your projects CSS
	 * @property {string} label A label for the theme (for display)
	 * @property {string} font The theme font family
	 * @property {string} background_base The theme base background color
	 * @property {string} background_content The theme content background color
	 * @property {string} color_base The theme base font color
	 * @property {string} color_link The theme link color
	 * @property {string} background_leftnav The theme left navigation background color
	 * @property {string} [background_leftnav_hover] The theme left navigation item hover background color
	 * @property {string} [background_leftnav_active] The theme left navigation active item background color
	 * @property {string} [border_color_base] The theme base border color
	 * @property {string} [color_alt] The theme alternate font color
	 * @property {string} [background_alt] The theme alternate background color
	 * @property {string} [border_color_alt] The theme alternate border color
	 * @property {string} [color_notifications] The theme notification banner font color
	 * @property {string} [background_notifications] The theme notification banner background color
	 * @property {string} [background_notifications_dismiss_hover] The theme notification banner dismiss button hover background color
	 * @property {string} [border_color_notifications] The theme notification banner border color
	 * @property {string} [color_link_hover] The theme link hover color
	 * @property {string} [color_selection] The theme selected text color
	 * @property {string} [background_selection] The theme selected text background color
	 * @property {string} [color_input] The theme input text color
	 * @property {string} [background_input] The theme input background color
	 * @property {string} [border_input] The theme input border color
	 * @property {string} [box_shadow_base] The theme base box shadow style
	 * @property {string} [box_shadow_focus] The theme focus box shadow style
	 * @property {string} [background_search_results_hover] The theme search results hover-state background color
	 * @property {string} [foreground_message_success] The theme success messaging foreground color
	 * @property {string} [background_message_success] The theme success messaging background color
	 * @property {string} [foreground_message_info] The theme info messaging foreground color
	 * @property {string} [background_message_info] The theme info messaging background color
	 * @property {string} [foreground_message_error] The theme error messaging foreground color
	 * @property {string} [background_message_error] The theme error messaging background color
	 * @property {string} [foreground_message_warn] The theme warn messaging foreground color
	 * @property {string} [background_message_warn] The theme warn messaging background color
	 * @property {string} [foreground_button] The theme button foreground color
	 * @property {string} [background_button] The theme button background color
	 * @property {string} [foreground_button_hover] The theme button hover foreground color
	 * @property {string} [background_button_hover] The theme button hover background color
	 * @property {string} [foreground_tray_button] The theme tray button foreground color
	 * @property {string} [background_tray_button] The theme tray button background color (also tray content's outline color)
	 *
	 * @example
	 * // A theme configuration object
	 * var themeConfig = {
	 *   "classname": "contrast",
	 *   "label": "contrast",
	 *   "font": "arial, sans-serif",
	 *   "background_base": "#ffffff",
	 *   "background_content": "#e0e0e0",
	 *   "color_base": "#000000",
	 *   "border_color_base": "#CCCCCC",
	 *   "color_alt": "#000000",
	 *   "background_alt": "#e0e0e0",
	 *   "border_color_alt": "#73737d",
	 *   "color_notifications": "#000000",
	 *   "background_notifications": "#ffffff",
	 *   "background_notifications_dismiss_hover": "#0024b1",
	 *   "border_color_notifications": "#0061ff",
	 *   "color_link": "#0024b1",
	 *   "color_link_hover": "#0061ff",
	 *   "color_selection": "#000000",
	 *   "background_selection": "#73737d",
	 *   "color_input": "#000000",
	 *   "background_input": "#ffffff",
	 *   "border_input": "1px solid #73737d",
	 *   "box_shadow_base": "0px 0px 5px 0px rgba(0,0,0,0.5)",
	 *   "box_shadow_focus": "0px 0px 6px 0px #0061ff",
	 *   "background_leftnav": "#ffffff",
	 *   "background_leftnav_hover": "#ffffff",
	 *   "background_leftnav_active": "#F4F4F4",
	 *   "color_leftnav_active": "#000000",
	 *   "background_search_results_hover": "#F4F4F4",
	 *   "foreground_message_success": "#6CBB1F",
	 *   "background_message_success": "#E9F7DB",
	 *   "foreground_message_info": "#074F95",
	 *   "background_message_info": "#EAF4FA",
	 *   "foreground_message_error": "#BD2121",
	 *   "background_message_error": "#FDE9E8",
	 *   "foreground_message_warn": "#F8C41C",
	 *   "background_message_warn": "#FEF2CD",
	 *   "foreground_button": "#ffffff",
	 *   "background_button": "#0024b1",
	 *   "foreground_button_hover": "#ffffff",
	 *   "background_button_hover": "#0061ff",
	 *   "foreground_tray_button": "#ffffff",
	 *   "background_tray_button": "#0024b1",
	 *   "border_color_tray_content": "#0024b1"
	 * };
	 */

	/**
	 * @class Themes
	 * @augments {awf.__.BaseObject}
	 * @type {object}
	 * @memberOf awf.ui
	 * @requires jQuery
	 * @requires lodash
	 *
	 * @classdesc
	 * The Themes class provides the functionality associated with UI themes.
	 *
	 * @description
	 * Constructs an AWF Themes class. The passed params will look for a "themes" property and process the object contained within, looking for key value pairs where the the key is the id of the theme and it's value is a [themeConfig]{@link awf.ui.Themes.themeConfig} object.
	 *
	 * @param {object} params
	 * @param {Object.<...string, awf.ui.Themes.themeConfig>} params.themes - An object containing a set of theme id and theme config object pairs
	 *
	 * @property {array} classnames - Array of theme classnames
	 * @property {object} items - stored theme objects. this.items.default is included by default
	 * @property {object} stylesheet - awf.ui.Stylesheet object
	 * @property {string} current_theme - the id of the currently applied theme
	 *
	 * @example
	 *  // Creating a simple instance, defining only the required values
	 *  var themes = new awf.ui.Themes({
	 *    themes: {
	 *      "contrast": {
	 *        "classname": "contrast",
	 *        "label": "contrast",
	 *        "font": "arial, sans-serif",
	 *        "background_base": "#ffffff",
	 *        "background_content": "#e0e0e0",
	 *        "color_base": "#000000",
	 *        "color_link": "#0024b1",
	 *        "background_leftnav": "#ffffff",
	 *      }
	 *    }
	 *  });
	 */
	function Themes (params) {
		console.log('params: ', params);

		BaseObject.apply(this, arguments);

		var self = this;

		params = params || {};

		self.has_custom_default = false;
		self.classnames = ["default"];
		self.items = {
			default: {
				classname: "default",
				//TODO: automate this in theme-switcher
				theme: {
					id: "default",
					classname: "default",
					label: "default",
					background_content: "#e4e4e4",
					background_base: "#ffffff",
					background_leftnav: "#f5f5f4",
					color_link: "#0024b1",
					font: "helvetica, sans-serif",
					color_base: "#00183f"
				}
			}
		};


		self.stylesheet = new Stylesheet();

		if (params.themes) {
			// If custom default, override here
			if (params.themes.default) {
				self.has_custom_default = true;
			}

			_.forEach(params.themes, function (theme, key) {
				self.addTheme(key, theme);
			});
		}

		self.cs_pref = awf.construct.getOrCreate('app-theme');

		var ls_value = localStorage.getItem("app-theme"),
			saved_value = self.cs_pref.value || ls_value;

		self.current_theme = "default";

		if (saved_value in self.items) {
			self.current_theme = saved_value;
		}

		console.log('theme pref value: ', self.cs_pref.value);

		if (self.cs_pref.value) {
			
			self.setTheme(self.current_theme);

		} else {
			self.applyTheme(self.current_theme);

			console.time('theme construct');
			self.cs_pref.fetch(-1)
				.always(function () {
					console.timeEnd('theme construct');
				})
				.done(function (val) {
					if (val in self.items) {
						self.setTheme(val);
					}
				});
		}
	}


	_.extend(Themes.prototype, {

		/**
		 * Adds a theme object to this.items.
		 * @memberof awf.ui.Themes
		 * @param {string} key - the theme's ID
		 * @param {awf.ui.Themes.themeConfig} theme - an object with with the configuration for a single theme
		 *
		 * @fires this#add and passes the id of the added theme
		 * @return {Object} self chainable
		 */
		addTheme: function (key, theme) {
			var self = this;

			if (theme) {
				var given_keys = _.keys(theme),
					expected_keys = [
						"classname",
						"label",
						"background_base",
						"background_content",
						"background_leftnav",
						"color_link",
						"font",
						"color_base"
					],
					missing_keys = _.difference(expected_keys, given_keys);

				if (missing_keys.length === 0) {
					self.items[key] = {
						classname: theme.classname,
						styles: _themeables(theme),
						theme: theme
					};
					self.classnames.push(theme.classname);
					self.triggerHandler('add', key);
				} else {
					throw new Error("Themes.addTheme() Error: The theme you're attempting to add is missing the following parameters: " + missing_keys);
				}
			}

			return self;
		},

		/**
		 * Deletes a theme object from this.items
		 * @memberof awf.ui.Themes
		 * @param {string} id The id of the theme to be deleted
		 *
		 * @fires this#remove and passes the id of the deleted theme
		 * @return {Object} null if not found, otherwise the removed theme
		 */
		removeTheme: function (id) {
			if (id in this.items) {
				var pos = this.classnames.indexOf(this.items[id].classname),
					theme = this.items[id];

				this.classnames.splice(pos, 1);
				delete this.items[id];
				this.triggerHandler('remove', id);

				return theme;
			} else {
				return null;
			}
		},

		/**
		 * Adds the theme's classname to the html element and applies the theme's
		 * styles to this.stylesheet. A valid theme ID must be passed.
		 * @memberof awf.ui.Themes
		 * @param {string} id The id of the theme to be set
		 *
		 * @fires this#change and passes the id of the theme that was set
		 * @return {Object} self chainable
		 */
		setTheme: function (id) {
			var self = this;

			if (self.items[id]) {
				localStorage.setItem("app-theme", id);

				if (self.cs_pref.value != id) {
					self.cs_pref
						.setValue(id)
						.save();
				}

				self.current_theme = id;
				this.applyTheme();

				self.triggerHandler('change', id);
			} else {
				throw new Error("Error Setting Theme: \"" + id + "\" is not a valid theme id.");
			}
			return self;
		},

		/**
		 * Same as this.setTheme() except it doesn't store the passed value as the
		 * current theme. Passing null applies this.current_theme
		 * @memberof awf.ui.Themes
		 * @param {string} id The id of the theme to be previewed
		 *
		 * @fires this#apply and passes the id of the theme that was applied
		 * @return {Object} self chainable
		 */
		applyTheme: function (id) {
			var self = this;

			id = id || self.current_theme;

			if (self.items[id]) {
				$('html')
					.removeClass(this.classnames.join(" "))
					.addClass(self.items[id].classname);

				if (id == "default" && ! self.has_custom_default) {
					self.stylesheet.destroy();
				} else {
					self.stylesheet.css(self.items[id].styles).render();
				}

				self.triggerHandler('apply', id);
			} else {
				throw new Error('Error Previewing Theme: "' + id + '" is not a valid theme id.');
			}

			return self;
		}

	});


/***/ },
/* 170 */
/***/ function(module, exports) {

	module.exports = "{[\n\tvar font = font || \"helvetica, arial, sans-serif\";\n\tvar background_base = background_base || \"#ffffff\";\n\tvar background_content = background_content || \"#f4f4f4\";\n\tvar color_base = color_base || \"#00183f\";\n\tvar border_color_base = border_color_base || \"#e0e0e0\";\n\tvar color_alt = color_alt || \"#73737d\";\n\tvar background_alt = background_alt || \"#e0e0e0\";\n\tvar border_color_alt = border_color_alt || \"#73737d\";\n\tvar color_notifications = color_notifications || \"#ffffff\";\n\tvar background_notifications = background_notifications || \"#0061ff\";\n\tvar background_notifications_dismiss_hover = background_notifications_dismiss_hover || \"#0024b1\";\n\tvar border_color_notifications = border_color_notifications || \"#0061ff\";\n\tvar color_link = color_link || \"#0024b1\";\n\tvar color_link_hover = color_link_hover || \"#0061ff\";\n\tvar color_selection = color_selection || \"#dec6ff\";\n\tvar background_selection = background_selection || \"#5d00db\";\n\tvar color_input = color_input || \"#00183f\";\n\tvar background_input = background_input || \"#ffffff\";\n\tvar border_input = border_input || \"1px solid #e0e0e0\";\n\tvar box_shadow_base = box_shadow_base || \"0px 0px 5px 0px rgba(0,0,0,0.5)\";\n\tvar box_shadow_focus = box_shadow_focus || \"0px 0px 6px 0px #0061ff\";\n\tvar background_leftnav = background_leftnav || \"#f5f5f4\";\n\tvar background_leftnav_hover = background_leftnav_hover || \"#eeeeee\";\n\tvar background_leftnav_active = background_leftnav_active || \"#ffffff\";\n\tvar color_leftnav_active = color_leftnav_active || \"#00183f\";\n\tvar color_search_icon = color_search_icon || \"\";\n\tvar background_search_results_hover = background_search_results_hover || \"#f4f4f4\";\n\tvar foreground_message_success = foreground_message_success || \"#6CBB1F\";\n\tvar background_message_success = background_message_success || \"#E9F7DB\";\n\tvar foreground_message_info = foreground_message_info || \"#074F95\";\n\tvar background_message_info = background_message_info || \"#EAF4FA\";\n\tvar foreground_message_error = foreground_message_error || \"#BD2121\";\n\tvar background_message_error = background_message_error || \"#FDE9E8\";\n\tvar foreground_message_warn = foreground_message_warn || \"#F8C41C\";\n\tvar background_message_warn = background_message_warn || \"#FEF2CD\";\n\tvar foreground_badge = foreground_badge || \"#ffffff\";\n\tvar background_badge = background_badge || \"#990000\";\n\tvar foreground_button = foreground_button || \"#ffffff\";\n\tvar background_button = background_button || \"#0024b1\";\n\tvar foreground_button_hover = foreground_button_hover || \"#ffffff\";\n\tvar background_button_hover = background_button_hover || \"#0061ff\";\n\tvar foreground_tray_button = foreground_tray_button || \"#ffffff\";\n\tvar background_tray_button = background_tray_button || \"#0024b1\";\n\tvar border_color_tray_content = border_color_tray_content || \"#0024b1\";\n]}\n\n\n\n\n\n/*------------------------------------*\\\n\t#LAYOUT\n\\*------------------------------------*/\n\n\thtml {\n\t\tbackground: {{background_base}};\n\t}\n\n\tbody {\n\t\tfont-family: {{font}};\n\t\tcolor: {{color_base}};\n\t}\n\n\t::-moz-selection {\n\t\tbackground: {{background_selection}};\n\t\tcolor: {{color_selection}};\n\t}\n\t::selection {\n\t\tbackground: {{background_selection}};\n\t\tcolor: {{color_selection}};\n\t}\n\n\thr {\n\t\tborder-color: {{border_color_base}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#SEMANTIC\n\\*------------------------------------*/\n\n\ta,\n\t.-awf-link {\n\t\tcolor: {{color_link}};\n\t}\n\n\ta:hover, a:focus, a:active, a.-is-active,\n\t.-awf-link:hover, .-awf-link:focus, .-awf-link:active, .-awf-link.-is-active {\n\t\tcolor: {{color_link_hover}};\n\t}\n\n\n\t.-awf-link-inverted {\n\t\tcolor: {{color_base}};\n\t}\n\n\t.-awf-link-inverted:hover, .-awf-link-inverted:focus, .-awf-link-inverted:active, .-awf-link-inverted.-is-active {\n\t\tcolor: {{color_link_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#FORMS\n\\*------------------------------------*/\n\n\tinput,\n\ttextarea,\n\tselect {\n\t\tcolor: {{color_input}};\n\t\tbackground: {{background_input}}\n\t}\n\n\t::-webkit-input-placeholder {\n\t\tcolor: {{color_input}};\n\t}\n\n\t:-moz-placeholder {\n\t\tcolor: {{color_input}};\n\t}\n\n\t::-moz-placeholder {\n\t\tcolor: {{color_input}};\n\t}\n\n\t:-ms-input-placeholder {\n\t\tcolor: {{color_input}};\n\t}\n\n\tinput:-moz-placeholder {\n\t\tcolor: {{color_input}};\n\t}\n\n\t/* Buttons\n\t-----------------------------------------------*/\n\t\t.awf-btn {\n\t\t\tcolor: {{foreground_button}};\n\t\t\tbackground-color: {{background_button}};\n\t\t}\n\t\t.awf-btn:hover,\n\t\t.awf-btn:active,\n\t\t.awf-btn:focus {\n\t\t\tcolor: {{foreground_button_hover}};\n\t\t\tbackground-color: {{background_button_hover}};\n\t\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#HELPERS\n\\*------------------------------------*/\n\n\t.-awf-focus-on,\n\t.-awf-focus:focus {\n\t\t-webkit-box-shadow: {{box_shadow_focus}};\n\t\t   -moz-box-shadow: {{box_shadow_focus}};\n\t\t        box-shadow: {{box_shadow_focus}};\n\t}\n\n\t.-color-base {\n\t\tcolor: {{color_base}};\n\t}\n\n\t.-border-color-base {\n\t\tborder-color: {{border_color_base}};\n\t}\n\n\t.-border-color-link {\n\t\tborder-color: {{color_link}};\n\t}\n\n\t.-border-color-link:focus {\n\t\tborder-color: {{color_link_hover}};\n\t}\n\n\t.-color-alt {\n\t\tcolor: {{color_alt}};\n\t}\n\n\t.-color-link {\n\t\tcolor: {{color_link}};\n\t}\n\n\t.-color-link-hover {\n\t\tcolor: {{color_link_hover}};\n\t}\n\n\t.-background-base {\n\t\tbackground-color: {{background_base}};\n\t}\n\n\t.-background-alt {\n\t\tbackground-color: {{background_alt}};\n\t}\n\n\t.-background-link {\n\t\tbackground-color: {{color_link}};\n\t}\n\n\t.-box-shadow-base {\n\t\t-webkit-box-shadow: {{box_shadow_base}};\n\t\t   -moz-box-shadow: {{box_shadow_base}};\n\t\t        box-shadow: {{box_shadow_base}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #AWF-DROPDOWN\n\\*------------------------------------*/\n\n\t.awf-dropdown .tip-wrapper {\n\t\t\toutline: 0 0 5px {{color_link}};\n\t}\n\t.awf-dropdown .tip-wrapper .tip {\n\t\t-webkit-box-shadow: 0 0 5px {{border_color_alt}};\n\t\t   -moz-box-shadow: 0 0 5px {{border_color_alt}};\n\t\t        box-shadow: 0 0 5px {{border_color_alt}};\n\t}\n\n\n\t.awf-dropdown__wrapper__content {\n\t\t-webkit-box-shadow: 0px 0px 5px {{border_color_alt}};\n\t\t   -moz-box-shadow: 0px 0px 5px {{border_color_alt}};\n\t\t        box-shadow: 0px 0px 5px {{border_color_alt}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #IMAGE-CIRCLE\n\\*------------------------------------*/\n\n\t.image-circle {\n\t\tborder: 2px solid {{color_link}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #MASTHEAD_MASTHEAD-TRAYS\n\\*------------------------------------*/\n\n\t.masthead-trays__dropdown__close:focus,\n\t.masthead-trays__dropdown__close:hover,\n\t.masthead-trays__dropdown__close:active {\n\t\tcolor: {{color_link_hover}};\n\t}\n\n\t.masthead-trays__button-collection .btn-control.-is-active {\n\t\tcolor: {{color_link_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #MASTHEAD_USER\n\\*------------------------------------*/\n\n\t.masthead-icon .awf-dropdown__button:focus {\n\t\toutline: 1px dotted {{color_link_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #NOTIFICATIONS\n\\*------------------------------------*/\n\n\t.notifications {\n\t\tbackground: {{background_notifications}};\n\t\tcolor: {{color_notifications}};\n\t\tborder-color: {{border_color_notifications}};\n\t}\n\n\t.notifications a {\n\t\tcolor: {{color_notifications}};\n\t}\n\n\t.notifications__dismiss__button:hover,\n\t.notifications__dismiss__button:focus {\n\t\tbackground-color: {{background_notifications_dismiss_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#PAGE\n\\*------------------------------------*/\n\n\t.awf-page {\n\t\tbackground-color: {{background_content}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #SITELINKS\n\\*------------------------------------*/\n\n\t.sitelinks__tab-wrapper {\n\t\t-webkit-box-shadow: 0px -2px 0px 0px {{border_color_alt}} inset;\n\t\t   -moz-box-shadow: 0px -2px 0px 0px {{border_color_alt}} inset;\n\t\t        box-shadow: 0px -2px 0px 0px {{border_color_alt}} inset;\n\t}\n\n\t.sitelinks__tablist__tab.-is-active {\n\t\tborder-bottom: 2px solid {{color_link_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#TITLED-CARD\n\\*------------------------------------*/\n\n\t.awf-card__titlebar__title:focus,\n\t.awf-card__titlebar__title:hover {\n\t\tcolor: {{color_base}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#LARGE-CARD\n\\*------------------------------------*/\n\n\t.awf-card.-large-card .awf-card__titlebar__title:focus,\n\t.awf-card.-large-card .awf-card__titlebar__title:hover {\n\t\tcolor: {{color_alt}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #VERTICAL-NAV\n\\*------------------------------------*/\n\n\t#leftnav,\n\t.vertical-nav {\n\t\tbackground: {{background_leftnav}};\n\t}\n\n\t.vertical-nav__item:hover {\n\t\tbackground: {{background_leftnav_hover}};\n\t}\n\n\t.vertical-nav__item.-is-active {\n\t\tborder-left-color: {{color_link}};\n\t\tbackground: {{background_leftnav_active}};\n\t}\n\n\t.vertical-nav__item.-is-active .vertical-nav__item__icon,\n\t.vertical-nav__item.-is-active .vertical-nav__item__label {\n\t\tcolor: {{color_leftnav_active}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#SEARCH\n\\*------------------------------------*/\n\n\t.awf-search__submit,\n\t.awf-search__clear {\n\t\tcolor: {{color_search_icon}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#BUCKET\n\\*------------------------------------*/\n\n\t.awf-bucket-item:hover,\n\t.awf-bucket-item:focus,\n\t.awf-bucket-item:active {\n\t\tbackground: {{background_search_results_hover}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#MESSAGE\n\\*------------------------------------*/\n\n\t.awf-message--success {\n\t\tborder-left-color: {{foreground_message_success}};\n\t\tbackground-color: {{background_message_success}};\n\t}\n\n\t.awf-message--success .awf-message__icon {\n\t\tcolor: {{foreground_message_success}};\n\t}\n\n\n\t.awf-message--info {\n\t\tborder-left-color: {{foreground_message_info}};\n\t\tbackground-color: {{background_message_info}};\n\t}\n\n\t.awf-message--info .awf-message__icon {\n\t\tcolor: {{foreground_message_info}};\n\t}\n\n\n\t.awf-message--error {\n\t\tborder-left-color: {{foreground_message_error}};\n\t\tbackground-color: {{background_message_error}};\n\t}\n\n\t.awf-message--error .awf-message__icon {\n\t\tcolor: {{foreground_message_error}};\n\t}\n\n\n\t.awf-message--warn {\n\t\tborder-left-color: {{foreground_message_warn}};\n\t\tbackground-color: {{background_message_warn}};\n\t}\n\n\t.awf-message--warn .awf-message__icon {\n\t\tcolor: {{foreground_message_warn}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n\t#BADGE\n\\*------------------------------------*/\n\n\t.awf-badge {\n\t\tbackground: {{background_badge}};\n\t\tcolor: {{foreground_badge}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #CUSTOM-NAME\n\\*------------------------------------*/\n\n\t.awf-custom-name.-is-editable .awf-custom-name__btn:hover,\n\t.awf-custom-name.-is-editable .awf-custom-name__btn:focus {\n\t\tborder-color: {{color_link}};\n\t}\n\n\n\n\n\n/*------------------------------------*\\\n    #TRAY\n\\*------------------------------------*/\n\n\t.awf-tray .awf-tray__toggle {\n\t\tbackground-color: {{background_tray_button}};\n\t\tcolor: {{foreground_tray_button}};\n\t}\n\n\t.awf-tray .awf-tray__content {\n\t\tborder-color: {{border_color_tray_content}};\n\t}\n";

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ThemeSwitcher UI Component
	 * @type {ThemeSwitcher}
	 * @implements {ThemeSwitcher}
	 * @memberOf awf.ui
	 */
	module.exports = ThemeSwitcher;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(172);


	use(BaseUI).toCreate(ThemeSwitcher);

	/**
	 * If passed params.theme, the addOption() method will be called for each on instantiation.
	 * @class
	 * @augments {awf.ui.Base}
	 *
	 * @requires jQuery
	 * @requires loDash
	 *
	 * @param {array} params
	 * @param {object} params.themes theme objects (see addOption() method documentation for details about these objects)
	 *
	 * @property {string} template - HTML template
	 * @property {object} themes - stored theme objects. this.themes.default is included by default
	 * @property {object} _$current - jQuery object for template's current theme container
	 * @property {object} _$current_svg - jQuery object for template's current theme svg container
	 * @property {object} _$current_text - jQuery object for template's current theme text container
	 * @property {object} _$list - jQuery object for template's option list container
	 *
	 * @example
	 *  // Creating a simple instance
	 *  var theme_switcher = new awf.ui.ThemeSwitcher({
	 *        themes: {
	 *          "contrast": {
	 *            label: "contrast",
	 *            background_content: "#e4e4e4",
	 *            background_base: "#FFFFFF",
	 *            background_leftnav: "#f5f5f4",
	 *            color_link: "blue",
	 *            font: "arial, sans-serif",
	 *            color_base: "#000000"
	 *          }
	 *        }
	 *      });
	 */
	function ThemeSwitcher (params) {

		console.group("Constructing ThemeSwitcher");

		var self = this;

		if (params === true || params === undefined)
			params = {};


		params.template = params.template || this.template || template;
		self.themes = {};

		console.log('params.themes: ', params.themes);

		if (params.themes) {
			_.forEach(params.themes, function (theme, key) {
				self.addOption(key, theme.theme);
			});
		}

		BaseUI.call(self, params);

		console.groupEnd();
	}


	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(ThemeSwitcher, {
			current: '.js-current-theme',
			current_svg: '.js-current-svg',
			current_text: '.js-current-text',
			list: '.js-list'
		});


	_.extend(ThemeSwitcher.prototype, {
		_svg_template: _.template(__webpack_require__(173)),
		_option_template: _.template(__webpack_require__(174)),

		render: function () {
			BaseUI.prototype.render.apply(this, arguments);

			this.renderOptions();

			return this;
		},

		/**
		 * Adds a theme object to this.themes. Will trigger a console error if any required properties are missing.
		 * @memberof awf.ui.ThemeSwitcher
		 *
		 * @param {object} theme
		 * @param {string} key Required: the theme's ID
		 * @param {string} theme.label Required: the theme's label
		 * @param {string} theme.background_base Required: the theme's base background color
		 * @param {string} theme.background_leftnav Required: the theme's left navigation background color
		 * @param {string} theme.background_content Required: the theme's main content background color
		 * @param {string} theme.color_link Required: the theme's link color
		 * @param {string} theme.font Required: The theme font family
		 * @param {string} theme.color_base Required: The theme base font color
		 *
		 * @return {Object} self chainable
		 */
		addOption: function (key, theme) {
			console.log('Adding option: ', key);

			if (theme) {
				var given_keys = _.keys(theme),
					expected_keys = [
						"label",
						"background_base",
						"background_content",
						"background_leftnav",
						"color_link",
						"font",
						"color_base"
					],
					missing_keys = _.difference(expected_keys, given_keys);

				if (missing_keys.length === 0) {
					this.themes[key] = {
						label: theme.label,
						svg: this._svg_template({
							background_content: theme.background_content,
							background_base: theme.background_base,
							background_masthead: theme.background_masthead || theme.background_base,
							background_leftnav: theme.background_leftnav,
							color_link: theme.color_link,
							font: theme.font,
							color_base: theme.color_base
						})
					};
				} else {
					throw new Error("ThemeSwitcher.addOption() Error: The theme you're attempting to add is missing the following parameters: " + missing_keys);
				}
			}

			return this;
		},

		/**
		 * Deletes a theme object from this.themes
		 * @memberof awf.ui.ThemeSwitcher
		 * @param {string} id The id of the theme to be deleted
		 *
		 * @fires this#remove and passes the id of the deleted theme
		 * @return {Object} null if not found, otherwise the removed theme
		 */
		removeOption: function (id) {
			if (id in this.themes) {
				var theme = this.themes[id];
				delete this.themes[id];
				this.triggerHandler('remove', id);
				return theme;
			} else {
				return null;
			}
		},

		/**
		 * Updates the template's current theme display
		 * @memberof awf.ui.ThemeSwitcher
		 * @param {string} key a valid this.themes[key].id
		 *
		 * @return {Object} self chainable
		 */
		renderCurrent: function (key) {
			var self = this;

			self._$current_svg.html(self.themes[key].svg);
			self._$current_text.html(self.themes[key].label);
			self._$list.find('[data-theme=' + key + ']')
				.addClass('-is-selected')
				.attr({
					'aria-pressed': 'true'
				})
				.siblings()
				.removeClass('-is-selected')
				.attr({
					'aria-pressed': 'false'
				});

			return self;
		},

		/**
		 * Renders the template's theme options display. Creates a
		 * button for each this.themes. Each button listens for 'click',
		 * 'mouseover', and 'mouseout' events.
		 * On 'click' the button will trigger the 'click' event and pass its theme's id.
		 * On 'mouseover' the button will trigger the 'mouseover' event and pass its theme's id.
		 * On 'mouseout' the button will trigger the 'mouseout' event and pass no arguments.
		 * @memberof awf.ui.ThemeSwitcher
		 *
		 * @return {Object} self chainable
		 */
		renderOptions: function () {
			var self = this,
				hvr_timeout = null,
				was_hover_triggered = false;

			self._$list.empty();

			_.forEach(self.themes, function (theme, key) {
				var $button = $(self._option_template({
						theme: key,
						svg: theme.svg,
						label: theme.label
					}));

				$button
					.on('click', function() {
						self.triggerHandler('select-theme', key);
						$button.focus();
					})
					.on('mouseover', function () {
						hvr_timeout = setTimeout(function () {
							was_hover_triggered = true;
							$button.addClass('-is-hover');
							self.triggerHandler('apply-theme', key);
						},500);
					})
					.on('mouseout', function() {
						clearTimeout(hvr_timeout);
						if (was_hover_triggered) {
							was_hover_triggered = false;
							$button.removeClass('-is-hover');
							self.triggerHandler('reset-theme');
						}
					});

				self._$list.append($button);
			});

			return self;
		}

	});


/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = "<div class=\"themes\">\n\t<section class=\"js-current-theme themes__current -border-color-base\">\n\t\t<div class=\"js-current-svg themes__current__svg -border-color-base\"></div>\n\t\t<label class=\"themes__current__label\">current theme: <span class=\"js-current-text\"></span></label>\n\t</section>\n\t<section class=\"themes__options group -border-color-base\">\n\t\t<h2 class=\"themes__options__title\">Themes</h2>\n\t\t<div class='js-list themes__list'></div>\n\t</section>\n</div>\n";

/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports = "<svg class=\"svg-theme-sample -display-block\" height=\"75\" width=\"150\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<rect fill=\"{{background_content}}\" height=\"75\" width=\"150\" y=\"0\" x=\"0\" />\n\t<rect fill=\"{{background_leftnav}}\" height=\"75\" width=\"25\" y=\"0\" x=\"0\" />\n\t<rect fill=\"{{background_masthead}}\" height=\"15\" width=\"150\" y=\"0\" x=\"0\" />\n\t<rect fill=\"{{color_link}}\" height=\"20\" width=\"25\" y=\"15\" x=\"0\" />\n\t<rect ry=\"2\" rx=\"2\" fill=\"{{background_base}}\" height=\"40\" width=\"35\" y=\"25\" x=\"35\" />\n\t<text font-size=\"14\" font-family=\"{{font}}\" x=\"42\" y=\"42\" fill=\"{{color_base}}\">text</text>\n</svg>\n";

/***/ },
/* 174 */
/***/ function(module, exports) {

	module.exports = "<button class=\"themes__list__btn -awf-focus\" data-theme=\"{{theme}}\" aria-pressed=\"false\" role=\"button\">\n\t<div class=\"js-option-svg themes__list__btn__svg -border-color-base\">{{svg}}</div>\n\t<label class=\"themes__list__btn__label\">{{label}}</label>\n</button>\n";

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Tray;

	var $ = __webpack_require__(4),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		template = __webpack_require__(176);

	use(BaseUI).toCreate(Tray);

	/**
	 * Creates a slide-out tray UI component. There is a content area
	 * that is hidden by default, and control buttons for showing/hiding
	 * that content.
	 * @class
	 * @memberOf awf.ui
	 *
	 * @param {object} params
	 * @param {string} [params.label] The ARIA label to add to the
	 * component's show/hide buttons and content.
	 * @param {null|string} [params.class_name] The class name(s) to add to the
	 * component (can then be leveraged in project's CSS).
	 * @param {string|object} [params.content] The content of the Tray.
	 * Can be an HTML string or jQuery DOM object.
	 * @param {string|object} params.show_text The `show` button's text.
	 * Can be an HTML string or jQuery DOM object
	 * @param {string|object} params.hide_text The `hide` button's text.
	 * Can be an HTML string or jQuery DOM object
	 * @param {number} params.width The Tray content's width.
	 * @param {number} params.min_height The Tray content's minimum height.
	 * @param {number} params.bottom The Tray's bottom CSS property value.
	 * @param {string} [params.position] The Tray's CSS position. `fixed` or `absolute`.
	 * @param {string} [params.toggle_align] The Tray's toggle buttons
	 * alignment. `top` will align the buttons to the top of the tray.
	 * `bottom` will align the buttons to the bottom of the tray.
	 *
	 * @property {string} aria_id Automatically generated. Used for ARIA attributes.
	 * @property {null|string} label The ARIA label for the component's show/hide buttons and content.
	 * component's show/hide buttons and content.
	 * @property {null|string} class_name=null The component's additional class names.
	 * @property {boolean} active_state=false The current active state. `true` is active. `false` is inactive.
	 * @property {null|string|object} content=null The content.
	 * @property {null|string|object} show_text=null The show button's content.
	 * @property {null|string|object} hide_text=null The hide button's content.
	 * @property {null|number} width=null The content width.
	 * @property {null|number} min_height=null The content minimum height.
	 * @property {null|number} bottom=null The Tray's bottom CSS property value.
	 * @property {null|string} position='fixed' The Tray's CSS position.
	 * @property {null|string} toggle_align='bottom' The tray's toggle
	 * @property {undefined|boolean} _tooltip Adds a title attribute to the open and close button when `true`
	 * button alignment.
	 * @property {object} _$toggle jQuery shortcut to the toggle buttons' container.
	 * @property {object} _$toggle_show jQuery shortcut to the show button.
	 * @property {object} _$toggle_hide jQuery shortcut to the hide button.
	 * @property {object} _$content jQuery shortcut to the tray content.
	 *
	 * @extends {awf.ui.Base}
	 * @requires jQuery
	 *
	 * @example
	 *  // Creating a simple instance
	 *  var tray = new awf.ui.Tray({
	 *  	label: "Hello World Tray"
	 *  	width: 275, // required
	 *  	min_height: 360, // required
	 *  	bottom: 60, // required
	 *  	class_name: 'test-tray', // optional
	 *  	toggle_align: 'bottom', // optional
	 *  	position: 'fixed', // optional
	 *  	parent: $('#content'), // optional
	 *  	show_text: '<em class="awficon-info"></em> <span class="awf-access">Open</span>', // required
	 *  	hide_text: '<em class="awficon-close"></em> <span class="awf-access">Close</span>', // required
	 *  	content: '<p>Hello World!</p>'
	 *  });
	 *
	 */
	function Tray (params) {
		params = params || {};
		this.template = params.template || this.template || template;

		this.aria_id = awf.util.randomID();
		this.hide_timeout = null;
		this._tooltip = params.tooltip;

		BaseUI.call(this, params);

		awf.util.mixin.properties(this, params, {

			/**
			 * Adds all appropriate ARIA labelling to hide/show/content elements.
			 * @memberof awf.ui.Tray
			 *
			 * @name setLabel
			 * @function
			 *
			 * @param {null|string} val The label to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:label passing old and new values
			 */
			label: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {
					if (val) {
						this._$toggle_show
							.attr({
								'aria-label': 'Show ' + val,
								'title': this._tooltip ? 'Show ' + val : null
							});
						this._$toggle_hide
							.attr({
								'aria-label': 'Hide ' + val,
								'title': this._tooltip ? 'Show ' + val : null
							});
						this._$content
							.attr('aria-label', val + ' Content');
					} else {
						this._$toggle_show
							.attr({
								'aria-label': 'Show',
								'title': this._tooltip ? 'Show' : null
							});
						this._$toggle_hide
							.attr({
								'aria-label': 'Hide',
								'title': this._tooltip ? 'Hide' : null
							});
						this._$content
							.attr('aria-label', 'Content');
					}

				}
			},


			/**
			 * Adds passed value to the component's `class` attribute. Subsequent
			 * calls will remove any prior class names added.
			 * @memberof awf.ui.Tray
			 *
			 * @name setClassName
			 * @function
			 *
			 * @param {null|string} val The class name(s) to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:class_name passing old and new values
			 */
			class_name: {
				default: null,
				types: ['null','string'],
				renderHandler: function (val) {

					if (val) {
						this.$el.addClass(val);
					} else {
						this.$el.attr('class','awf-tray');
					}

				}
			},


			/**
			 * Sets the active state of the component and updates the DOM
			 * appropriately in order to show/hide the tray content.
			 * @memberof awf.ui.Tray
			 *
			 * @name setActiveState
			 * @function
			 *
			 * @param {boolean} val true to set active, false to set inactive.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:active_state passing old and new values
			 */
			active_state: {
				default: false,
				types: ['boolean'],
				renderHandler: function (val) {

					if (val) {
						this.$el.addClass('-is-active');
					} else {
						this.$el.removeClass('-is-active');
					}

				}
			},


			/**
			 * Sets the tray content. Can be an HTML string or a jQuery object.
			 * @memberof awf.ui.Tray
			 * @name setContent
			 * @function
			 *
			 * @param  {Null|String|Object} val The content to set.
			 * string or a jQuery object.
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:content passing old and new values
			 */
			content: {
				default: null,
				types: ['null','string','object'],
				renderHandler: function (val) {
					if (val === null) {
						this._$content.empty();
					} else {
						this._$content.html(val);
					}
				}
			},


			/**
			 * Sets the show button's text. Can be an HTML string or jQuery object.
			 * @memberof awf.ui.Tray
			 * @name setShowText
			 * @function
			 *
			 * @param  {Null|String|Object} val The `show` text to set.
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:show_text passing old and new values
			 */
			show_text: {
				default: null,
				types: ['null','string','object'],
				renderHandler: function (val) {
					if (val === null) {
						this._$toggle_show.empty();
					} else {
						this._$toggle_show.html(val);
					}
				}
			},


			/**
			 * Sets the hide button's text. Can be an HTML string or jQuery object.
			 * @memberof awf.ui.Tray
			 * @name setHideText
			 * @function
			 *
			 * @param  {Null|String|Object} val The `hide` text to set.
			 * @return {Object} this (chainable)
			 *
			 * @fires this#change:hide_text passing old and new values
			 */
			hide_text: {
				default: null,
				types: ['null','string','object'],
				renderHandler: function (val) {
					if (val === null) {
						this._$toggle_hide.empty();
					} else {
						this._$toggle_hide.html(val);
					}
				}
			},


			/**
			 * Sets the width of this._$content
			 * @memberof awf.ui.Tray
			 *
			 * @name setWidth
			 * @function
			 *
			 * @param {null|number} val The width to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:width passing old and new values
			 */
			width: {
				default: null,
				types: ['null','number']
			},


			/**
			 * Sets the minimum height of this._$content
			 * @memberof awf.ui.Tray
			 *
			 * @name setHeight
			 * @function
			 *
			 * @param {null|number} val The minimum height to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:height passing old and new values
			 */
			min_height: {
				default: null,
				types: ['null','number'],
				renderHandler: function (val) {
					if (val) {
						this._$content.css('min-height', val + 'px');
					} else {
						this._$content.css('min-height','');
					}
				}
			},


			/**
			 * Sets the CSS position of the tray.
			 * @memberof awf.ui.Tray
			 *
			 * @name setPosition
			 * @function
			 *
			 * @param {null|string} val='fixed' The CSS position to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:position passing old and new values
			 */
			position: {
				default: 'fixed',
				types: ['null','string'],
				renderHandler: function (val) {
					this.$el.css('position', (val == 'absolute') ? val : 'fixed');
				}
			},


			/**
			 * Sets the CSS bottom property of the tray.
			 * @memberof awf.ui.Tray
			 *
			 * @name setBottom
			 * @function
			 *
			 * @param {null|number} val=null The CSS bottom property to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:bottom passing old and new values
			 */
			bottom: {
				default: null,
				types: ['null','number'],
				renderHandler: function (val) {
					this.$el.css('bottom', val + 'px');
				}
			},


			/**
			 * Sets the show/hide button vertical alignment. `top` and `bottom` are
			 * the only two options, currently.
			 * @memberof awf.ui.Tray
			 *
			 * @name setPosition
			 * @function
			 *
			 * @param {null|string} val='bottom' The show/hide button vertical alignment to set.
			 * @return {Object} self chainable
			 *
			 * @fires this#change:toggle_align passing old and new values
			 */
			toggle_align: {
				default: 'bottom',
				types: ['null','string'],
				renderHandler: function (val) {
					if (val == 'top') {
						this._$toggle.css({
							'top': 0,
							'bottom': 'auto'
						});
					} else {
						this._$toggle.css({
							'top': 'auto',
							'bottom': 0
						});
					}
				}
			}

		});
	}





	/*	element shortcuts
	------------------------------------------*/
		BaseUI.generateDomProperties(Tray, {
			toggle: '.js-tray-toggle',
			toggle_show: '.js-tray-show',
			toggle_hide: '.js-tray-hide',
			content: '.js-tray-content',
			loop_last: '.js-loop-to-last',
			loop_first: '.js-loop-to-first'
		});





	_.extend(Tray.prototype, {

		/**
		 * Adds ARIA attributes and binds `click` events to the show/hide buttons.
		 * @memberof awf.ui.Tray
		 *
		 * @return {object} self chainable
		 */
		render: function () {
			var self = this;
			BaseUI.prototype.render.apply(this, arguments);

			self._$content
				.attr('id', this.aria_id);

			self._$toggle_show.add(self._$toggle_hide)
				.attr('aria-controls', this.aria_id);


			/*	Bind events
			------------------------------------------*/
				self._$toggle_show
					.on('click', function() {
						self.show();
					});

				self._$toggle_hide
					.on('click', function() {
						self.hide();
					});

			return self;
		},


		/**
		 * Shows the tray contents.<br>
		 *  - Updates ARIA attributes<br>
		 *  - Binds event listeners<br>
		 *  - Activates a tabloop through the tray contents
		 * @memberof awf.ui.Tray
		 *
		 * @return {object} self chainable
		 */
		show: function () {
			var self = this;
			clearTimeout(self.hide_timeout);
			self.$el.removeClass('-hiding');
			self._$content
				.css({
					width: self.width
				})
				.attr('aria-expanded', 'true');
			self
				.setActiveState(true)
				._$toggle_hide.focus();

			self.triggerHandler('tray:show');


			/*	Bind events
			------------------------------------------*/
				$('body')
					.on('click.tray_' + this.aria_id, function(e) {
						if ( !self.$el.is(e.target) && self.$el.has(e.target).length === 0) {
							self.hide(true);
						}
					})
					.on('keyup.tray_' + this.aria_id, function (e) {
						if (e.keyCode == awf.util.keyCodes.esc) {
							self.hide();
						}
					});

			/*	Tabloop
			------------------------------------------*/
				self._$loop_last
					.show()
					.on('focus', function () {
						self._$toggle.add(self._$content).find(':tabbable').last().focus();
					});

				self._$loop_first
					.show()
					.on('focus', function () {
						self._$toggle.add(self._$content).find(':tabbable').first().focus();
					});

			return self;
		},

		/**
		 * Hides the tray contents.<br>
		 *  - Updates ARIA attributes<br>
		 *  - Unbinds event listeners<br>
		 *  - Deactivates a tabloop through the tray contents
		 * @memberof awf.ui.Tray
		 *
		 * @param {boolean} [do_not_focus] By default, the `open` button gains focus
		 * when the tray is hidden. Setting this parameter to `true` will prevent that.
		 *
		 * @return {object} self chainable
		 */
		hide: function (do_not_focus) {
			var self = this;

			self.$el.addClass('-hiding');

			self._$content
				.css('width','')
				.attr('aria-expanded', 'false');


			self.hide_timeout = setTimeout(function () {
				self.setActiveState(false);
				self.$el.removeClass('-hiding');

				if ( ! do_not_focus) {
					self._$toggle_show.focus();
				}

				self.triggerHandler('tray:hide');
			}, 300);

			/*	Unbind events
			------------------------------------------*/
				$('body').off('keyup.tray_' + this.aria_id + ' click.tray_' + this.aria_id);
				self._$loop_last.hide().off('focus');
				self._$loop_first.hide().off('focus');

			return self;
		},


		/**
		 * Unbind `body` event
		 * @memberof awf.ui.Tray
		 *
		 * @return {object} self chainable
		 */
		destroy: function () {
			var self = this;
			BaseUI.prototype.destroy.apply(this, arguments);

			$('body').off('keyup.tray_' + this.aria_id + ' click.tray_' + this.aria_id);

			return self;
		}

	});


/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports = "<div class=\"awf-tray\">\n\t<button class=\"awf-access js-loop-to-last awf-tray__loop-last\" aria-hidden=\"true\">Loop to last</button>\n\t<div class=\"js-tray-toggle awf-tray__toggle -background-link\">\n\t\t<button class=\"js-tray-show awf-tray__toggle__show -awf-focus\"></button>\n\t\t<button class=\"js-tray-hide awf-tray__toggle__hide -awf-focus\"></button>\n\t</div>\n\t<div class=\"js-tray-content awf-tray__content -background-base\" role=\"region\" aria-expanded=\"false\"></div>\n\t<button class=\"awf-access js-loop-to-first awf-tray__loop-last\" aria-hidden=\"true\">Loop to first</button>\n</div>\n";

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = VerticalNavItem;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		BaseUI = awf.ui.Base,
		CollectionItem = awf.ui.CollectionItem;

	use(CollectionItem).toCreate(VerticalNavItem);

	/**
	 * VerticalNavItem UI Component
	 * @class
	 * @type {VerticalNavItem}
	 * @implements {VerticalNavItem}
	 * @memberOf awf.ui
	 * @extends {awf.ui.CollectionItem}
	 */
	function VerticalNavItem (params) {
		params = params || {};

		this.template = __webpack_require__(178);

		CollectionItem.apply(this, arguments);

		awf.util.mixin.properties(this, params, {

			label: {
				default: '',
				types: ['string'],
				renderHandler: function (val) {
					this._$label.html(val);
					this.$el.attr('title', val);
				}
			},

			active_state: {
				default: false,
				types: ['boolean'],
				renderHandler: function (is_active) {
					this.$el[is_active ? 'addClass' : 'removeClass']('-is-active');
					this.$el.attr({
						'tabindex': is_active ? '0' : '-1',
						'aria-pressed': is_active? 'true' : 'false'
					});
				}
			},

			icon: {
				default: null,
				types: ['null','string']
			},

			active_icon: {
				default: null,
				types: ['null','string']
			}
		});

		this.applyIcon();
		this.on('change:active_state change:icon change:active_icon', function () {
			this.applyIcon();
		});
	}

	BaseUI.generateDomProperties(VerticalNavItem, {
		label: '.js-label',
		icon: '.js-icon',
		button: '.js-button'
	});

	_.extend(VerticalNavItem.prototype, {

		/**
		 * Renders the UI.
		 * Assigns label and icon.
		 * Attaches a click event to the button that will tell the parent collection to `setActiveIndex` to `this.index()`
		 * @memberOf awf.ui.VerticalNavItem
		 * @return {object} this (chainable)
		 */
		render: function () {
			CollectionItem.prototype.render.apply(this, arguments);

			var self = this;

			self.$el.on('click', function () {
				if (self.collection) {
					var index = self.index();
					self.collection.setActiveIndex(index);
					self.collection.triggerHandler('click:item', [self.label, index]);
				} else {
					self.setActiveState(true);
				}
				self.$el.focus();
			});

			self.applyIcon().attachEvents();

			return self;
		},


		applyIcon: function () {
			var self = this;

			if (self.active_state === false || (self.active_state === true && ! self.active_icon)) {
				if (self.icon === null) {
					self._$icon.empty();
				} else {
					self._$icon
						.html('<em class="' + self.icon + '"></em>');
				}
			} else {
				self._$icon
					.html('<em class="' + self.active_icon + '"></em>');
			}

			return self;
		},


		attachEvents: function () {
			var $item = this.$el;
			$item
				.on('keydown', function(e){
					var tabIndex = $item.index(),
						tabsLength = $item.siblings().length;

					if (e.altKey || e.ctrlKey) {
						// do nothing
						return true;
					}

					switch (e.keyCode) {
						case awf.util.keyCodes.left:
						case awf.util.keyCodes.up: {
							if (tabIndex === 0) {
								// item is the first one:
								// switch to last item
								$item.siblings().last().focus();
							} else {
								// switch to previous item
								$item.prev().focus();
							}

							e.stopPropagation();
							return false;
						}
						case awf.util.keyCodes.right:
						case awf.util.keyCodes.down: {
							if (tabIndex == tabsLength) {
								// item is the last one:
								// switch to first item
								$item.siblings().first().focus();
							}
							else {
								// switch to next item
								$item.next().focus();
							}

							e.stopPropagation();
							return false;
						}
						case awf.util.keyCodes.home: {
							// switch to the first item
							$item.siblings().add($item).first().focus();

							e.stopPropagation();
							return false;
						}
						case awf.util.keyCodes.end: {
							// switch to the last item
							$item.siblings().add($item).last().focus();

							e.stopPropagation();
							return false;
						}
					}
				});

			return this;
		}

	});


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = "<button class=\"vertical-nav__item -awf-focus\" role=\"button\">\n\t<span class=\"vertical-nav__item__icon js-icon\"></span>\n\t<span class=\"vertical-nav__item__label js-label\"></span>\n</button>\n";

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = VerticalNav;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		use = __webpack_require__(21),
		Collection = awf.ui.Collection;

	use(Collection).toCreate(VerticalNav);

	/**
	 * @typedef leftnavConfig
	 * @memberof awf.ui.VerticalNav
	 * @type Object
	 *
	 * @description
	 * The leftnavConfig object is a sub-element of the AWF config ([awfConfig]{@link awf.awfConfig}) and Application Copmposition config ([appCompConfig]{@Link awf.__.App.appCompConfig}) initialization objects. It is used to describe the configurable elements of a page left navigator component. The configuration is used to build the navigator through {@link awf.init} or through [awf.app.compose]{@link awf.__.App.compose}.
	 *
	 * @property {object[]} data - An array of data objects representing a left nav item
	 */

	/**
	 * VerticalNav UI Component
	 * @class
	 * @type {VerticalNav}
	 * @implements {VerticalNav}
	 * @memberOf awf.ui
	 * @extends {awf.ui.Collection}
	 *
	 * @property {number} active_index The active/selected index
	 * @property {boolean} is_active The mobile active state
	 * @property {awf.ui.VerticalNavItem} Item The constructor for new nav items
	 */
	function VerticalNav (params) {

		params = params || {};

		this.template = params.template || __webpack_require__(180);

		awf.util.mixin.properties(this, params, {

			/**
			 * Assigns active_index property. Loops through all items, assigning the correct active state. To remove all active states, pass `-1`
			 * @name setActiveIndex
			 * @function
			 * @param {number} index The new index value
			 * @memberOf awf.ui.VerticalNav
			 * @return {object} this (chainable)
			 */
			active_index: {
				default: -1,
				types: ['number'],
				handler: function (val) {
					_.forEach(this.items, function (item, i) {
						item.setActiveState(i === val);
					});
				}
			},


			/**
			 * Assigns is_active property. When set to true, a class '-leftnav-active' is added to the HTML element, to be leveraged elsewhere.
			 * @name setIsActive
			 * @function
			 * @param {boolean} val The new is_active value
			 * @memberOf awf.ui.VerticalNav
			 * @return {object} this (chainable)
			 */
			is_active: {
				default: false,
				types: ['boolean'],
				handler: function (val) {
					if (val)
						setTimeout(function () { $('html').addClass('-leftnav-active'); }, 10); //wait so that transition won't break
					else
						$('html').removeClass('-leftnav-active');
				}
			}

		});

		Collection.apply(this, arguments);
	}


	_.extend(VerticalNav.prototype, {

		Item: awf.ui.VerticalNavItem

	});


/***/ },
/* 180 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vertical-nav\" role=\"toolbar\" aria-label=\"Experience Options\" aria-controls=\"layout\"></div>\n";

/***/ },
/* 181 */
/***/ function(module, exports) {

	awf.mouse = {
		x: 0,
		y: 0
	};

	awf.$(window).on('mousemove.awf_mouse', function (ev) {
		awf.mouse.x = ev.pageX;
		awf.mouse.y = ev.pageY;
		awf.mouse.offset = {
			x: ev.pageX - awf.$(window).scrollLeft(),
			y: ev.pageY - awf.$(window).scrollTop()
		};
	});


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	_.extend(awf.__, __webpack_require__(183));

	/**
	 * @instance user
	 * @memberOf awf
	 * @type {awf.__.User}
	 * 
	 * @description The default instance, created if [userConfig]{@link awf.__.User.userConfig} is included in the configuration for {@link awf.init} or [awf.app.compose]{@link awf.__.App.compose}
	 */
	awf.user = new awf.__.User();

	__webpack_require__(189);


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		User: __webpack_require__(184),
		IdentityManager: __webpack_require__(185),
		OpenIDAuthService: __webpack_require__(187),
		BlueGroups: __webpack_require__(188)
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = User;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		BaseModel = awf.__.BaseModel,
		use = __webpack_require__(21);

	use(BaseModel).toCreate(User);




	/**
	 * User
	 * 
	 * @class
	 * @memberOf awf.__
	 * @requires jQuery
	 * @augments {awf.__.BaseModel}
	 *
	 * @example
	 * // To adapt this object to your environment,
	 * // create a subclass of User and replace awf.__.User with the new definition.
	 *
	 * var User = awf.__.User;
	 * awf.util.use(User).toCreate(MyCustomUserClass);
	 * function MyCustomUserClass () {
	 * 	User.apply(this, arguments);
	 * }
	 *
	 * _.extend(MyCustomUserClass.prototype, {
	 *
	 * 	login: function () {
	 * 		// Add code to initiate login for your environment
	 * 		// Normally, sinse this method exists in the superclass, you'd want to call it. e.g.: User.prototype.login.apply(this, arguments);
	 * 		// However, in this case, don't. It will only throw a console warning.
	 * 	},
	 *
	 *	getAuthenticationStatus: function () {
	 * 		// Add code to initiate login for your environment
	 * 		// Normally, sinse this method exists in the superclass, you'd want to call it. e.g.: User.prototype.getAuthenticationStatus.apply(this, arguments);
	 * 		// However, in this case, don't. It will only throw a console warning.
	 * 	}
	 *
	 * });
	 *
	 * // Don't miss this last step
	 * // This way, when awf.init is called, it will use your definition, not the original, to instantiate awf.user
	 * awf.__.User = MyCustomUserClass;
	 *
	 */
	function User () {
		BaseModel.apply(this, arguments);

		var is_authenticated = null,
			authentication_dfr = $.Deferred();

		this.info = {};
		
		this.data = {};
		this.services = {};

		awf.util.mixin.properties(this, arguments, {

			resolution: {
				default: null,
				types: ['null','string']
			}

		});
		
		this.authentication = $.Deferred();

		this.authentication
			.done(function (result) {
				is_authenticated = result;
			});

		Object.defineProperty(this, 'is_authenticated', {
			enumerable: true,
			configurable: true,
			get: function () {
				return !! is_authenticated;
			}
		});
	}




	_.extend(User.prototype, {

		/**
		 * Initiates the login flow. Until adapted, this method will merely give a console warning.
		 * @memberOf awf.__.User
		 * @type {function}
		 *
		 * @example
		 * // When adapting `login` for your implementation, all that is needed is to initiate the login process
		 *
		 * // Such as:
		 * window.location = 'login.html';
		 *
		 * // ..or if you have a login overlay..
		 * openTheLoginOverlayPlease();
		 *
		 */
		login: function () {
			console.warn('User method `login` has not yet been adapted.');
		},



		/**
		 * Initiates a check for authentication. Until adapted, this method will merely give a console warning.
		 * @memberOf awf.__.User
		 * @type {function}
		 *
		 * @example
		 * // When adapting `getAuthenticationStatus` for your implementation, do the following:
		 * 1. Looks up the authenticated state for the current user (ajax call, cookie check, etc)
		 * 2. Updates awf.user.info
		 * 3. Return a promise to be resolved when the authentication state is known AND awf.user.info has been updated.
		 */
		getAuthenticationStatus: function () {
			console.warn('User method `getAuthenticationStatus` has not yet been adapted.');
		}

	});



/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = IdentityManager;



	var $ = __webpack_require__(4),
		_ = __webpack_require__(5);


	__webpack_require__(186);


	/**
	 * Propagates the identity of the user between various applications.
	 * @param {object} params see example below for all the params options.
	 *
	 * @class
	 * @memberOf awf.__
	 *
	 * @example
	 * // params key/value options
	 *
	 * // REQUIRED:
	 * hostname - String - the hostname of the cookie gen service
	 * cookie - String - the cookie name for the cookie gen service
	 * path - String - the path part of the ajax URL
	 * services - Object - key/value set of name/appId, e.g.: { "WSF":"12345-456789", "ABC":"67890-987654" }
	 *
	 * // OPTIONAL:
	 * port - Number - default: 80
	 * timeout - Number - default: 30000 // 30 seconds
	 *
	 * @example
	 *
	 * var id_man = new awf.__.IdentityManager({
	 *   hostname: 'prdpcrdw3n01.w3-969.ibm.com',
	 *   cookie: 'PD-W3-SSO-ID',
	 *   path: '/myw3/awf/sso/v1/ssotoken',
	 *   services: {
	 *     "CONNECTIONS": "123456987-65123561-8461828",
	 *     "CAREERSMART_TALENT": "84151682-12380005-535",
	 *     "WSF_UAT": "89612582-328126-0456148",
	 *     "WSF": "56016218-9845618-106821105"
	 *   }
	 * });
	 * 
	 */
	function IdentityManager (params) {

		var self = this;

		if (params === undefined)
			throw new Error('IdentityManager cannot be initialized without params');

		if ( ! ("hostname" in params))
			throw new Error('IdentityManager params require hostname to be defined');

		if ( ! ("cookie" in params))
			throw new Error('IdentityManager params require cookie to be defined');

		if ( ! ("path" in params))
			throw new Error('IdentityManager params require path to be defined');

		/**
		 * Prefix for saving timestamp in a session
		 * @private
		 * @readonly
		 * @memberof awf.__.IdentityManager
		 */
		var SESSION_STORAGE_KEY = 'IDENTITY-MANAGER-SUPPORTED-SERVICE-';

		/**
		 * Identity service configuration
		 * [Service Documentation]{@link https://w3-connections.ibm.com/wikis/home?lang=en-us#!/wiki/d71c33f6-1d71-4d24-9ef2-ee88747b4169/page/AWF-%20SSO%20Proxy%20Service}
		 * @private
		 * @readonly
		 * @memberof awf.__.IdentityManager
		 */
		var services = [],

			// required
			IDENTITY_HOSTNAME = params.hostname,
			IDENTITY_COOKIE = params.cookie,
			IDENTITY_PATH = params.path,
			IDENTITY_SEARCH = "?appId=",

			// optional
			IDENTITY_PORT = params.port || 80,
			IDENTITY_TIMEOUT = params.timeout || 30 * 1000; // 30 seconds


		(function () {
			var i = 0;
			_.forEach(params.services, function (appId, name) {
				services.push({
					uid: i++,
					name: name,
					appId: appId,
					expires: null,
					loading: false,
					pending: [],
					data: null,
					deferred: {}
				});
			});
		})();


		var LOG = null;

		/**
		 * Current list of services we can propogate identity for
		 * @public
		 * @alias SupportedServices
		 * @readonly
		 * @enum {number}
		 * @memberof awf.__.IdentityManager
		 */
		this.SupportedServices = {};

		_.forEach(services, function (service, i) {
			self.SupportedServices[service.name] = i;
		});


		/**
		 * Ensures the user has the required SSO tokens to call the external REST
		 * service without forcing the user to re-authenticate
		 * @public
		 * @alias ajax
		 * @memberof awf.__.IdentityManager
		 * @param {String} serviceIndex - Index of the Supported Service to authenticate against
		 * @param {Object} ajaxObject - jQuery ajax request params
		 */
		this.ajax = function (serviceIndex, ajaxObject) {
			// Make sure we support the service
			if (!serviceIsSupported.call(this, serviceIndex)) {
				return false;
			}

			if ( ! awf.user || (awf.user && ! awf.user.is_authenticated)) {
				LOG('!!! User is *NOT* authenticated !!!');
			}

			// Push pending request
			var service = services[serviceIndex];
				service.pending.push(ajaxObject);
				service.deferred = $.Deferred();

				LOG(service.name + ' >> Checking if old token is still valid');
			if ( ! service.expires || hasIdentityExpired(service.expires)) {
				if ( ! service.loading) {
					// Need to fetch a new identity token
					LOG(service.name + ' >> Fetching new token');
					propogateIdentity.call(this, service);
					return service.deferred.promise();
				}
			} else {
				// Re-use token
				LOG(service.name + ' >> Re-using token');
				executeAdopterRequests(service);
				return service.deferred.promise();
			}
		};

		/* Private functions
		------------------------------------------------------------------------------*/

			/**
			 * Constructor
			 * - load expiration data from session
			 * @private
			 * @alias init
			 * @memberof awf.__.IdentityManager
			 */
			function init () {
				LOG = function () {}; //awf.util.createPrefixedLog('SSO >> ');
				if (window.sessionStorage) {
					for (var key in this.SupportedServices) {
						if (sessionStorage[SESSION_STORAGE_KEY + this.SupportedServices[key]]) {
							var value = JSON.parse(sessionStorage[SESSION_STORAGE_KEY + this.SupportedServices[key]]);
							services[this.SupportedServices[key]].expires = value.date;
							services[this.SupportedServices[key]].data = value.data;
						}
					}
				}

			}
			init.call(this);

			/**
			 * Call the identity service to get back the token values
			 * @private
			 * @alias propogateIdentity
			 * @memberof awf.__.IdentityManager
			 * @param {Object} service - Params for requested service
			 */
			function propogateIdentity (service) {
				service.loading = true;

				return $.ajax({
					url: getIdentityUrl( service.appId ),
					timeout: IDENTITY_TIMEOUT,
					xhrFields: {
						withCredentials: true
					},
					success: function (response) {
						service.loading = false;
						if (response.cookieName && response.cookieValue) {
							LOG(service.name + ' >> SSO Service SUCCESS');

							// Handle correct response
							service.data = response;

							setExpirationTimestamp(service);
							executeAdopterRequests(service);

						} else {
							LOG(service.name + ' >> SSO Service ERROR >> 200 Code, weird');

							// Unexpected response
							executeAdopterErrors( service, {
								source: 'SSO Service',
								status: -1,
								responseText: 'Unexpected response'
							});
						}
					},
					error: function (er) {
						try {
							LOG(getSupportedServiceKey.call(this, service.uid) + ' >> SSO Service ERROR >> ' + JSON.stringify(er));
						} catch (err) {
							var json_string = '{{failed to stringify error}}';
							try {
								json_string = JSON.stringify(er);
							} catch (err2) {
								//
							}
							LOG('The propogateIdentity error log failed. >> SSO Service ERROR >> ' + json_string);
						}

						service.loading = false;
						executeAdopterErrors( service, {
							source: 'SSO Service',
							status: er.status,
							message: er.responseText
						});
					}
				});
			}

			/**
			 * Call the ajax query the adopter is waiting for
			 * @private
			 * @alias executeAdopterRequests
			 * @memberof awf.__.IdentityManager
			 * @param {Object} service - service to call
			 */
			function executeAdopterRequests (service) {
				// Make sure the correct token is in the header

				LOG(service.name + ' >> Adding cookie to header before fetch');
				LOG(service.name + ' >> Cookie Value = ' + JSON.stringify(service.data));
				removeIdentityCookie(service.data);
				writeIdentityCookie(service.data);

				LOG(service.name + ' >> Fetching from adopter service');

				var thenFn = function (response) {
					LOG(service.name + ' >> Adopter Service SUCCESS');
					service.deferred.resolve(response);
				}.bind(this);
				var failFn = function (er) {
					LOG(service.name + ' >> Adopter Service ERROR >> ' + JSON.stringify(er));
					service.deferred.reject(er);
				}.bind(this);

				// Ajax calls
				while (service.pending.length > 0) {
					var ajaxObject = service.pending.pop();
					$.ajax(ajaxObject).then(thenFn).fail(failFn);
				}
			}

			/**
			 * Call the error function from each adopter's request
			 * @private
			 * @alias executeAdopterErrors
			 * @memberof awf.__.IdentityManager
			 * @param {Object} service - service object
			 * @param {Object} er - error object
			 * @param {Number} er.status - error code
			 * @param {String} er.message - error explanation
			 */
			function executeAdopterErrors (service, er) {
				// Callbacks
				while (service.pending.length > 0) {
					var ajaxObject = service.pending.pop();


					if (ajaxObject.error) {
						ajaxObject.error(er);
					}
				}

				// Deferred
				service.deferred.reject(er);
			}

			/**
			 * The cookie expires in 10 minutes, so we set the timestamp for 9 min 30 sec
			 * in the future:
			 * 9 * 60 = 540. 540 + 30 = 570
			 * @private
			 * @alias setExpirationTimestamp
			 * @memberof awf.__.IdentityManager
			 * @param {Object} service - service which just had an identity cookie written
			 */
			function setExpirationTimestamp (service) {
				var date = new Date();
				date.setSeconds(date.getSeconds() + 570);

				// Set in memory
				service.expires = date;

				LOG(service.name + ' >> Set expire timestamp for ' + date);

				// Set in Session
				if (window.sessionStorage) {
					sessionStorage.setItem(SESSION_STORAGE_KEY + service.uid, JSON.stringify({ date: date, data: service.data }));
				}
			}

			/**
			 * Return the url for the Identity service
			 * @private
			 * @alias serviceIsSupported
			 * @memberof awf.__.IdentityManager
			 * @param {integer} value - Value of the service being asked for
			 * @return {boolean}
			 */
			function serviceIsSupported (value) {
				for (var key in this.SupportedServices) {
					if (this.SupportedServices[key] === value) {
						return true;
					}
				}

				return false;
			}

			/**
			 * Removes any cookies with the same name as we're going write
			 * @private
			 * @alias removeIdentityCookie
			 * @memberof awf.__.IdentityManager
			 * @param {Object} obj
			 * @param {String} obj.cookieDomain - Domain to write cookie in
			 * @param {String} obj.cookieName - Name of the cookie
			 * @param {String} obj.cookiePath - Path to write cookie in
			 * @param {String} obj.cookieValue - Value of the cookie
			 * @param {number} obj.maxAge - When the cookie expires (-1 for session cookie)
			 * @param {boolean} obj.secureCookie - true, if only sent via HTTPS
			 */
			function removeIdentityCookie (obj) {
				document.cookie = obj.cookieName + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; domain=' + obj.cookieDomain + '; path=/;';//' secure;';
			}

			/**
			 * Add the identity cookie to the browser
			 * @private
			 * @alias writeIdentityCookie
			 * @memberof awf.__.IdentityManager
			 * @param {Object} obj
			 * @param {String} obj.cookieDomain - Domain to write cookie in
			 * @param {String} obj.cookieName - Name of the cookie
			 * @param {String} obj.cookiePath - Path to write cookie in
			 * @param {String} obj.cookieValue - Value of the cookie
			 * @param {number} obj.maxAge - When the cookie expires (-1 for session cookie)
			 * @param {boolean} obj.secureCookie - true, if only sent via HTTPS
			 */
			function writeIdentityCookie (obj) {
				document.cookie = obj.cookieName + '=' + obj.cookieValue + '; domain=' + obj.cookieDomain + '; path=/;';//secure;';
			}

			/**
			 * Check if the cookie is still valid
			 * @private
			 * @alias hasIdentityExpired
			 * @memberof awf.__.IdentityManager
			 * @param {String} expirationDateString - Duration the cookie is valid for
			 */
			function hasIdentityExpired (expirationDateString) {
				if (expirationDateString) {
					var expirationDate = new Date(expirationDateString);
					if (expirationDate < new Date()) {
						return true;
					}
				}
				return false;
			}

			/**
			 * NOTE: FOR NOW -- we use HTTP -- because HTTPS is NOT YET supported.
			 * TODO: UPGRADE TO USE HTTPS WHEN IT IS AVAILABLE
			 * Return the url for the Identity service
			 * @private
			 * @alias getIdentityUrl
			 * @memberof awf.__.IdentityManager
			 * @param {String} appId - Id for the service we want a LTPAToken2 for
			 * @return {String}
			 */
			function getIdentityUrl (appId) {
				return 'https://' + IDENTITY_HOSTNAME + IDENTITY_PATH + IDENTITY_SEARCH + appId;
			}
	}



/***/ },
/* 186 */
/***/ function(module, exports) {

	awf.registerExternalInitHandler('user', 'identity_manager', function (identity_manager_hold, identity_manager_config) {

		awf.user.identity_manager = new awf.__.IdentityManager(identity_manager_config);

		identity_manager_hold.resolve('done');

	});


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = OpenIDAuthService;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		Base = awf.__.Service,
		use = __webpack_require__(21),
		LS_TOKEN_KEY = 'TOKEN-OBJ',
		LS_CALLBACK_URL = 'CALLBACK-URL';

	use(Base).toCreate(OpenIDAuthService);


	/**
	 * @param {Object} params
	 * @param {string} params.client_id Client ID of the partner. Set when creating the partner to the OP federation.
	 * @param {string} params.client_secret Client Secret set when creating the partner to the OP federation.
	 * @param {string} params.scope The scope of the grant to request from the user. Space separated string that must include `openid`.
	 * @param {string} params.redirect_uri The URI to redirect the users browser to after the authorization
	 * @param {String} params.prefix The local storage prefix for storing tokens
	 * @param {String} params.auth_endpoint The authorization service endpoint URL
	 * @class OpenIDAuthService
	 * @memberOf awf.__
	 * @requires jQuery
	 * @requires Lodash
	 * @augments {awf.__.Service}
	 *
	 * @example
	 * var oauth = new awf.__.OpenIDAuthService({
	 *       prefix: 'AWF-',
	 *       client_id: 'XYZpqrsABC',
	 *       client_secret: 'ABCpqrsXYZ',
	 *       scope: 'openid',
	 *       auth_endpoint: 'https://www.acme.com/openid/authorize',
	 *       redirect_uri: 'https://www.acme.com/redirect.html'
	 *     });
	 *
	 * // Initiate login by calling the signIn() method, or by attempting to fetch data
	 *
	 * oauth.signIn();
	 * // or
	 * oauth.fetch('SOME_OPENID_CONNECT_ENABLED_ENDPOINT');
	 *
	 * // in your redirect.html you'll want to do at least the following
	 * var oauth = new awf.__.OpenIDAuthService({
	 *       prefix: 'AWF-' // must match in order to grab the correct info from localstorage
	 *     });
	 * oauth.storeToken();
	 * oauth.returnToCallbackUrl();
	 */
	function OpenIDAuthService (params) {
		params = params || {};
		Base.apply(this, arguments);

		Object.defineProperty(this, "prefix", {
			enumerable: true,
		    value: params.prefix || this.prefix || null,
		    writable: false
		});

		Object.defineProperty(this, "auth_endpoint", {
			enumerable: true,
		    value: params.auth_endpoint || this.auth_endpoint || null,
		    writable: false
		});

		Object.defineProperty(this, "client_id", {
			enumerable: true,
		    value: params.client_id || this.client_id || null,
		    writable: false
		});

		Object.defineProperty(this, "client_secret", {
			enumerable: true,
		    value: params.client_secret || this.client_secret || null,
		    writable: false
		});

		Object.defineProperty(this, "scope", {
			enumerable: true,
		    value: params.scope || this.scope || null,
		    writable: false
		});

		Object.defineProperty(this, "redirect_uri", {
			enumerable: true,
		    value: params.redirect_uri || this.redirect_uri || null,
		    writable: false
		});
	}


	_.extend(OpenIDAuthService.prototype, {

		/**
		 * Reads token from storage, evaluates expiration date and returns token if
		 * its still valid or `false`.
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 * @return {Object|false} Auth token or `false`
		 */
		hasValidToken: function () {
			// Load token object from localStorage
			var token = awf.util.getStoredObject(this.prefix + LS_TOKEN_KEY);
			if (token) {
				var now = new Date(),
					expires = new Date(token.expires);
				if (now < expires) {
					return token;
				}
			}
			return false;
		},


		/**
		 * Retrieve data from the protected endpoint
		 * @param {string} url Endpoint location
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 * @return {Promise} Promise for final service response or workflow error
		 */
		oldFetch: function (url) {
			// Load token object from localStorage
			var token = this.hasValidToken(),
				promise = new Promise(function (resolve, reject) {
					if (token) {
						// Hit endpoint
						xhr(url, token.access_token, resolve, reject);
					} else {
						// No token, so send user to sign in
						this.signIn();
					}
				}.bind(this));

			return promise;
		},


		onFetch: function (deferred, url) {
			var token = this.hasValidToken(), // Load token object from localStorage
				authorization = 'Bearer ' + token; // Create authorization header

			if (token) {
				// Hit endpoint
				$.ajax({
					xhrFields: {
						withCredentials: true
					},
					headers: {
						"Conent-Type": "application/json",
						"Authorization": authorization
					},
					type: "GET",
					url: url
				})
					.done(function (response) {
						if (response) {
							try {
								var responseObj = JSON.parse(req.response);
								deferred.resolve(responseObj);
							} catch (er) {
								deferred.reject('unable to parse response');
							}
						} else {
							deferred.reject('no response data');
						}
					})
					.fail(function (er) {
						deferred.reject(er);
					});


				// req.open('GET', url, true);
				// req.withCredentials = true;
				// req.setRequestHeader('Content-Type', 'application/json');
				// req.setRequestHeader('Authorization', authorization);
				// req.onreadystatechange = function () {
				// 	if (req.readyState === 4) {
				// 		if (req.status === 200) {
				// 			if (req.responseText) {
				// 				var responseObj = JSON.parse(req.responseText);
				// 				deferred.resolve(responseObj);
				// 			} else {
				// 				deferred.resolve();
				// 			}
				// 		} else {
				// 			deferred.reject();
				// 		}
				// 	}
				// };
				// req.send(null);
			} else {
				// No token, reject the deferred object
				deferred.reject('no token');
			}

		},


		/**
		 * Remove the tokens from local storage
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 * @return {Object} The removed tokens object
		 */
		wipeTokens: function () {
			var tokens = awf.util.getStoredObject(this.prefix + LS_TOKEN_KEY);
			localStorage.removeItem(this.prefix + LS_TOKEN_KEY);
			return tokens;
		},


		/**
		 * Store origin url and navigation to Authenitcation page
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 */
		signIn: function () {
			// Stash callback url
			awf.util.setStoredObject(this.prefix + LS_CALLBACK_URL, {
				url: encodeURIComponent(window.location.href)
			});

			// Get authentication url
			var url = this._getSignInUrl();

			// Go to authentication page
			window.location = url;
		},


		/**
		 * Parse token in the url and store it in local storage
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 */
		storeToken: function () {
			var token = {};

			// Take hash from position 1 to the end because we do not need the '#'
			var hash = window.location.hash.substr(1),
				params = hash.split('&');

			for (var i = 0; i < params.length; i++) {
				var kv = params[i].split('=');
				// Don't save time until expires; save expiration date
				if (kv[0] === 'expires_in') {
					var date = new Date();
					date.setSeconds(date.getSeconds() + parseInt(kv[1], 10));
					kv[0] = 'expires';
					kv[1] = date.toString();
				}
				token[kv[0]] = kv[1];
			}

			// Store
			awf.util.setStoredObject(this.prefix + LS_TOKEN_KEY, token);
		},


		/**
		 * Retrieve original url from storage and navigate to it
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 */
		returnToCallbackUrl: function () {
			var urlObject = awf.util.getStoredObject(this.prefix + LS_CALLBACK_URL);
			window.location = decodeURIComponent(urlObject.url);
		},

		/**
		 * Build authentication url with configuration parameters
		 * @memberOf awf.__.OpenIDAuthService
		 * @instance
		 * @return {string} Authentication endpoint
		 */
		_getSignInUrl: function () {
			var url = this.auth_endpoint + awf.util.urlParams({
					response_type: "code",
					redirect_uri: this.redirect_uri,
					client_id: this.client_id,
					scope: this.scope
				});
			return url;
		}
	});


	function xhr (url, token, resolve, reject) {
		// Create authorization header
		var authorization = 'Bearer ' + token;

		// Make request
		var req = new XMLHttpRequest();
		req.open('GET', url, true);
		req.withCredentials = true;
		req.setRequestHeader('Content-Type', 'application/json');
		req.setRequestHeader('Authorization', authorization);
		req.onreadystatechange = function () {
			if (req.readyState === 4) {
				if (req.status === 200) {
					if (req.responseText) {
						var responseObj = JSON.parse(req.responseText);
						resolve(responseObj);
					} else {
						resolve();
					}
				} else {
					reject();
				}
			}
		};
		req.send(null);
	}


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = BlueGroups;

	var $ = __webpack_require__(4),
		_ = __webpack_require__(5),
		Service = awf.__.Service,
		use = __webpack_require__(21);

	use(Service).toCreate(BlueGroups);


	/**
	 * <strong>*NOTE:</strong> This Class is currently only relevant when the
	 * w3 Feature Pack is included in your project. It automatically parses data
	 * from a service endpoint for you, and that data structure is specific to IBM
	 * BlueGroups.<br>
	 * Creates a BlueGroups service instance for a specified user based
	 * on the user's email address. The user's email should be included in
	 * the service's endpoint URL.
	 *
	 * @class
	 * @memberOf awf.__
	 * @requires jQuery
	 * @requires lodash
	 * @requires w3FeaturePack
	 * @augments {awf.__.Service}
	 *
	 * @param {object} params
	 * @param {string|null} params.endpoint The BlueGroup service endpoint URL
	 * @param {string|null} [params.appid] The appid for the service
	 *
	 * @property {string|null} endpoint=null The BlueGroup service endpoint URL
	 * @property {string|null} appid=null The instance appid for the service
	 * @property {array} data The fetched and parsed data
	 *
	 * @example
	 * // Manually creating an instance for the user
	 *
	 * awf.user.services.blue_groups = new awf.__.BlueGroups({
	 *     endpoint: '//' + window.location.host + '/proxy/BpHttpApisv3/slaphapi?ibmperson/mail=' + awf.user.info.email + '.list/byjson?ibm-allgroups',
	 *     appid: null
	 * });
	 *
	 * // or create an instance for another user/person
	 *
	 * var new_person = {},
	 *     new_person.email = 'foo@bar.com',
	 *     new_person.blue_groups = new awf.__.BlueGroups({
	 *          endpoint: '//' + window.location.host + '/proxy/BpHttpApisv3/slaphapi?ibmperson/mail=' + new_person.email + '.list/byjson?ibm-allgroups',
	 *          appid: null
	 *     });
	 *
	 */
	function BlueGroups (params) {
		var self = this;
		params = params || {};

		Service.apply(self, arguments);

		awf.util.mixin.properties(self, params, {

			/**
			 * Sets this.endpoint
			 * @memberOf awf.__.BlueGroups
			 * @name setEndpoint
			 * @function
			 * @instance
			 *
			 * @param  {string|null} value the service's endpoint URL
			 *
			 * @return {Object} this chainable
			 *
			 * @fires this#change:endpoint
			 */
			endpoint: {
				default: null,
				types: ['string','null']
			},


			/**
			 * Sets this.timeout
			 * @memberOf awf.__.BlueGroups
			 * @name setTimeout
			 * @function
			 * @instance
			 *
			 * @param  {string|null} value the service's timeout URL
			 *
			 * @return {Object} this chainable
			 *
			 * @fires this#change:timeout
			 */
			timeout: {
				default: null,
				types: ['null','number']
			},


			/**
			 * Sets this.appid
			 * @memberOf awf.__.BlueGroups
			 * @name setAppId
			 * @function
			 * @instance
			 *
			 * @param  {string|null} value the appid for the service
			 *
			 * @return {Object} this chainable
			 *
			 * @fires this#change:appid
			 */
			appid: {
				default: null,
				types: ['string','null']
			}

		});


		self.data = [];
	}


	_.extend(BlueGroups, {

		/**
		 * NOTE: This method is a helper method that should not be used
		 * independently.<br>
		 * Parses raw data from the BlueGroups service and returns an object
		 * that is more easily filtered for later inquiries.
		 * @memberOf awf.__.BlueGroups
		 *
		 * @param {object} data Raw BlueGroups data
		 *
		 * @return {object} The parsed BlueGroups data
		 */
		_parseRawData: function (data) {
			if (typeof(data) == "string")
				data = JSON.parse(data);

			data = data.search.entry[0].attribute[0].value;

			return _.map(data, function (group) {
				var obj = {};
				_.forEach(group.split(','), function (section) {
					var kv = section.split('=');
					obj[kv[0]] = kv[1];
				});
				return obj;
			});
		}

	});


	_.extend(BlueGroups.prototype, {


		onFetch: function (dfr) {
			var self = this;

			console.time('bluegroups');
			dfr.always(function () {
				console.timeEnd('bluegroups');
			});

			if (self.endpoint) {

				switch (awf.util.url_params.bluegroups) {

					case "fail":
						console.log("-- forcing Bluegroups service to fail...");

						setTimeout(function () {
							dfr.reject('Bluegroups service was forced to fail');
						}, 500);
						break;


					case "timeout":
						console.log("-- forcing Bluegroups service to timeout...");

						setTimeout(function () {
							dfr.reject('Bluegroups service was forced to timeout');
						}, self.timeout || 5000);
						break;


					case 'hang':
						console.log("-- forcing Bluegroups service to hang...");
						break;


					default:

						var delayed_success_dfr = awf.util.urlDelayedDeferred('bluegroups');

						$.ajax({
								url: self.endpoint,
								data: {
									appid: self.appid || ''
								},
								timeout: self.timeout
							})
							.done(function (response) {

								delayed_success_dfr.done(function () {
									try {
										var parsed = BlueGroups._parseRawData(response);
										self.data = parsed;
										dfr.resolve(parsed);
									} catch (er) {
										dfr.reject('failed to parse bluegroup data');
									}
								});

							})
							.fail(dfr.reject);
				}

			} else {
				dfr.reject('BlueGroup endpoint was not defined.');
			}

		},


		/**
		 * Checks if the BlueGroup exists for the user and returns a promise.
		 * The promise's done() response will be a boolean value. <em>True</em>
		 * indicates that the user is a part of the BlueGroup. <em>False</em>
		 * indicates that the user is <strong>not</strong> a part of the
		 * BlueGroup.<br>
		 * When called for the first time, this method will fetch and store
		 * data from the BlueGroup service.
		 * @memberOf awf.__.BlueGroups
		 * @instance
		 *
		 * @param {string} name The BlueGroup name to check
		 *
		 * @example
		 *
		 * awf.user.services.blue_groups.checkForBlueGroup('All-US-NonLenovo')
		 *     .done(function (response) {
		 *         if (response)
		 *             console.log('user is in the BlueGroup!');
		 *         else
		 *             console.log('user is not in the BlueGroup :-(');
		 *     })
		 *     .fail(function (er) {
		 *         console.log('the check failed to completed because of: ', er);
		 *     });
		 *
		 * @return {$.Deferred} A promise that will resolve/reject when fetch is complete
		 */
		checkForBlueGroup: function (name) {
			var dfr = $.Deferred();

			this.fetch(-1)
				.done(function (response) {
					dfr.resolve(_.filter(response, {cn:name}).length > 0);
				})
				.fail(function (er) {
					dfr.reject(er);
				});

			return dfr.promise();
		},


		/**
		 * @memberOf awf.__.BlueGroups
		 * @instance
		 *
		 * @param {string} name Name of the BlueGroup
		 *
		 * @example
		 *
		 * if (awf.user.services.blue_groups.hasBlueGroup('All-US-NonLenovo')) {
		 *   // codeblock for user IN the bluegroup
		 * } else {
		 *   // codeblock for user NOT in the bluegroup
		 * }
		 *
		 * @return {boolean} `true` if the user is a part of the group, `false` if not
		 */
		hasBlueGroup: function (name) {
			return _.filter(this.data, {cn:name}).length > 0;
		}

	});


	/**
	 * <strong>*NOTE:</strong> This instance is only created when the w3 Feature Pack is included in your project.<br>
	 * The default instance, created if included in awf.app.compose(). The BlueGroups service <strong>should</strong>
	 * require a person's e-mail address. For the purposes of config, use the token <em>{{email}}</em> in the appropriate
	 * place of your endpoint url config, and app composition will update it with the user's email for you.
	 *
	 * @type {awf.__.BlueGroups}
	 * @see {@link awf.__.BlueGroups} for more details
	 * @memberOf awf.user
	 * @name awf.user.services.blue_groups
	 * @namespace  awf.user.services.blue_groups
	 *
	 * @example
	 *
	 * awf.app.compose({
	 *     id: "my_app",
	 *     user: {
	 *         blue_groups: {
	 *             service: {
	 *                 endpoint: "/proxy/BpHttpApisv3/slaphapi?ibmperson/mail={{email}}.list/byjson?ibm-allgroups",
	 *                 appid: "my_bluegroups_app",
	 *                 blocking: true
	 *             }
	 *         }
	 *     },
	 *     layout: ....
	 * });
	 *
	 */


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(190);
	__webpack_require__(191);


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);

	_.extend(awf.__.FeatureToggler.handlers, {

		authenticated: {
			check: function (obj) {
				if ( ! awf.user)
					return !obj;

				return obj === awf.user.is_authenticated;
			},

			setupChangeHandler: function (ping) {

				if (awf.user.authentication.state() == 'pending') {
					awf.user.authentication
						.done(ping);
				}

			}
		}

	});


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);

	_.extend(awf.__.FeatureToggler.handlers, {

		'email': {
			check: function (obj) {
				if ( ! (awf.user && awf.user.is_authenticated))
					return false;

				var email = _.get(awf.user, 'info.email');

				if (email) {
					email = email.toLowerCase();
				}

				switch (typeof obj) {
					case "string":
						obj = obj.toLowerCase();
						return obj === email;

					case "object":
						obj = _.map(obj, function(val) {
							return val.toLowerCase();
						});
						return _.contains(obj, email);

					default:
						return null;
				}
			},

			setupChangeHandler: function (ping) {

				if (awf.user.authentication.state() == 'pending') {
					awf.user.authentication
						.done(ping);
				}

			}
		},



		'email-rolling-release': {
			check: function (obj) {
				if ( ! (awf.user && awf.user.is_authenticated))
					return false;

				var email = _.get(awf.user, 'info.email');
				if (typeof email !== "string")
					return false;

				var email_char = email.charAt(0).toLowerCase();
				return obj.toLowerCase().indexOf(email_char) > -1;
			},

			setupChangeHandler: function (ping) {

				if (awf.user.authentication.state() == 'pending') {
					awf.user.authentication
						.done(ping);
				}

			}
		},



		'cnum': {
			check: function (obj) {
				if ( ! (awf.user && awf.user.is_authenticated))
					return false;

				var cnum = _.get(awf.user, 'info.cnum');

				switch (typeof obj) {
					case "string":
						return obj === cnum;

					case "object":
						return _.contains(obj, cnum);

					default:
						return null;
				}
			},

			setupChangeHandler: function (ping) {

				if (awf.user.authentication.state() == 'pending') {
					awf.user.authentication
						.done(ping);
				}

			}
		},



		'cc': {
			check: function (obj) {
				if ( ! (awf.user && awf.user.is_authenticated))
					return false;

				var last_three_of_cnum = _.get(awf.user, 'info.cnum').split('').reverse().splice(0,3).reverse().join('');

				switch (typeof obj) {
					case "string":
						return obj === last_three_of_cnum;

					case "object":
						return _.contains(obj, last_three_of_cnum);

					default:
						return null;
				}
			},

			setupChangeHandler: function (ping) {

				if (awf.user.authentication.state() == 'pending') {
					awf.user.authentication
						.done(ping);
				}

			}
		}

	});


/***/ }
/******/ ]);